// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/witx-bindgen` command

use core::fmt;
use core::mem::MaybeUninit;
#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct RdmaError(u16);
pub const RDMA_ERROR_SUCCESS: RdmaError = RdmaError(0);
pub const RDMA_ERROR_RUNTIME_ERROR: RdmaError = RdmaError(1);
pub const RDMA_ERROR_IO_ERROR: RdmaError = RdmaError(2);
impl RdmaError {
    pub const fn raw(&self) -> u16 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "SUCCESS",
            1 => "RUNTIME_ERROR",
            2 => "IO_ERROR",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for RdmaError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RdmaError")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct AiFlags(u8);
pub const AI_FLAGS_RAI_PASSIVE: AiFlags = AiFlags(0);
pub const AI_FLAGS_RAI_NUMERICHOST: AiFlags = AiFlags(1);
pub const AI_FLAGS_RAI_NOROUTE: AiFlags = AiFlags(2);
pub const AI_FLAGS_RAI_FAMILY: AiFlags = AiFlags(3);
impl AiFlags {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "RAI_PASSIVE",
            1 => "RAI_NUMERICHOST",
            2 => "RAI_NOROUTE",
            3 => "RAI_FAMILY",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            3 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for AiFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AiFlags")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct AiPortSpace(u8);
pub const AI_PORT_SPACE_RDMA_PS_UDP: AiPortSpace = AiPortSpace(0);
pub const AI_PORT_SPACE_RDMA_PS_TCP: AiPortSpace = AiPortSpace(1);
pub const AI_PORT_SPACE_RDMA_PS_IB: AiPortSpace = AiPortSpace(2);
impl AiPortSpace {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "RDMA_PS_UDP",
            1 => "RDMA_PS_TCP",
            2 => "RDMA_PS_IB",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for AiPortSpace {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AiPortSpace")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct AiFamliy(u8);
pub const AI_FAMLIY_AF_IB: AiFamliy = AiFamliy(0);
pub const AI_FAMLIY_AF_INET: AiFamliy = AiFamliy(1);
pub const AI_FAMLIY_AF_INET6: AiFamliy = AiFamliy(2);
impl AiFamliy {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "AF_IB",
            1 => "AF_INET",
            2 => "AF_INET6",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for AiFamliy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AiFamliy")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct AiQpType(u8);
pub const AI_QP_TYPE_IBV_UD: AiQpType = AiQpType(0);
pub const AI_QP_TYPE_IBV_RC: AiQpType = AiQpType(1);
impl AiQpType {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "IBV_UD",
            1 => "IBV_RC",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for AiQpType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AiQpType")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct IbvQpType(u8);
pub const IBV_QP_TYPE_IBV_QPT_RC: IbvQpType = IbvQpType(0);
pub const IBV_QP_TYPE_IBV_QPT_UC: IbvQpType = IbvQpType(1);
pub const IBV_QP_TYPE_IBV_QPT_UD: IbvQpType = IbvQpType(2);
impl IbvQpType {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "IBV_QPT_RC",
            1 => "IBV_QPT_UC",
            2 => "IBV_QPT_UD",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for IbvQpType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("IbvQpType")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

pub type Id = u32;
pub type IbvMr = u32;
pub type IbvWc = u32;
pub type RdmaAddrinfo = u32;
pub type Context = u32;
pub type ConnParam = u32;
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct RdmaAddrinfoStruct {
    pub flags: AiFlags,
    pub port_space: AiPortSpace,
    pub family: AiFamliy,
    pub qp_type: AiQpType,
    pub src_len: u32,
    pub dst_len: u32,
    pub canonname: &str,
}
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct IbvQpCap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
pub type RdmaCq = u32;
pub type EpPd = u32;
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct IbvQpInitAttr {
    pub qp_context: Id,
    pub send_cq: RdmaCq,
    pub recv_cq: RdmaCq,
    /// (field $srq (handle))
    pub cap: IbvQpCap,
    pub qp_type: IbvQpType,
    pub sq_sig_all: u8,
}
pub unsafe fn rdma_getaddrinfo(
    node: &str,
    service: &str,
    hints: RdmaAddrinfoStruct,
) -> Result<RdmaAddrinfo, RdmaError> {
    let mut rp0 = MaybeUninit::<RdmaAddrinfo>::uninit();
    let ret = rdma::rdma_getaddrinfo(
        node.as_ptr() as i32,
        node.len() as i32,
        service.as_ptr() as i32,
        service.len() as i32,
        &hints as *const _ as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(
            rp0.as_mut_ptr() as i32 as *const RdmaAddrinfo
        )),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_create_ep(
    id: Id,
    res: RdmaAddrinfo,
    pd: EpPd,
    qp_init_attr: IbvQpInitAttr,
) -> Result<(), RdmaError> {
    let ret = rdma::rdma_create_ep(
        id as i32,
        res as i32,
        pd as i32,
        &qp_init_attr as *const _ as i32,
    );
    match ret {
        0 => Ok(()),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_freeaddrinfo(res: RdmaAddrinfo) -> Result<(), RdmaError> {
    let ret = rdma::rdma_freeaddrinfo(res as i32);
    match ret {
        0 => Ok(()),
        _ => Err(RdmaError(ret as u16)),
    }
}

///
/// ## Parameters
///
/// * `addr` - Register the memory region for the message buffer
pub unsafe fn rdma_reg_msgs(id: Id, addr: *mut u8) -> Result<IbvMr, RdmaError> {
    let mut rp0 = MaybeUninit::<IbvMr>::uninit();
    let ret = rdma::rdma_reg_msgs(id as i32, addr as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const IbvMr)),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_dereg_mr(mr: IbvMr) -> Result<(), RdmaError> {
    let ret = rdma::rdma_dereg_mr(mr as i32);
    match ret {
        0 => Ok(()),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_post_send(id: Id, context: Context, addr: *mut u8, send_mr: IbvMr, flags: u32) {
    rdma::rdma_post_send(
        id as i32,
        context as i32,
        addr as i32,
        send_mr as i32,
        flags as i32,
    );
}

pub unsafe fn rdma_destroy_ep(id: Id) -> Result<(), RdmaError> {
    let ret = rdma::rdma_destroy_ep(id as i32);
    match ret {
        0 => Ok(()),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_post_recv(id: Id, context: Context, addr: *mut u8, recv_mr: IbvMr) {
    rdma::rdma_post_recv(id as i32, context as i32, addr as i32, recv_mr as i32);
}

pub unsafe fn rdma_get_send_comp(id: Id, wc: IbvWc) -> Result<IbvWc, RdmaError> {
    let mut rp0 = MaybeUninit::<IbvWc>::uninit();
    let ret = rdma::rdma_get_send_comp(id as i32, wc as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const IbvWc)),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_get_recv_comp(id: Id, wc: IbvWc) -> Result<IbvWc, RdmaError> {
    let mut rp0 = MaybeUninit::<IbvWc>::uninit();
    let ret = rdma::rdma_get_recv_comp(id as i32, wc as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const IbvWc)),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_connect(id: Id, conn_param: ConnParam) {
    rdma::rdma_connect(id as i32, conn_param as i32);
}

pub unsafe fn rdma_disconnect(id: Id) {
    rdma::rdma_disconnect(id as i32);
}

pub mod rdma {
    #[link(wasm_import_module = "rdma")]
    extern "C" {
        pub fn rdma_getaddrinfo(
            arg0: i32,
            arg1: i32,
            arg2: i32,
            arg3: i32,
            arg4: i32,
            arg5: i32,
        ) -> i32;
        pub fn rdma_create_ep(arg0: i32, arg1: i32, arg2: i32, arg3: i32) -> i32;
        pub fn rdma_freeaddrinfo(arg0: i32) -> i32;
        pub fn rdma_reg_msgs(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn rdma_dereg_mr(arg0: i32) -> i32;
        pub fn rdma_post_send(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32);
        pub fn rdma_destroy_ep(arg0: i32) -> i32;
        pub fn rdma_post_recv(arg0: i32, arg1: i32, arg2: i32, arg3: i32);
        pub fn rdma_get_send_comp(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn rdma_get_recv_comp(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn rdma_connect(arg0: i32, arg1: i32);
        pub fn rdma_disconnect(arg0: i32);
    }
}
