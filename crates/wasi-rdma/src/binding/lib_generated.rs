// This file is automatically generated, DO NOT EDIT
//
// To regenerate this file run the `crates/witx-bindgen` command

use core::fmt;
use core::mem::MaybeUninit;
#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct RdmaError(u16);
pub const RDMA_ERROR_SUCCESS: RdmaError = RdmaError(0);
pub const RDMA_ERROR_RUNTIME_ERROR: RdmaError = RdmaError(1);
pub const RDMA_ERROR_IO_ERROR: RdmaError = RdmaError(2);
impl RdmaError {
    pub const fn raw(&self) -> u16 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "SUCCESS",
            1 => "RUNTIME_ERROR",
            2 => "IO_ERROR",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for RdmaError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("RdmaError")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct AiFlags(u8);
pub const AI_FLAGS_RAI_PASSIVE: AiFlags = AiFlags(0);
pub const AI_FLAGS_RAI_NUMERICHOST: AiFlags = AiFlags(1);
pub const AI_FLAGS_RAI_NOROUTE: AiFlags = AiFlags(2);
pub const AI_FLAGS_RAI_FAMILY: AiFlags = AiFlags(3);
impl AiFlags {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "RAI_PASSIVE",
            1 => "RAI_NUMERICHOST",
            2 => "RAI_NOROUTE",
            3 => "RAI_FAMILY",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            3 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for AiFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AiFlags")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct AiPortSpace(u8);
pub const AI_PORT_SPACE_RDMA_PS_UDP: AiPortSpace = AiPortSpace(0);
pub const AI_PORT_SPACE_RDMA_PS_TCP: AiPortSpace = AiPortSpace(1);
pub const AI_PORT_SPACE_RDMA_PS_IB: AiPortSpace = AiPortSpace(2);
impl AiPortSpace {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "RDMA_PS_UDP",
            1 => "RDMA_PS_TCP",
            2 => "RDMA_PS_IB",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for AiPortSpace {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AiPortSpace")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct AiFamliy(u8);
pub const AI_FAMLIY_AF_IB: AiFamliy = AiFamliy(0);
pub const AI_FAMLIY_AF_INET: AiFamliy = AiFamliy(1);
pub const AI_FAMLIY_AF_INET6: AiFamliy = AiFamliy(2);
impl AiFamliy {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "AF_IB",
            1 => "AF_INET",
            2 => "AF_INET6",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for AiFamliy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AiFamliy")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct AiQpType(u8);
pub const AI_QP_TYPE_IBV_UD: AiQpType = AiQpType(0);
pub const AI_QP_TYPE_IBV_RC: AiQpType = AiQpType(1);
impl AiQpType {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "IBV_UD",
            1 => "IBV_RC",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for AiQpType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("AiQpType")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

#[repr(transparent)]
#[derive(Copy, Clone, Hash, Eq, PartialEq, Ord, PartialOrd)]
pub struct IbvQpType(u8);
pub const IBV_QP_TYPE_IBV_QPT_RC: IbvQpType = IbvQpType(0);
pub const IBV_QP_TYPE_IBV_QPT_UC: IbvQpType = IbvQpType(1);
pub const IBV_QP_TYPE_IBV_QPT_UD: IbvQpType = IbvQpType(2);
impl IbvQpType {
    pub const fn raw(&self) -> u8 {
        self.0
    }

    pub fn name(&self) -> &'static str {
        match self.0 {
            0 => "IBV_QPT_RC",
            1 => "IBV_QPT_UC",
            2 => "IBV_QPT_UD",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
    pub fn message(&self) -> &'static str {
        match self.0 {
            0 => "",
            1 => "",
            2 => "",
            _ => unsafe { core::hint::unreachable_unchecked() },
        }
    }
}
impl fmt::Debug for IbvQpType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("IbvQpType")
            .field("code", &self.0)
            .field("name", &self.name())
            .field("message", &self.message())
            .finish()
    }
}

pub type Id = u32;
pub type IbvMr = u32;
pub type IbvWc = u32;
pub type RdmaAddrinfo = u32;
pub type Context = u32;
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct RdmaAddrinfoStruct {
    pub flags: AiFlags,
    pub port_space: AiPortSpace,
    pub family: AiFamliy,
    pub qp_type: AiQpType,
    pub src_len: u32,
    pub dst_len: u32,
}
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct IbvQpCap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
pub type Rdma = u32;
pub type RdmaCq = u32;
pub type EpPd = u32;
pub unsafe fn rdma_init(
    node: &str,
    service: &str,
    hints: RdmaAddrinfoStruct,
) -> Result<Rdma, RdmaError> {
    let mut rp0 = MaybeUninit::<Rdma>::uninit();
    let ret = wasi_rdma::rdma_init(
        node.as_ptr() as i32,
        node.len() as i32,
        service.as_ptr() as i32,
        service.len() as i32,
        &hints as *const _ as i32,
        rp0.as_mut_ptr() as i32,
    );
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const Rdma)),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_disconnect(rdma: Rdma) {
    wasi_rdma::rdma_disconnect(rdma as i32);
}

pub unsafe fn rdma_post_send(
    rdma: Rdma,
    addr: *mut u8,
    send_mr: IbvMr,
    flags: u32,
) -> Result<(), RdmaError> {
    let ret = wasi_rdma::rdma_post_send(rdma as i32, addr as i32, send_mr as i32, flags as i32);
    match ret {
        0 => Ok(()),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_post_recv(rdma: Rdma, addr: *mut u8, recv_mr: IbvMr) -> Result<(), RdmaError> {
    let ret = wasi_rdma::rdma_post_recv(rdma as i32, addr as i32, recv_mr as i32);
    match ret {
        0 => Ok(()),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_get_send_comp(rdma: Rdma, wc: IbvWc) -> Result<IbvWc, RdmaError> {
    let mut rp0 = MaybeUninit::<IbvWc>::uninit();
    let ret = wasi_rdma::rdma_get_send_comp(rdma as i32, wc as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const IbvWc)),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub unsafe fn rdma_get_recv_comp(rdma: Rdma, wc: IbvWc) -> Result<IbvWc, RdmaError> {
    let mut rp0 = MaybeUninit::<IbvWc>::uninit();
    let ret = wasi_rdma::rdma_get_recv_comp(rdma as i32, wc as i32, rp0.as_mut_ptr() as i32);
    match ret {
        0 => Ok(core::ptr::read(rp0.as_mut_ptr() as i32 as *const IbvWc)),
        _ => Err(RdmaError(ret as u16)),
    }
}

pub mod wasi_rdma {
    #[link(wasm_import_module = "wasi_rdma")]
    extern "C" {
        pub fn rdma_init(arg0: i32, arg1: i32, arg2: i32, arg3: i32, arg4: i32, arg5: i32) -> i32;
        pub fn rdma_disconnect(arg0: i32);
        pub fn rdma_post_send(arg0: i32, arg1: i32, arg2: i32, arg3: i32) -> i32;
        pub fn rdma_post_recv(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn rdma_get_send_comp(arg0: i32, arg1: i32, arg2: i32) -> i32;
        pub fn rdma_get_recv_comp(arg0: i32, arg1: i32, arg2: i32) -> i32;
    }
}
