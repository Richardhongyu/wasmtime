#![feature(prelude_import)]
//! ## The `WasiFile` and `WasiDir` traits
//!
//! The WASI specification only defines one `handle` type, `fd`, on which all
//! operations on both files and directories (aka dirfds) are defined. We
//! believe this is a design mistake, and are architecting wasi-common to make
//! this straightforward to correct in future snapshots of WASI.  Wasi-common
//! internally treats files and directories as two distinct resource types in
//! the table - `Box<dyn WasiFile>` and `Box<dyn WasiDir>`. The snapshot 0 and
//! 1 interfaces via `fd` will attempt to downcast a table element to one or
//! both of these interfaces depending on what is appropriate - e.g.
//! `fd_close` operates on both files and directories, `fd_read` only operates
//! on files, and `fd_readdir` only operates on directories.
//! The `WasiFile` and `WasiDir` traits are defined by `wasi-common` in terms
//! of types defined directly in the crate's source code (I decided it should
//! NOT those generated by the `wiggle` proc macros, see snapshot architecture
//! below), as well as the `cap_std::time` family of types.  And, importantly,
//! `wasi-common` itself provides no implementation of `WasiDir`, and only two
//! trivial implementations of `WasiFile` on the `crate::pipe::{ReadPipe,
//! WritePipe}` types, which in turn just delegate to `std::io::{Read,
//! Write}`. In order for `wasi-common` to access the local filesystem at all,
//! you need to provide `WasiFile` and `WasiDir` impls through either the new
//! `wasi-cap-std-sync` crate found at `crates/wasi-common/cap-std-sync` - see
//! the section on that crate below - or by providing your own implementation
//! from elsewhere.
//!
//! This design makes it possible for `wasi-common` embedders to statically
//! reason about access to the local filesystem by examining what impls are
//! linked into an application. We found that this separation of concerns also
//! makes it pretty enjoyable to write alternative implementations, e.g. a
//! virtual filesystem (which will land in a future PR).
//!
//! ## Traits for the rest of WASI's features
//!
//! Other aspects of a WASI implementation are not yet considered resources
//! and accessed by `handle`. We plan to correct this design deficiency in
//! WASI in the future, but for now we have designed the following traits to
//! provide embedders with the same sort of implementation flexibility they
//! get with WasiFile/WasiDir:
//!
//! * Timekeeping: `WasiSystemClock` and `WasiMonotonicClock` provide the two
//! interfaces for a clock. `WasiSystemClock` represents time as a
//! `cap_std::time::SystemTime`, and `WasiMonotonicClock` represents time as
//! `cap_std::time::Instant`.  * Randomness: we re-use the `cap_rand::RngCore`
//! trait to represent a randomness source. A trivial `Deterministic` impl is
//! provided.  * Scheduling: The `WasiSched` trait abstracts over the
//! `sched_yield` and `poll_oneoff` functions.
//!
//! Users can provide implementations of each of these interfaces to the
//! `WasiCtx::builder(...)` function. The
//! `wasi_cap_std_sync::WasiCtxBuilder::new()` function uses this public
//! interface to plug in its own implementations of each of these resources.
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
pub mod clocks {
    use crate::{Error, ErrorExt};
    use cap_std::time::{Duration, Instant, SystemTime};
    pub enum SystemTimeSpec {
        SymbolicNow,
        Absolute(SystemTime),
    }
    pub trait WasiSystemClock: Send + Sync {
        fn resolution(&self) -> Duration;
        fn now(&self, precision: Duration) -> SystemTime;
    }
    pub trait WasiMonotonicClock: Send + Sync {
        fn resolution(&self) -> Duration;
        fn now(&self, precision: Duration) -> Instant;
    }
    pub struct WasiMonotonicOffsetClock {
        pub creation_time: cap_std::time::Instant,
        pub abs_clock: Box<dyn WasiMonotonicClock>,
    }
    impl WasiMonotonicOffsetClock {
        pub fn new(clock: impl 'static + WasiMonotonicClock) -> Self {
            Self {
                creation_time: clock.now(clock.resolution()),
                abs_clock: Box::new(clock),
            }
        }
    }
    pub struct WasiClocks {
        pub system: Option<Box<dyn WasiSystemClock>>,
        pub monotonic: Option<WasiMonotonicOffsetClock>,
    }
    impl WasiClocks {
        pub fn new() -> Self {
            Self {
                system: None,
                monotonic: None,
            }
        }
        pub fn with_system(mut self, clock: impl 'static + WasiSystemClock) -> Self {
            self.system = Some(Box::new(clock));
            self
        }
        pub fn with_monotonic(
            mut self,
            clock: impl 'static + WasiMonotonicClock,
        ) -> Self {
            self.monotonic = Some(WasiMonotonicOffsetClock::new(clock));
            self
        }
        pub fn system(&self) -> Result<&dyn WasiSystemClock, Error> {
            self.system
                .as_deref()
                .ok_or_else(|| Error::badf().context("system clock is not supported"))
        }
        pub fn monotonic(&self) -> Result<&WasiMonotonicOffsetClock, Error> {
            self.monotonic
                .as_ref()
                .ok_or_else(|| Error::badf().context("monotonic clock is not supported"))
        }
    }
}
mod ctx {
    use crate::clocks::WasiClocks;
    use crate::dir::{DirCaps, DirEntry, WasiDir};
    use crate::file::{FileCaps, FileEntry, WasiFile};
    use crate::sched::WasiSched;
    use crate::string_array::StringArray;
    use crate::table::Table;
    use crate::{Error, StringArrayError};
    use cap_rand::RngCore;
    use std::ops::Deref;
    use std::path::{Path, PathBuf};
    use std::sync::{Arc, Mutex};
    /// An `Arc`-wrapper around the wasi-common context to allow mutable access to
    /// the file descriptor table. This wrapper is only necessary due to the
    /// signature of `fd_fdstat_set_flags`; if that changes, there are a variety of
    /// improvements that can be made (TODO:
    /// https://github.com/bytecodealliance/wasmtime/issues/5643).
    pub struct WasiCtx(Arc<WasiCtxInner>);
    #[automatically_derived]
    impl ::core::clone::Clone for WasiCtx {
        #[inline]
        fn clone(&self) -> WasiCtx {
            WasiCtx(::core::clone::Clone::clone(&self.0))
        }
    }
    pub struct WasiCtxInner {
        pub args: StringArray,
        pub env: StringArray,
        pub random: Mutex<Box<dyn RngCore + Send + Sync>>,
        pub clocks: WasiClocks,
        pub sched: Box<dyn WasiSched>,
        pub table: Table,
    }
    impl WasiCtx {
        pub fn new(
            random: Box<dyn RngCore + Send + Sync>,
            clocks: WasiClocks,
            sched: Box<dyn WasiSched>,
            table: Table,
        ) -> Self {
            let s = WasiCtx(
                Arc::new(WasiCtxInner {
                    args: StringArray::new(),
                    env: StringArray::new(),
                    random: Mutex::new(random),
                    clocks,
                    sched,
                    table,
                }),
            );
            s.set_stdin(Box::new(crate::pipe::ReadPipe::new(std::io::empty())));
            s.set_stdout(Box::new(crate::pipe::WritePipe::new(std::io::sink())));
            s.set_stderr(Box::new(crate::pipe::WritePipe::new(std::io::sink())));
            s
        }
        pub fn insert_file(&self, fd: u32, file: Box<dyn WasiFile>, caps: FileCaps) {
            self.table().insert_at(fd, Arc::new(FileEntry::new(caps, file)));
        }
        pub fn push_file(
            &self,
            file: Box<dyn WasiFile>,
            caps: FileCaps,
        ) -> Result<u32, Error> {
            self.table().push(Arc::new(FileEntry::new(caps, file)))
        }
        pub fn insert_dir(
            &self,
            fd: u32,
            dir: Box<dyn WasiDir>,
            caps: DirCaps,
            file_caps: FileCaps,
            path: PathBuf,
        ) {
            self.table()
                .insert_at(
                    fd,
                    Arc::new(DirEntry::new(caps, file_caps, Some(path), dir)),
                );
        }
        pub fn push_dir(
            &self,
            dir: Box<dyn WasiDir>,
            caps: DirCaps,
            file_caps: FileCaps,
            path: PathBuf,
        ) -> Result<u32, Error> {
            self.table().push(Arc::new(DirEntry::new(caps, file_caps, Some(path), dir)))
        }
        pub fn table(&self) -> &Table {
            &self.table
        }
        pub fn table_mut(&mut self) -> Option<&mut Table> {
            Arc::get_mut(&mut self.0).map(|c| &mut c.table)
        }
        pub fn push_arg(&mut self, arg: &str) -> Result<(), StringArrayError> {
            let s = Arc::get_mut(&mut self.0)
                .expect(
                    "`push_arg` should only be used during initialization before the context is cloned",
                );
            s.args.push(arg.to_owned())
        }
        pub fn push_env(
            &mut self,
            var: &str,
            value: &str,
        ) -> Result<(), StringArrayError> {
            let s = Arc::get_mut(&mut self.0)
                .expect(
                    "`push_env` should only be used during initialization before the context is cloned",
                );
            s.env
                .push({
                    let res = ::alloc::fmt::format(format_args!("{0}={1}", var, value));
                    res
                })?;
            Ok(())
        }
        pub fn set_stdin(&self, mut f: Box<dyn WasiFile>) {
            let rights = Self::stdio_rights(&mut *f);
            self.insert_file(0, f, rights);
        }
        pub fn set_stdout(&self, mut f: Box<dyn WasiFile>) {
            let rights = Self::stdio_rights(&mut *f);
            self.insert_file(1, f, rights);
        }
        pub fn set_stderr(&self, mut f: Box<dyn WasiFile>) {
            let rights = Self::stdio_rights(&mut *f);
            self.insert_file(2, f, rights);
        }
        fn stdio_rights(f: &mut dyn WasiFile) -> FileCaps {
            let mut rights = FileCaps::all();
            if f.isatty() {
                rights &= !(FileCaps::TELL | FileCaps::SEEK);
            }
            rights
        }
        pub fn push_preopened_dir(
            &self,
            dir: Box<dyn WasiDir>,
            path: impl AsRef<Path>,
        ) -> Result<(), Error> {
            let caps = DirCaps::all();
            let file_caps = FileCaps::all();
            self.table()
                .push(
                    Arc::new(
                        DirEntry::new(
                            caps,
                            file_caps,
                            Some(path.as_ref().to_owned()),
                            dir,
                        ),
                    ),
                )?;
            Ok(())
        }
    }
    impl Deref for WasiCtx {
        type Target = WasiCtxInner;
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    }
}
pub mod dir {
    use crate::file::{FdFlags, FileCaps, FileType, Filestat, OFlags, WasiFile};
    use crate::{Error, ErrorExt, SystemTimeSpec};
    use bitflags::bitflags;
    use std::any::Any;
    use std::path::PathBuf;
    use std::sync::{Arc, RwLock};
    pub trait WasiDir: Send + Sync {
        fn as_any(&self) -> &dyn Any;
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn open_file<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _symlink_follow: bool,
            _path: &'life1 str,
            _oflags: OFlags,
            _read: bool,
            _write: bool,
            _fdflags: FdFlags,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Box<dyn WasiFile>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Box<dyn WasiFile>, Error>> {
                    return __ret;
                }
                let __self = self;
                let _symlink_follow = _symlink_follow;
                let _oflags = _oflags;
                let _read = _read;
                let _write = _write;
                let _fdflags = _fdflags;
                let __ret: Result<Box<dyn WasiFile>, Error> = {
                    Err(Error::not_supported())
                };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn open_dir<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _symlink_follow: bool,
            _path: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Box<dyn WasiDir>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Box<dyn WasiDir>, Error>> {
                    return __ret;
                }
                let __self = self;
                let _symlink_follow = _symlink_follow;
                let __ret: Result<Box<dyn WasiDir>, Error> = {
                    Err(Error::not_supported())
                };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn create_dir<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _path: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn readdir<'life0, 'async_trait>(
            &'life0 self,
            _cursor: ReaddirCursor,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<
                        Box<dyn Iterator<Item = Result<ReaddirEntity, Error>> + Send>,
                        Error,
                    >,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<
                        Result<
                            Box<
                                dyn Iterator<Item = Result<ReaddirEntity, Error>> + Send,
                            >,
                            Error,
                        >,
                    > {
                    return __ret;
                }
                let __self = self;
                let _cursor = _cursor;
                let __ret: Result<
                    Box<dyn Iterator<Item = Result<ReaddirEntity, Error>> + Send>,
                    Error,
                > = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn symlink<'life0, 'life1, 'life2, 'async_trait>(
            &'life0 self,
            _old_path: &'life1 str,
            _new_path: &'life2 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn remove_dir<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _path: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn unlink_file<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _path: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn read_link<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _path: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<PathBuf, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<PathBuf, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<PathBuf, Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn get_filestat<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Filestat, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Filestat, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<Filestat, Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn get_path_filestat<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _path: &'life1 str,
            _follow_symlinks: bool,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Filestat, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Filestat, Error>> {
                    return __ret;
                }
                let __self = self;
                let _follow_symlinks = _follow_symlinks;
                let __ret: Result<Filestat, Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn rename<'life0, 'life1, 'life2, 'life3, 'async_trait>(
            &'life0 self,
            _path: &'life1 str,
            _dest_dir: &'life2 dyn WasiDir,
            _dest_path: &'life3 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            'life3: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn hard_link<'life0, 'life1, 'life2, 'life3, 'async_trait>(
            &'life0 self,
            _path: &'life1 str,
            _target_dir: &'life2 dyn WasiDir,
            _target_path: &'life3 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            'life3: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn set_times<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _path: &'life1 str,
            _atime: Option<SystemTimeSpec>,
            _mtime: Option<SystemTimeSpec>,
            _follow_symlinks: bool,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let _atime = _atime;
                let _mtime = _mtime;
                let _follow_symlinks = _follow_symlinks;
                let __ret: Result<(), Error> = { Err(Error::not_supported()) };
                #[allow(unreachable_code)] __ret
            })
        }
    }
    pub(crate) struct DirEntry {
        caps: RwLock<DirFdStat>,
        preopen_path: Option<PathBuf>,
        dir: Box<dyn WasiDir>,
    }
    impl DirEntry {
        pub fn new(
            dir_caps: DirCaps,
            file_caps: FileCaps,
            preopen_path: Option<PathBuf>,
            dir: Box<dyn WasiDir>,
        ) -> Self {
            DirEntry {
                caps: RwLock::new(DirFdStat { dir_caps, file_caps }),
                preopen_path,
                dir,
            }
        }
        pub fn capable_of_dir(&self, caps: DirCaps) -> Result<(), Error> {
            let fdstat = self.caps.read().unwrap();
            fdstat.capable_of_dir(caps)
        }
        pub fn drop_caps_to(
            &self,
            dir_caps: DirCaps,
            file_caps: FileCaps,
        ) -> Result<(), Error> {
            let mut fdstat = self.caps.write().unwrap();
            fdstat.capable_of_dir(dir_caps)?;
            fdstat.capable_of_file(file_caps)?;
            *fdstat = DirFdStat { dir_caps, file_caps };
            Ok(())
        }
        pub fn child_dir_caps(&self, desired_caps: DirCaps) -> DirCaps {
            self.caps.read().unwrap().dir_caps & desired_caps
        }
        pub fn child_file_caps(&self, desired_caps: FileCaps) -> FileCaps {
            self.caps.read().unwrap().file_caps & desired_caps
        }
        pub fn get_dir_fdstat(&self) -> DirFdStat {
            self.caps.read().unwrap().clone()
        }
        pub fn preopen_path(&self) -> &Option<PathBuf> {
            &self.preopen_path
        }
    }
    pub trait DirEntryExt {
        fn get_cap(&self, caps: DirCaps) -> Result<&dyn WasiDir, Error>;
    }
    impl DirEntryExt for DirEntry {
        fn get_cap(&self, caps: DirCaps) -> Result<&dyn WasiDir, Error> {
            self.capable_of_dir(caps)?;
            Ok(&*self.dir)
        }
    }
    pub struct DirCaps {
        bits: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for DirCaps {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for DirCaps {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for DirCaps {
        #[inline]
        fn eq(&self, other: &DirCaps) -> bool {
            self.bits == other.bits
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for DirCaps {}
    #[automatically_derived]
    impl ::core::cmp::Eq for DirCaps {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DirCaps {
        #[inline]
        fn clone(&self) -> DirCaps {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for DirCaps {
        #[inline]
        fn partial_cmp(
            &self,
            other: &DirCaps,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for DirCaps {
        #[inline]
        fn cmp(&self, other: &DirCaps) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for DirCaps {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.bits, state)
        }
    }
    impl ::bitflags::_core::fmt::Debug for DirCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            #[allow(non_snake_case)]
            trait __BitFlags {
                #[inline]
                fn CREATE_DIRECTORY(&self) -> bool {
                    false
                }
                #[inline]
                fn CREATE_FILE(&self) -> bool {
                    false
                }
                #[inline]
                fn LINK_SOURCE(&self) -> bool {
                    false
                }
                #[inline]
                fn LINK_TARGET(&self) -> bool {
                    false
                }
                #[inline]
                fn OPEN(&self) -> bool {
                    false
                }
                #[inline]
                fn READDIR(&self) -> bool {
                    false
                }
                #[inline]
                fn READLINK(&self) -> bool {
                    false
                }
                #[inline]
                fn RENAME_SOURCE(&self) -> bool {
                    false
                }
                #[inline]
                fn RENAME_TARGET(&self) -> bool {
                    false
                }
                #[inline]
                fn SYMLINK(&self) -> bool {
                    false
                }
                #[inline]
                fn REMOVE_DIRECTORY(&self) -> bool {
                    false
                }
                #[inline]
                fn UNLINK_FILE(&self) -> bool {
                    false
                }
                #[inline]
                fn PATH_FILESTAT_GET(&self) -> bool {
                    false
                }
                #[inline]
                fn PATH_FILESTAT_SET_TIMES(&self) -> bool {
                    false
                }
                #[inline]
                fn FILESTAT_GET(&self) -> bool {
                    false
                }
                #[inline]
                fn FILESTAT_SET_TIMES(&self) -> bool {
                    false
                }
            }
            #[allow(non_snake_case)]
            impl __BitFlags for DirCaps {
                #[allow(deprecated)]
                #[inline]
                fn CREATE_DIRECTORY(&self) -> bool {
                    if Self::CREATE_DIRECTORY.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::CREATE_DIRECTORY.bits
                            == Self::CREATE_DIRECTORY.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn CREATE_FILE(&self) -> bool {
                    if Self::CREATE_FILE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::CREATE_FILE.bits == Self::CREATE_FILE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn LINK_SOURCE(&self) -> bool {
                    if Self::LINK_SOURCE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::LINK_SOURCE.bits == Self::LINK_SOURCE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn LINK_TARGET(&self) -> bool {
                    if Self::LINK_TARGET.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::LINK_TARGET.bits == Self::LINK_TARGET.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn OPEN(&self) -> bool {
                    if Self::OPEN.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::OPEN.bits == Self::OPEN.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn READDIR(&self) -> bool {
                    if Self::READDIR.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::READDIR.bits == Self::READDIR.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn READLINK(&self) -> bool {
                    if Self::READLINK.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::READLINK.bits == Self::READLINK.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn RENAME_SOURCE(&self) -> bool {
                    if Self::RENAME_SOURCE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::RENAME_SOURCE.bits == Self::RENAME_SOURCE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn RENAME_TARGET(&self) -> bool {
                    if Self::RENAME_TARGET.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::RENAME_TARGET.bits == Self::RENAME_TARGET.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn SYMLINK(&self) -> bool {
                    if Self::SYMLINK.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::SYMLINK.bits == Self::SYMLINK.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn REMOVE_DIRECTORY(&self) -> bool {
                    if Self::REMOVE_DIRECTORY.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::REMOVE_DIRECTORY.bits
                            == Self::REMOVE_DIRECTORY.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn UNLINK_FILE(&self) -> bool {
                    if Self::UNLINK_FILE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::UNLINK_FILE.bits == Self::UNLINK_FILE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn PATH_FILESTAT_GET(&self) -> bool {
                    if Self::PATH_FILESTAT_GET.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::PATH_FILESTAT_GET.bits
                            == Self::PATH_FILESTAT_GET.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn PATH_FILESTAT_SET_TIMES(&self) -> bool {
                    if Self::PATH_FILESTAT_SET_TIMES.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::PATH_FILESTAT_SET_TIMES.bits
                            == Self::PATH_FILESTAT_SET_TIMES.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn FILESTAT_GET(&self) -> bool {
                    if Self::FILESTAT_GET.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::FILESTAT_GET.bits == Self::FILESTAT_GET.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn FILESTAT_SET_TIMES(&self) -> bool {
                    if Self::FILESTAT_SET_TIMES.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::FILESTAT_SET_TIMES.bits
                            == Self::FILESTAT_SET_TIMES.bits
                    }
                }
            }
            let mut first = true;
            if <Self as __BitFlags>::CREATE_DIRECTORY(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("CREATE_DIRECTORY")?;
            }
            if <Self as __BitFlags>::CREATE_FILE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("CREATE_FILE")?;
            }
            if <Self as __BitFlags>::LINK_SOURCE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("LINK_SOURCE")?;
            }
            if <Self as __BitFlags>::LINK_TARGET(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("LINK_TARGET")?;
            }
            if <Self as __BitFlags>::OPEN(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("OPEN")?;
            }
            if <Self as __BitFlags>::READDIR(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("READDIR")?;
            }
            if <Self as __BitFlags>::READLINK(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("READLINK")?;
            }
            if <Self as __BitFlags>::RENAME_SOURCE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("RENAME_SOURCE")?;
            }
            if <Self as __BitFlags>::RENAME_TARGET(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("RENAME_TARGET")?;
            }
            if <Self as __BitFlags>::SYMLINK(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("SYMLINK")?;
            }
            if <Self as __BitFlags>::REMOVE_DIRECTORY(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("REMOVE_DIRECTORY")?;
            }
            if <Self as __BitFlags>::UNLINK_FILE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("UNLINK_FILE")?;
            }
            if <Self as __BitFlags>::PATH_FILESTAT_GET(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("PATH_FILESTAT_GET")?;
            }
            if <Self as __BitFlags>::PATH_FILESTAT_SET_TIMES(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("PATH_FILESTAT_SET_TIMES")?;
            }
            if <Self as __BitFlags>::FILESTAT_GET(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("FILESTAT_GET")?;
            }
            if <Self as __BitFlags>::FILESTAT_SET_TIMES(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("FILESTAT_SET_TIMES")?;
            }
            let extra_bits = self.bits & !Self::all().bits();
            if extra_bits != 0 {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("0x")?;
                ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
            }
            if first {
                f.write_str("(empty)")?;
            }
            Ok(())
        }
    }
    impl ::bitflags::_core::fmt::Binary for DirCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::Octal for DirCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::LowerHex for DirCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::UpperHex for DirCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
        }
    }
    #[allow(dead_code)]
    impl DirCaps {
        pub const CREATE_DIRECTORY: Self = Self { bits: 0b1 };
        pub const CREATE_FILE: Self = Self { bits: 0b10 };
        pub const LINK_SOURCE: Self = Self { bits: 0b100 };
        pub const LINK_TARGET: Self = Self { bits: 0b1000 };
        pub const OPEN: Self = Self { bits: 0b10000 };
        pub const READDIR: Self = Self { bits: 0b100000 };
        pub const READLINK: Self = Self { bits: 0b1000000 };
        pub const RENAME_SOURCE: Self = Self { bits: 0b10000000 };
        pub const RENAME_TARGET: Self = Self { bits: 0b100000000 };
        pub const SYMLINK: Self = Self { bits: 0b1000000000 };
        pub const REMOVE_DIRECTORY: Self = Self { bits: 0b10000000000 };
        pub const UNLINK_FILE: Self = Self { bits: 0b100000000000 };
        pub const PATH_FILESTAT_GET: Self = Self { bits: 0b1000000000000 };
        pub const PATH_FILESTAT_SET_TIMES: Self = Self { bits: 0b10000000000000 };
        pub const FILESTAT_GET: Self = Self { bits: 0b100000000000000 };
        pub const FILESTAT_SET_TIMES: Self = Self { bits: 0b1000000000000000 };
        /// Returns an empty set of flags.
        #[inline]
        pub const fn empty() -> Self {
            Self { bits: 0 }
        }
        /// Returns the set containing all flags.
        #[inline]
        pub const fn all() -> Self {
            #[allow(non_snake_case)]
            trait __BitFlags {
                const CREATE_DIRECTORY: u32 = 0;
                const CREATE_FILE: u32 = 0;
                const LINK_SOURCE: u32 = 0;
                const LINK_TARGET: u32 = 0;
                const OPEN: u32 = 0;
                const READDIR: u32 = 0;
                const READLINK: u32 = 0;
                const RENAME_SOURCE: u32 = 0;
                const RENAME_TARGET: u32 = 0;
                const SYMLINK: u32 = 0;
                const REMOVE_DIRECTORY: u32 = 0;
                const UNLINK_FILE: u32 = 0;
                const PATH_FILESTAT_GET: u32 = 0;
                const PATH_FILESTAT_SET_TIMES: u32 = 0;
                const FILESTAT_GET: u32 = 0;
                const FILESTAT_SET_TIMES: u32 = 0;
            }
            #[allow(non_snake_case)]
            impl __BitFlags for DirCaps {
                #[allow(deprecated)]
                const CREATE_DIRECTORY: u32 = Self::CREATE_DIRECTORY.bits;
                #[allow(deprecated)]
                const CREATE_FILE: u32 = Self::CREATE_FILE.bits;
                #[allow(deprecated)]
                const LINK_SOURCE: u32 = Self::LINK_SOURCE.bits;
                #[allow(deprecated)]
                const LINK_TARGET: u32 = Self::LINK_TARGET.bits;
                #[allow(deprecated)]
                const OPEN: u32 = Self::OPEN.bits;
                #[allow(deprecated)]
                const READDIR: u32 = Self::READDIR.bits;
                #[allow(deprecated)]
                const READLINK: u32 = Self::READLINK.bits;
                #[allow(deprecated)]
                const RENAME_SOURCE: u32 = Self::RENAME_SOURCE.bits;
                #[allow(deprecated)]
                const RENAME_TARGET: u32 = Self::RENAME_TARGET.bits;
                #[allow(deprecated)]
                const SYMLINK: u32 = Self::SYMLINK.bits;
                #[allow(deprecated)]
                const REMOVE_DIRECTORY: u32 = Self::REMOVE_DIRECTORY.bits;
                #[allow(deprecated)]
                const UNLINK_FILE: u32 = Self::UNLINK_FILE.bits;
                #[allow(deprecated)]
                const PATH_FILESTAT_GET: u32 = Self::PATH_FILESTAT_GET.bits;
                #[allow(deprecated)]
                const PATH_FILESTAT_SET_TIMES: u32 = Self::PATH_FILESTAT_SET_TIMES.bits;
                #[allow(deprecated)]
                const FILESTAT_GET: u32 = Self::FILESTAT_GET.bits;
                #[allow(deprecated)]
                const FILESTAT_SET_TIMES: u32 = Self::FILESTAT_SET_TIMES.bits;
            }
            Self {
                bits: <Self as __BitFlags>::CREATE_DIRECTORY
                    | <Self as __BitFlags>::CREATE_FILE
                    | <Self as __BitFlags>::LINK_SOURCE
                    | <Self as __BitFlags>::LINK_TARGET | <Self as __BitFlags>::OPEN
                    | <Self as __BitFlags>::READDIR | <Self as __BitFlags>::READLINK
                    | <Self as __BitFlags>::RENAME_SOURCE
                    | <Self as __BitFlags>::RENAME_TARGET | <Self as __BitFlags>::SYMLINK
                    | <Self as __BitFlags>::REMOVE_DIRECTORY
                    | <Self as __BitFlags>::UNLINK_FILE
                    | <Self as __BitFlags>::PATH_FILESTAT_GET
                    | <Self as __BitFlags>::PATH_FILESTAT_SET_TIMES
                    | <Self as __BitFlags>::FILESTAT_GET
                    | <Self as __BitFlags>::FILESTAT_SET_TIMES,
            }
        }
        /// Returns the raw value of the flags currently stored.
        #[inline]
        pub const fn bits(&self) -> u32 {
            self.bits
        }
        /// Convert from underlying bit representation, unless that
        /// representation contains bits that do not correspond to a flag.
        #[inline]
        pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
            if (bits & !Self::all().bits()) == 0 {
                ::bitflags::_core::option::Option::Some(Self { bits })
            } else {
                ::bitflags::_core::option::Option::None
            }
        }
        /// Convert from underlying bit representation, dropping any bits
        /// that do not correspond to flags.
        #[inline]
        pub const fn from_bits_truncate(bits: u32) -> Self {
            Self {
                bits: bits & Self::all().bits,
            }
        }
        /// Convert from underlying bit representation, preserving all
        /// bits (even those not corresponding to a defined flag).
        ///
        /// # Safety
        ///
        /// The caller of the `bitflags!` macro can chose to allow or
        /// disallow extra bits for their bitflags type.
        ///
        /// The caller of `from_bits_unchecked()` has to ensure that
        /// all bits correspond to a defined flag or that extra bits
        /// are valid for this bitflags type.
        #[inline]
        pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
            Self { bits }
        }
        /// Returns `true` if no flags are currently stored.
        #[inline]
        pub const fn is_empty(&self) -> bool {
            self.bits() == Self::empty().bits()
        }
        /// Returns `true` if all flags are currently set.
        #[inline]
        pub const fn is_all(&self) -> bool {
            Self::all().bits | self.bits == self.bits
        }
        /// Returns `true` if there are flags common to both `self` and `other`.
        #[inline]
        pub const fn intersects(&self, other: Self) -> bool {
            !(Self {
                bits: self.bits & other.bits,
            })
                .is_empty()
        }
        /// Returns `true` if all of the flags in `other` are contained within `self`.
        #[inline]
        pub const fn contains(&self, other: Self) -> bool {
            (self.bits & other.bits) == other.bits
        }
        /// Inserts the specified flags in-place.
        #[inline]
        pub fn insert(&mut self, other: Self) {
            self.bits |= other.bits;
        }
        /// Removes the specified flags in-place.
        #[inline]
        pub fn remove(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
        /// Toggles the specified flags in-place.
        #[inline]
        pub fn toggle(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
        /// Inserts or removes the specified flags depending on the passed value.
        #[inline]
        pub fn set(&mut self, other: Self, value: bool) {
            if value {
                self.insert(other);
            } else {
                self.remove(other);
            }
        }
        /// Returns the intersection between the flags in `self` and
        /// `other`.
        ///
        /// Specifically, the returned set contains only the flags which are
        /// present in *both* `self` *and* `other`.
        ///
        /// This is equivalent to using the `&` operator (e.g.
        /// [`ops::BitAnd`]), as in `flags & other`.
        ///
        /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
        #[inline]
        #[must_use]
        pub const fn intersection(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
        /// Returns the union of between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags which are
        /// present in *either* `self` *or* `other`, including any which are
        /// present in both (see [`Self::symmetric_difference`] if that
        /// is undesirable).
        ///
        /// This is equivalent to using the `|` operator (e.g.
        /// [`ops::BitOr`]), as in `flags | other`.
        ///
        /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
        #[inline]
        #[must_use]
        pub const fn union(self, other: Self) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
        /// Returns the difference between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags present in
        /// `self`, except for the ones present in `other`.
        ///
        /// It is also conceptually equivalent to the "bit-clear" operation:
        /// `flags & !other` (and this syntax is also supported).
        ///
        /// This is equivalent to using the `-` operator (e.g.
        /// [`ops::Sub`]), as in `flags - other`.
        ///
        /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
        #[inline]
        #[must_use]
        pub const fn difference(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
        /// Returns the [symmetric difference][sym-diff] between the flags
        /// in `self` and `other`.
        ///
        /// Specifically, the returned set contains the flags present which
        /// are present in `self` or `other`, but that are not present in
        /// both. Equivalently, it contains the flags present in *exactly
        /// one* of the sets `self` and `other`.
        ///
        /// This is equivalent to using the `^` operator (e.g.
        /// [`ops::BitXor`]), as in `flags ^ other`.
        ///
        /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
        /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
        #[inline]
        #[must_use]
        pub const fn symmetric_difference(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
        /// Returns the complement of this set of flags.
        ///
        /// Specifically, the returned set contains all the flags which are
        /// not set in `self`, but which are allowed for this type.
        ///
        /// Alternatively, it can be thought of as the set difference
        /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
        ///
        /// This is equivalent to using the `!` operator (e.g.
        /// [`ops::Not`]), as in `!flags`.
        ///
        /// [`Self::all()`]: Self::all
        /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
        #[inline]
        #[must_use]
        pub const fn complement(self) -> Self {
            Self::from_bits_truncate(!self.bits)
        }
    }
    impl ::bitflags::_core::ops::BitOr for DirCaps {
        type Output = Self;
        /// Returns the union of the two sets of flags.
        #[inline]
        fn bitor(self, other: DirCaps) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitOrAssign for DirCaps {
        /// Adds the set of flags.
        #[inline]
        fn bitor_assign(&mut self, other: Self) {
            self.bits |= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitXor for DirCaps {
        type Output = Self;
        /// Returns the left flags, but with all the right flags toggled.
        #[inline]
        fn bitxor(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitXorAssign for DirCaps {
        /// Toggles the set of flags.
        #[inline]
        fn bitxor_assign(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitAnd for DirCaps {
        type Output = Self;
        /// Returns the intersection between the two sets of flags.
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitAndAssign for DirCaps {
        /// Disables all flags disabled in the set.
        #[inline]
        fn bitand_assign(&mut self, other: Self) {
            self.bits &= other.bits;
        }
    }
    impl ::bitflags::_core::ops::Sub for DirCaps {
        type Output = Self;
        /// Returns the set difference of the two sets of flags.
        #[inline]
        fn sub(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::SubAssign for DirCaps {
        /// Disables all flags enabled in the set.
        #[inline]
        fn sub_assign(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
    }
    impl ::bitflags::_core::ops::Not for DirCaps {
        type Output = Self;
        /// Returns the complement of this set of flags.
        #[inline]
        fn not(self) -> Self {
            Self { bits: !self.bits } & Self::all()
        }
    }
    impl ::bitflags::_core::iter::Extend<DirCaps> for DirCaps {
        fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            &mut self,
            iterator: T,
        ) {
            for item in iterator {
                self.insert(item)
            }
        }
    }
    impl ::bitflags::_core::iter::FromIterator<DirCaps> for DirCaps {
        fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            iterator: T,
        ) -> Self {
            let mut result = Self::empty();
            result.extend(iterator);
            result
        }
    }
    pub struct DirFdStat {
        pub file_caps: FileCaps,
        pub dir_caps: DirCaps,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DirFdStat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "DirFdStat",
                "file_caps",
                &self.file_caps,
                "dir_caps",
                &&self.dir_caps,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DirFdStat {
        #[inline]
        fn clone(&self) -> DirFdStat {
            DirFdStat {
                file_caps: ::core::clone::Clone::clone(&self.file_caps),
                dir_caps: ::core::clone::Clone::clone(&self.dir_caps),
            }
        }
    }
    impl DirFdStat {
        pub fn capable_of_dir(&self, caps: DirCaps) -> Result<(), Error> {
            if self.dir_caps.contains(caps) {
                Ok(())
            } else {
                let missing = caps & !self.dir_caps;
                let err = if missing.intersects(DirCaps::READDIR) {
                    Error::not_dir()
                } else {
                    Error::perm()
                };
                Err(
                    err
                        .context({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "desired rights {0:?}, has {1:?}", caps, self.dir_caps
                                ),
                            );
                            res
                        }),
                )
            }
        }
        pub fn capable_of_file(&self, caps: FileCaps) -> Result<(), Error> {
            if self.file_caps.contains(caps) {
                Ok(())
            } else {
                Err(
                    Error::perm()
                        .context({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "desired rights {0:?}, has {1:?}", caps, self.file_caps
                                ),
                            );
                            res
                        }),
                )
            }
        }
    }
    pub(crate) trait TableDirExt {
        fn get_dir(&self, fd: u32) -> Result<Arc<DirEntry>, Error>;
    }
    impl TableDirExt for crate::table::Table {
        fn get_dir(&self, fd: u32) -> Result<Arc<DirEntry>, Error> {
            self.get(fd)
        }
    }
    pub struct ReaddirEntity {
        pub next: ReaddirCursor,
        pub inode: u64,
        pub name: String,
        pub filetype: FileType,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ReaddirEntity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "ReaddirEntity",
                "next",
                &self.next,
                "inode",
                &self.inode,
                "name",
                &self.name,
                "filetype",
                &&self.filetype,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ReaddirEntity {
        #[inline]
        fn clone(&self) -> ReaddirEntity {
            ReaddirEntity {
                next: ::core::clone::Clone::clone(&self.next),
                inode: ::core::clone::Clone::clone(&self.inode),
                name: ::core::clone::Clone::clone(&self.name),
                filetype: ::core::clone::Clone::clone(&self.filetype),
            }
        }
    }
    pub struct ReaddirCursor(u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for ReaddirCursor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "ReaddirCursor",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for ReaddirCursor {}
    #[automatically_derived]
    impl ::core::clone::Clone for ReaddirCursor {
        #[inline]
        fn clone(&self) -> ReaddirCursor {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    impl From<u64> for ReaddirCursor {
        fn from(c: u64) -> ReaddirCursor {
            ReaddirCursor(c)
        }
    }
    impl From<ReaddirCursor> for u64 {
        fn from(c: ReaddirCursor) -> u64 {
            c.0
        }
    }
}
mod error {
    //! wasi-common uses an [`Error`] type which represents either a preview 1 [`Errno`] enum, on
    //! [`anyhow::Error`] for trapping execution.
    //!
    //! The user can construct an [`Error`] out of an [`Errno`] using the `From`/`Into` traits.
    //! They may also use [`Error::trap`] to construct an error that traps execution. The contents
    //! can be inspected with [`Error::downcast`] and [`Error::downcast_ref`]. Additional context
    //! can be provided with the [`Error::context`] method. This context is only observable with the
    //! `Display` and `Debug` impls of the error.
    pub use crate::snapshots::preview_1::error::{Errno, Error, ErrorExt};
    use std::fmt;
    /// An error returned from the `proc_exit` host syscall.
    ///
    /// Embedders can test if an error returned from wasm is this error, in which
    /// case it may signal a non-fatal trap.
    pub struct I32Exit(pub i32);
    #[automatically_derived]
    impl ::core::fmt::Debug for I32Exit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "I32Exit", &&self.0)
        }
    }
    impl fmt::Display for I32Exit {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(format_args!("Exited with i32 exit status {0}", self.0))
        }
    }
    impl std::error::Error for I32Exit {}
}
pub mod file {
    use crate::{Error, ErrorExt, SystemTimeSpec};
    use bitflags::bitflags;
    use std::any::Any;
    use std::sync::{Arc, RwLock};
    pub trait WasiFile: Send + Sync {
        fn as_any(&self) -> &dyn Any;
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn get_filetype<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<FileType, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        #[cfg(unix)]
        fn pollable(&self) -> Option<rustix::fd::BorrowedFd> {
            None
        }
        fn isatty(&self) -> bool {
            false
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn sock_accept<'life0, 'async_trait>(
            &'life0 self,
            _fdflags: FdFlags,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Box<dyn WasiFile>, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Box<dyn WasiFile>, Error>> {
                    return __ret;
                }
                let __self = self;
                let _fdflags = _fdflags;
                let __ret: Result<Box<dyn WasiFile>, Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn sock_recv<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            _ri_data: &'life1 mut [std::io::IoSliceMut<'a>],
            _ri_flags: RiFlags,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(u64, RoFlags), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(u64, RoFlags), Error>> {
                    return __ret;
                }
                let __self = self;
                let _ri_flags = _ri_flags;
                let __ret: Result<(u64, RoFlags), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn sock_send<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            _si_data: &'life1 [std::io::IoSlice<'a>],
            _si_flags: SiFlags,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let _si_flags = _si_flags;
                let __ret: Result<u64, Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn sock_shutdown<'life0, 'async_trait>(
            &'life0 self,
            _how: SdFlags,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let _how = _how;
                let __ret: Result<(), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn datasync<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Ok(()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn sync<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Ok(()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn get_fdflags<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<FdFlags, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<FdFlags, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<FdFlags, Error> = { Ok(FdFlags::empty()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn set_fdflags<'life0, 'async_trait>(
            &'life0 mut self,
            _flags: FdFlags,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let mut __self = self;
                let _flags = _flags;
                let __ret: Result<(), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn get_filestat<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<Filestat, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<Filestat, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<Filestat, Error> = {
                    Ok(Filestat {
                        device_id: 0,
                        inode: 0,
                        filetype: __self.get_filetype().await?,
                        nlink: 0,
                        size: 0,
                        atim: None,
                        mtim: None,
                        ctim: None,
                    })
                };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn set_filestat_size<'life0, 'async_trait>(
            &'life0 self,
            _size: u64,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let _size = _size;
                let __ret: Result<(), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn advise<'life0, 'async_trait>(
            &'life0 self,
            _offset: u64,
            _len: u64,
            _advice: Advice,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let _offset = _offset;
                let _len = _len;
                let _advice = _advice;
                let __ret: Result<(), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn allocate<'life0, 'async_trait>(
            &'life0 self,
            _offset: u64,
            _len: u64,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let _offset = _offset;
                let _len = _len;
                let __ret: Result<(), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn set_times<'life0, 'async_trait>(
            &'life0 self,
            _atime: Option<SystemTimeSpec>,
            _mtime: Option<SystemTimeSpec>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let _atime = _atime;
                let _mtime = _mtime;
                let __ret: Result<(), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn read_vectored<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            _bufs: &'life1 mut [std::io::IoSliceMut<'a>],
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<u64, Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn read_vectored_at<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            _bufs: &'life1 mut [std::io::IoSliceMut<'a>],
            _offset: u64,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let _offset = _offset;
                let __ret: Result<u64, Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn write_vectored<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            _bufs: &'life1 [std::io::IoSlice<'a>],
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<u64, Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn write_vectored_at<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            _bufs: &'life1 [std::io::IoSlice<'a>],
            _offset: u64,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let _offset = _offset;
                let __ret: Result<u64, Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn seek<'life0, 'async_trait>(
            &'life0 self,
            _pos: std::io::SeekFrom,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let _pos = _pos;
                let __ret: Result<u64, Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn peek<'life0, 'life1, 'async_trait>(
            &'life0 self,
            _buf: &'life1 mut [u8],
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<u64, Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        fn num_ready_bytes(&self) -> Result<u64, Error> {
            Ok(0)
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn readable<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[must_use]
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn writable<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<(), Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<(), Error> = { Err(Error::badf()) };
                #[allow(unreachable_code)] __ret
            })
        }
    }
    pub enum FileType {
        Unknown,
        BlockDevice,
        CharacterDevice,
        Directory,
        RegularFile,
        SocketDgram,
        SocketStream,
        SymbolicLink,
        Pipe,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FileType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    FileType::Unknown => "Unknown",
                    FileType::BlockDevice => "BlockDevice",
                    FileType::CharacterDevice => "CharacterDevice",
                    FileType::Directory => "Directory",
                    FileType::RegularFile => "RegularFile",
                    FileType::SocketDgram => "SocketDgram",
                    FileType::SocketStream => "SocketStream",
                    FileType::SymbolicLink => "SymbolicLink",
                    FileType::Pipe => "Pipe",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FileType {}
    #[automatically_derived]
    impl ::core::clone::Clone for FileType {
        #[inline]
        fn clone(&self) -> FileType {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FileType {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FileType {
        #[inline]
        fn eq(&self, other: &FileType) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FileType {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FileType {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    pub struct FdFlags {
        bits: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FdFlags {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FdFlags {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FdFlags {
        #[inline]
        fn eq(&self, other: &FdFlags) -> bool {
            self.bits == other.bits
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FdFlags {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FdFlags {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FdFlags {
        #[inline]
        fn clone(&self) -> FdFlags {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FdFlags {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FdFlags,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FdFlags {
        #[inline]
        fn cmp(&self, other: &FdFlags) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FdFlags {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.bits, state)
        }
    }
    impl ::bitflags::_core::fmt::Debug for FdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            #[allow(non_snake_case)]
            trait __BitFlags {
                #[inline]
                fn APPEND(&self) -> bool {
                    false
                }
                #[inline]
                fn DSYNC(&self) -> bool {
                    false
                }
                #[inline]
                fn NONBLOCK(&self) -> bool {
                    false
                }
                #[inline]
                fn RSYNC(&self) -> bool {
                    false
                }
                #[inline]
                fn SYNC(&self) -> bool {
                    false
                }
            }
            #[allow(non_snake_case)]
            impl __BitFlags for FdFlags {
                #[allow(deprecated)]
                #[inline]
                fn APPEND(&self) -> bool {
                    if Self::APPEND.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::APPEND.bits == Self::APPEND.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn DSYNC(&self) -> bool {
                    if Self::DSYNC.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::DSYNC.bits == Self::DSYNC.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn NONBLOCK(&self) -> bool {
                    if Self::NONBLOCK.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::NONBLOCK.bits == Self::NONBLOCK.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn RSYNC(&self) -> bool {
                    if Self::RSYNC.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::RSYNC.bits == Self::RSYNC.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn SYNC(&self) -> bool {
                    if Self::SYNC.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::SYNC.bits == Self::SYNC.bits
                    }
                }
            }
            let mut first = true;
            if <Self as __BitFlags>::APPEND(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("APPEND")?;
            }
            if <Self as __BitFlags>::DSYNC(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("DSYNC")?;
            }
            if <Self as __BitFlags>::NONBLOCK(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("NONBLOCK")?;
            }
            if <Self as __BitFlags>::RSYNC(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("RSYNC")?;
            }
            if <Self as __BitFlags>::SYNC(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("SYNC")?;
            }
            let extra_bits = self.bits & !Self::all().bits();
            if extra_bits != 0 {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("0x")?;
                ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
            }
            if first {
                f.write_str("(empty)")?;
            }
            Ok(())
        }
    }
    impl ::bitflags::_core::fmt::Binary for FdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::Octal for FdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::LowerHex for FdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::UpperHex for FdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
        }
    }
    #[allow(dead_code)]
    impl FdFlags {
        pub const APPEND: Self = Self { bits: 0b1 };
        pub const DSYNC: Self = Self { bits: 0b10 };
        pub const NONBLOCK: Self = Self { bits: 0b100 };
        pub const RSYNC: Self = Self { bits: 0b1000 };
        pub const SYNC: Self = Self { bits: 0b10000 };
        /// Returns an empty set of flags.
        #[inline]
        pub const fn empty() -> Self {
            Self { bits: 0 }
        }
        /// Returns the set containing all flags.
        #[inline]
        pub const fn all() -> Self {
            #[allow(non_snake_case)]
            trait __BitFlags {
                const APPEND: u32 = 0;
                const DSYNC: u32 = 0;
                const NONBLOCK: u32 = 0;
                const RSYNC: u32 = 0;
                const SYNC: u32 = 0;
            }
            #[allow(non_snake_case)]
            impl __BitFlags for FdFlags {
                #[allow(deprecated)]
                const APPEND: u32 = Self::APPEND.bits;
                #[allow(deprecated)]
                const DSYNC: u32 = Self::DSYNC.bits;
                #[allow(deprecated)]
                const NONBLOCK: u32 = Self::NONBLOCK.bits;
                #[allow(deprecated)]
                const RSYNC: u32 = Self::RSYNC.bits;
                #[allow(deprecated)]
                const SYNC: u32 = Self::SYNC.bits;
            }
            Self {
                bits: <Self as __BitFlags>::APPEND | <Self as __BitFlags>::DSYNC
                    | <Self as __BitFlags>::NONBLOCK | <Self as __BitFlags>::RSYNC
                    | <Self as __BitFlags>::SYNC,
            }
        }
        /// Returns the raw value of the flags currently stored.
        #[inline]
        pub const fn bits(&self) -> u32 {
            self.bits
        }
        /// Convert from underlying bit representation, unless that
        /// representation contains bits that do not correspond to a flag.
        #[inline]
        pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
            if (bits & !Self::all().bits()) == 0 {
                ::bitflags::_core::option::Option::Some(Self { bits })
            } else {
                ::bitflags::_core::option::Option::None
            }
        }
        /// Convert from underlying bit representation, dropping any bits
        /// that do not correspond to flags.
        #[inline]
        pub const fn from_bits_truncate(bits: u32) -> Self {
            Self {
                bits: bits & Self::all().bits,
            }
        }
        /// Convert from underlying bit representation, preserving all
        /// bits (even those not corresponding to a defined flag).
        ///
        /// # Safety
        ///
        /// The caller of the `bitflags!` macro can chose to allow or
        /// disallow extra bits for their bitflags type.
        ///
        /// The caller of `from_bits_unchecked()` has to ensure that
        /// all bits correspond to a defined flag or that extra bits
        /// are valid for this bitflags type.
        #[inline]
        pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
            Self { bits }
        }
        /// Returns `true` if no flags are currently stored.
        #[inline]
        pub const fn is_empty(&self) -> bool {
            self.bits() == Self::empty().bits()
        }
        /// Returns `true` if all flags are currently set.
        #[inline]
        pub const fn is_all(&self) -> bool {
            Self::all().bits | self.bits == self.bits
        }
        /// Returns `true` if there are flags common to both `self` and `other`.
        #[inline]
        pub const fn intersects(&self, other: Self) -> bool {
            !(Self {
                bits: self.bits & other.bits,
            })
                .is_empty()
        }
        /// Returns `true` if all of the flags in `other` are contained within `self`.
        #[inline]
        pub const fn contains(&self, other: Self) -> bool {
            (self.bits & other.bits) == other.bits
        }
        /// Inserts the specified flags in-place.
        #[inline]
        pub fn insert(&mut self, other: Self) {
            self.bits |= other.bits;
        }
        /// Removes the specified flags in-place.
        #[inline]
        pub fn remove(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
        /// Toggles the specified flags in-place.
        #[inline]
        pub fn toggle(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
        /// Inserts or removes the specified flags depending on the passed value.
        #[inline]
        pub fn set(&mut self, other: Self, value: bool) {
            if value {
                self.insert(other);
            } else {
                self.remove(other);
            }
        }
        /// Returns the intersection between the flags in `self` and
        /// `other`.
        ///
        /// Specifically, the returned set contains only the flags which are
        /// present in *both* `self` *and* `other`.
        ///
        /// This is equivalent to using the `&` operator (e.g.
        /// [`ops::BitAnd`]), as in `flags & other`.
        ///
        /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
        #[inline]
        #[must_use]
        pub const fn intersection(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
        /// Returns the union of between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags which are
        /// present in *either* `self` *or* `other`, including any which are
        /// present in both (see [`Self::symmetric_difference`] if that
        /// is undesirable).
        ///
        /// This is equivalent to using the `|` operator (e.g.
        /// [`ops::BitOr`]), as in `flags | other`.
        ///
        /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
        #[inline]
        #[must_use]
        pub const fn union(self, other: Self) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
        /// Returns the difference between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags present in
        /// `self`, except for the ones present in `other`.
        ///
        /// It is also conceptually equivalent to the "bit-clear" operation:
        /// `flags & !other` (and this syntax is also supported).
        ///
        /// This is equivalent to using the `-` operator (e.g.
        /// [`ops::Sub`]), as in `flags - other`.
        ///
        /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
        #[inline]
        #[must_use]
        pub const fn difference(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
        /// Returns the [symmetric difference][sym-diff] between the flags
        /// in `self` and `other`.
        ///
        /// Specifically, the returned set contains the flags present which
        /// are present in `self` or `other`, but that are not present in
        /// both. Equivalently, it contains the flags present in *exactly
        /// one* of the sets `self` and `other`.
        ///
        /// This is equivalent to using the `^` operator (e.g.
        /// [`ops::BitXor`]), as in `flags ^ other`.
        ///
        /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
        /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
        #[inline]
        #[must_use]
        pub const fn symmetric_difference(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
        /// Returns the complement of this set of flags.
        ///
        /// Specifically, the returned set contains all the flags which are
        /// not set in `self`, but which are allowed for this type.
        ///
        /// Alternatively, it can be thought of as the set difference
        /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
        ///
        /// This is equivalent to using the `!` operator (e.g.
        /// [`ops::Not`]), as in `!flags`.
        ///
        /// [`Self::all()`]: Self::all
        /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
        #[inline]
        #[must_use]
        pub const fn complement(self) -> Self {
            Self::from_bits_truncate(!self.bits)
        }
    }
    impl ::bitflags::_core::ops::BitOr for FdFlags {
        type Output = Self;
        /// Returns the union of the two sets of flags.
        #[inline]
        fn bitor(self, other: FdFlags) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitOrAssign for FdFlags {
        /// Adds the set of flags.
        #[inline]
        fn bitor_assign(&mut self, other: Self) {
            self.bits |= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitXor for FdFlags {
        type Output = Self;
        /// Returns the left flags, but with all the right flags toggled.
        #[inline]
        fn bitxor(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitXorAssign for FdFlags {
        /// Toggles the set of flags.
        #[inline]
        fn bitxor_assign(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitAnd for FdFlags {
        type Output = Self;
        /// Returns the intersection between the two sets of flags.
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitAndAssign for FdFlags {
        /// Disables all flags disabled in the set.
        #[inline]
        fn bitand_assign(&mut self, other: Self) {
            self.bits &= other.bits;
        }
    }
    impl ::bitflags::_core::ops::Sub for FdFlags {
        type Output = Self;
        /// Returns the set difference of the two sets of flags.
        #[inline]
        fn sub(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::SubAssign for FdFlags {
        /// Disables all flags enabled in the set.
        #[inline]
        fn sub_assign(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
    }
    impl ::bitflags::_core::ops::Not for FdFlags {
        type Output = Self;
        /// Returns the complement of this set of flags.
        #[inline]
        fn not(self) -> Self {
            Self { bits: !self.bits } & Self::all()
        }
    }
    impl ::bitflags::_core::iter::Extend<FdFlags> for FdFlags {
        fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            &mut self,
            iterator: T,
        ) {
            for item in iterator {
                self.insert(item)
            }
        }
    }
    impl ::bitflags::_core::iter::FromIterator<FdFlags> for FdFlags {
        fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            iterator: T,
        ) -> Self {
            let mut result = Self::empty();
            result.extend(iterator);
            result
        }
    }
    pub struct SdFlags {
        bits: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for SdFlags {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SdFlags {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SdFlags {
        #[inline]
        fn eq(&self, other: &SdFlags) -> bool {
            self.bits == other.bits
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for SdFlags {}
    #[automatically_derived]
    impl ::core::cmp::Eq for SdFlags {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SdFlags {
        #[inline]
        fn clone(&self) -> SdFlags {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for SdFlags {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SdFlags,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for SdFlags {
        #[inline]
        fn cmp(&self, other: &SdFlags) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for SdFlags {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.bits, state)
        }
    }
    impl ::bitflags::_core::fmt::Debug for SdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            #[allow(non_snake_case)]
            trait __BitFlags {
                #[inline]
                fn RD(&self) -> bool {
                    false
                }
                #[inline]
                fn WR(&self) -> bool {
                    false
                }
            }
            #[allow(non_snake_case)]
            impl __BitFlags for SdFlags {
                #[allow(deprecated)]
                #[inline]
                fn RD(&self) -> bool {
                    if Self::RD.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::RD.bits == Self::RD.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn WR(&self) -> bool {
                    if Self::WR.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::WR.bits == Self::WR.bits
                    }
                }
            }
            let mut first = true;
            if <Self as __BitFlags>::RD(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("RD")?;
            }
            if <Self as __BitFlags>::WR(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("WR")?;
            }
            let extra_bits = self.bits & !Self::all().bits();
            if extra_bits != 0 {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("0x")?;
                ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
            }
            if first {
                f.write_str("(empty)")?;
            }
            Ok(())
        }
    }
    impl ::bitflags::_core::fmt::Binary for SdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::Octal for SdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::LowerHex for SdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::UpperHex for SdFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
        }
    }
    #[allow(dead_code)]
    impl SdFlags {
        pub const RD: Self = Self { bits: 0b1 };
        pub const WR: Self = Self { bits: 0b10 };
        /// Returns an empty set of flags.
        #[inline]
        pub const fn empty() -> Self {
            Self { bits: 0 }
        }
        /// Returns the set containing all flags.
        #[inline]
        pub const fn all() -> Self {
            #[allow(non_snake_case)]
            trait __BitFlags {
                const RD: u32 = 0;
                const WR: u32 = 0;
            }
            #[allow(non_snake_case)]
            impl __BitFlags for SdFlags {
                #[allow(deprecated)]
                const RD: u32 = Self::RD.bits;
                #[allow(deprecated)]
                const WR: u32 = Self::WR.bits;
            }
            Self {
                bits: <Self as __BitFlags>::RD | <Self as __BitFlags>::WR,
            }
        }
        /// Returns the raw value of the flags currently stored.
        #[inline]
        pub const fn bits(&self) -> u32 {
            self.bits
        }
        /// Convert from underlying bit representation, unless that
        /// representation contains bits that do not correspond to a flag.
        #[inline]
        pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
            if (bits & !Self::all().bits()) == 0 {
                ::bitflags::_core::option::Option::Some(Self { bits })
            } else {
                ::bitflags::_core::option::Option::None
            }
        }
        /// Convert from underlying bit representation, dropping any bits
        /// that do not correspond to flags.
        #[inline]
        pub const fn from_bits_truncate(bits: u32) -> Self {
            Self {
                bits: bits & Self::all().bits,
            }
        }
        /// Convert from underlying bit representation, preserving all
        /// bits (even those not corresponding to a defined flag).
        ///
        /// # Safety
        ///
        /// The caller of the `bitflags!` macro can chose to allow or
        /// disallow extra bits for their bitflags type.
        ///
        /// The caller of `from_bits_unchecked()` has to ensure that
        /// all bits correspond to a defined flag or that extra bits
        /// are valid for this bitflags type.
        #[inline]
        pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
            Self { bits }
        }
        /// Returns `true` if no flags are currently stored.
        #[inline]
        pub const fn is_empty(&self) -> bool {
            self.bits() == Self::empty().bits()
        }
        /// Returns `true` if all flags are currently set.
        #[inline]
        pub const fn is_all(&self) -> bool {
            Self::all().bits | self.bits == self.bits
        }
        /// Returns `true` if there are flags common to both `self` and `other`.
        #[inline]
        pub const fn intersects(&self, other: Self) -> bool {
            !(Self {
                bits: self.bits & other.bits,
            })
                .is_empty()
        }
        /// Returns `true` if all of the flags in `other` are contained within `self`.
        #[inline]
        pub const fn contains(&self, other: Self) -> bool {
            (self.bits & other.bits) == other.bits
        }
        /// Inserts the specified flags in-place.
        #[inline]
        pub fn insert(&mut self, other: Self) {
            self.bits |= other.bits;
        }
        /// Removes the specified flags in-place.
        #[inline]
        pub fn remove(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
        /// Toggles the specified flags in-place.
        #[inline]
        pub fn toggle(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
        /// Inserts or removes the specified flags depending on the passed value.
        #[inline]
        pub fn set(&mut self, other: Self, value: bool) {
            if value {
                self.insert(other);
            } else {
                self.remove(other);
            }
        }
        /// Returns the intersection between the flags in `self` and
        /// `other`.
        ///
        /// Specifically, the returned set contains only the flags which are
        /// present in *both* `self` *and* `other`.
        ///
        /// This is equivalent to using the `&` operator (e.g.
        /// [`ops::BitAnd`]), as in `flags & other`.
        ///
        /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
        #[inline]
        #[must_use]
        pub const fn intersection(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
        /// Returns the union of between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags which are
        /// present in *either* `self` *or* `other`, including any which are
        /// present in both (see [`Self::symmetric_difference`] if that
        /// is undesirable).
        ///
        /// This is equivalent to using the `|` operator (e.g.
        /// [`ops::BitOr`]), as in `flags | other`.
        ///
        /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
        #[inline]
        #[must_use]
        pub const fn union(self, other: Self) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
        /// Returns the difference between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags present in
        /// `self`, except for the ones present in `other`.
        ///
        /// It is also conceptually equivalent to the "bit-clear" operation:
        /// `flags & !other` (and this syntax is also supported).
        ///
        /// This is equivalent to using the `-` operator (e.g.
        /// [`ops::Sub`]), as in `flags - other`.
        ///
        /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
        #[inline]
        #[must_use]
        pub const fn difference(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
        /// Returns the [symmetric difference][sym-diff] between the flags
        /// in `self` and `other`.
        ///
        /// Specifically, the returned set contains the flags present which
        /// are present in `self` or `other`, but that are not present in
        /// both. Equivalently, it contains the flags present in *exactly
        /// one* of the sets `self` and `other`.
        ///
        /// This is equivalent to using the `^` operator (e.g.
        /// [`ops::BitXor`]), as in `flags ^ other`.
        ///
        /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
        /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
        #[inline]
        #[must_use]
        pub const fn symmetric_difference(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
        /// Returns the complement of this set of flags.
        ///
        /// Specifically, the returned set contains all the flags which are
        /// not set in `self`, but which are allowed for this type.
        ///
        /// Alternatively, it can be thought of as the set difference
        /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
        ///
        /// This is equivalent to using the `!` operator (e.g.
        /// [`ops::Not`]), as in `!flags`.
        ///
        /// [`Self::all()`]: Self::all
        /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
        #[inline]
        #[must_use]
        pub const fn complement(self) -> Self {
            Self::from_bits_truncate(!self.bits)
        }
    }
    impl ::bitflags::_core::ops::BitOr for SdFlags {
        type Output = Self;
        /// Returns the union of the two sets of flags.
        #[inline]
        fn bitor(self, other: SdFlags) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitOrAssign for SdFlags {
        /// Adds the set of flags.
        #[inline]
        fn bitor_assign(&mut self, other: Self) {
            self.bits |= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitXor for SdFlags {
        type Output = Self;
        /// Returns the left flags, but with all the right flags toggled.
        #[inline]
        fn bitxor(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitXorAssign for SdFlags {
        /// Toggles the set of flags.
        #[inline]
        fn bitxor_assign(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitAnd for SdFlags {
        type Output = Self;
        /// Returns the intersection between the two sets of flags.
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitAndAssign for SdFlags {
        /// Disables all flags disabled in the set.
        #[inline]
        fn bitand_assign(&mut self, other: Self) {
            self.bits &= other.bits;
        }
    }
    impl ::bitflags::_core::ops::Sub for SdFlags {
        type Output = Self;
        /// Returns the set difference of the two sets of flags.
        #[inline]
        fn sub(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::SubAssign for SdFlags {
        /// Disables all flags enabled in the set.
        #[inline]
        fn sub_assign(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
    }
    impl ::bitflags::_core::ops::Not for SdFlags {
        type Output = Self;
        /// Returns the complement of this set of flags.
        #[inline]
        fn not(self) -> Self {
            Self { bits: !self.bits } & Self::all()
        }
    }
    impl ::bitflags::_core::iter::Extend<SdFlags> for SdFlags {
        fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            &mut self,
            iterator: T,
        ) {
            for item in iterator {
                self.insert(item)
            }
        }
    }
    impl ::bitflags::_core::iter::FromIterator<SdFlags> for SdFlags {
        fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            iterator: T,
        ) -> Self {
            let mut result = Self::empty();
            result.extend(iterator);
            result
        }
    }
    pub struct SiFlags {
        bits: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for SiFlags {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for SiFlags {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for SiFlags {
        #[inline]
        fn eq(&self, other: &SiFlags) -> bool {
            self.bits == other.bits
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for SiFlags {}
    #[automatically_derived]
    impl ::core::cmp::Eq for SiFlags {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SiFlags {
        #[inline]
        fn clone(&self) -> SiFlags {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for SiFlags {
        #[inline]
        fn partial_cmp(
            &self,
            other: &SiFlags,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for SiFlags {
        #[inline]
        fn cmp(&self, other: &SiFlags) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for SiFlags {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.bits, state)
        }
    }
    impl ::bitflags::_core::fmt::Debug for SiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            #[allow(non_snake_case)]
            trait __BitFlags {}
            #[allow(non_snake_case)]
            impl __BitFlags for SiFlags {}
            let mut first = true;
            let extra_bits = self.bits & !Self::all().bits();
            if extra_bits != 0 {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("0x")?;
                ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
            }
            if first {
                f.write_str("(empty)")?;
            }
            Ok(())
        }
    }
    impl ::bitflags::_core::fmt::Binary for SiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::Octal for SiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::LowerHex for SiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::UpperHex for SiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
        }
    }
    #[allow(dead_code)]
    impl SiFlags {
        /// Returns an empty set of flags.
        #[inline]
        pub const fn empty() -> Self {
            Self { bits: 0 }
        }
        /// Returns the set containing all flags.
        #[inline]
        pub const fn all() -> Self {
            Self { bits: 0 }
        }
        /// Returns the raw value of the flags currently stored.
        #[inline]
        pub const fn bits(&self) -> u32 {
            self.bits
        }
        /// Convert from underlying bit representation, unless that
        /// representation contains bits that do not correspond to a flag.
        #[inline]
        pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
            if (bits & !Self::all().bits()) == 0 {
                ::bitflags::_core::option::Option::Some(Self { bits })
            } else {
                ::bitflags::_core::option::Option::None
            }
        }
        /// Convert from underlying bit representation, dropping any bits
        /// that do not correspond to flags.
        #[inline]
        pub const fn from_bits_truncate(bits: u32) -> Self {
            Self {
                bits: bits & Self::all().bits,
            }
        }
        /// Convert from underlying bit representation, preserving all
        /// bits (even those not corresponding to a defined flag).
        ///
        /// # Safety
        ///
        /// The caller of the `bitflags!` macro can chose to allow or
        /// disallow extra bits for their bitflags type.
        ///
        /// The caller of `from_bits_unchecked()` has to ensure that
        /// all bits correspond to a defined flag or that extra bits
        /// are valid for this bitflags type.
        #[inline]
        pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
            Self { bits }
        }
        /// Returns `true` if no flags are currently stored.
        #[inline]
        pub const fn is_empty(&self) -> bool {
            self.bits() == Self::empty().bits()
        }
        /// Returns `true` if all flags are currently set.
        #[inline]
        pub const fn is_all(&self) -> bool {
            Self::all().bits | self.bits == self.bits
        }
        /// Returns `true` if there are flags common to both `self` and `other`.
        #[inline]
        pub const fn intersects(&self, other: Self) -> bool {
            !(Self {
                bits: self.bits & other.bits,
            })
                .is_empty()
        }
        /// Returns `true` if all of the flags in `other` are contained within `self`.
        #[inline]
        pub const fn contains(&self, other: Self) -> bool {
            (self.bits & other.bits) == other.bits
        }
        /// Inserts the specified flags in-place.
        #[inline]
        pub fn insert(&mut self, other: Self) {
            self.bits |= other.bits;
        }
        /// Removes the specified flags in-place.
        #[inline]
        pub fn remove(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
        /// Toggles the specified flags in-place.
        #[inline]
        pub fn toggle(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
        /// Inserts or removes the specified flags depending on the passed value.
        #[inline]
        pub fn set(&mut self, other: Self, value: bool) {
            if value {
                self.insert(other);
            } else {
                self.remove(other);
            }
        }
        /// Returns the intersection between the flags in `self` and
        /// `other`.
        ///
        /// Specifically, the returned set contains only the flags which are
        /// present in *both* `self` *and* `other`.
        ///
        /// This is equivalent to using the `&` operator (e.g.
        /// [`ops::BitAnd`]), as in `flags & other`.
        ///
        /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
        #[inline]
        #[must_use]
        pub const fn intersection(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
        /// Returns the union of between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags which are
        /// present in *either* `self` *or* `other`, including any which are
        /// present in both (see [`Self::symmetric_difference`] if that
        /// is undesirable).
        ///
        /// This is equivalent to using the `|` operator (e.g.
        /// [`ops::BitOr`]), as in `flags | other`.
        ///
        /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
        #[inline]
        #[must_use]
        pub const fn union(self, other: Self) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
        /// Returns the difference between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags present in
        /// `self`, except for the ones present in `other`.
        ///
        /// It is also conceptually equivalent to the "bit-clear" operation:
        /// `flags & !other` (and this syntax is also supported).
        ///
        /// This is equivalent to using the `-` operator (e.g.
        /// [`ops::Sub`]), as in `flags - other`.
        ///
        /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
        #[inline]
        #[must_use]
        pub const fn difference(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
        /// Returns the [symmetric difference][sym-diff] between the flags
        /// in `self` and `other`.
        ///
        /// Specifically, the returned set contains the flags present which
        /// are present in `self` or `other`, but that are not present in
        /// both. Equivalently, it contains the flags present in *exactly
        /// one* of the sets `self` and `other`.
        ///
        /// This is equivalent to using the `^` operator (e.g.
        /// [`ops::BitXor`]), as in `flags ^ other`.
        ///
        /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
        /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
        #[inline]
        #[must_use]
        pub const fn symmetric_difference(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
        /// Returns the complement of this set of flags.
        ///
        /// Specifically, the returned set contains all the flags which are
        /// not set in `self`, but which are allowed for this type.
        ///
        /// Alternatively, it can be thought of as the set difference
        /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
        ///
        /// This is equivalent to using the `!` operator (e.g.
        /// [`ops::Not`]), as in `!flags`.
        ///
        /// [`Self::all()`]: Self::all
        /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
        #[inline]
        #[must_use]
        pub const fn complement(self) -> Self {
            Self::from_bits_truncate(!self.bits)
        }
    }
    impl ::bitflags::_core::ops::BitOr for SiFlags {
        type Output = Self;
        /// Returns the union of the two sets of flags.
        #[inline]
        fn bitor(self, other: SiFlags) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitOrAssign for SiFlags {
        /// Adds the set of flags.
        #[inline]
        fn bitor_assign(&mut self, other: Self) {
            self.bits |= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitXor for SiFlags {
        type Output = Self;
        /// Returns the left flags, but with all the right flags toggled.
        #[inline]
        fn bitxor(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitXorAssign for SiFlags {
        /// Toggles the set of flags.
        #[inline]
        fn bitxor_assign(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitAnd for SiFlags {
        type Output = Self;
        /// Returns the intersection between the two sets of flags.
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitAndAssign for SiFlags {
        /// Disables all flags disabled in the set.
        #[inline]
        fn bitand_assign(&mut self, other: Self) {
            self.bits &= other.bits;
        }
    }
    impl ::bitflags::_core::ops::Sub for SiFlags {
        type Output = Self;
        /// Returns the set difference of the two sets of flags.
        #[inline]
        fn sub(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::SubAssign for SiFlags {
        /// Disables all flags enabled in the set.
        #[inline]
        fn sub_assign(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
    }
    impl ::bitflags::_core::ops::Not for SiFlags {
        type Output = Self;
        /// Returns the complement of this set of flags.
        #[inline]
        fn not(self) -> Self {
            Self { bits: !self.bits } & Self::all()
        }
    }
    impl ::bitflags::_core::iter::Extend<SiFlags> for SiFlags {
        fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            &mut self,
            iterator: T,
        ) {
            for item in iterator {
                self.insert(item)
            }
        }
    }
    impl ::bitflags::_core::iter::FromIterator<SiFlags> for SiFlags {
        fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            iterator: T,
        ) -> Self {
            let mut result = Self::empty();
            result.extend(iterator);
            result
        }
    }
    pub struct RiFlags {
        bits: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for RiFlags {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RiFlags {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RiFlags {
        #[inline]
        fn eq(&self, other: &RiFlags) -> bool {
            self.bits == other.bits
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for RiFlags {}
    #[automatically_derived]
    impl ::core::cmp::Eq for RiFlags {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RiFlags {
        #[inline]
        fn clone(&self) -> RiFlags {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for RiFlags {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RiFlags,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for RiFlags {
        #[inline]
        fn cmp(&self, other: &RiFlags) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for RiFlags {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.bits, state)
        }
    }
    impl ::bitflags::_core::fmt::Debug for RiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            #[allow(non_snake_case)]
            trait __BitFlags {
                #[inline]
                fn RECV_PEEK(&self) -> bool {
                    false
                }
                #[inline]
                fn RECV_WAITALL(&self) -> bool {
                    false
                }
            }
            #[allow(non_snake_case)]
            impl __BitFlags for RiFlags {
                #[allow(deprecated)]
                #[inline]
                fn RECV_PEEK(&self) -> bool {
                    if Self::RECV_PEEK.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::RECV_PEEK.bits == Self::RECV_PEEK.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn RECV_WAITALL(&self) -> bool {
                    if Self::RECV_WAITALL.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::RECV_WAITALL.bits == Self::RECV_WAITALL.bits
                    }
                }
            }
            let mut first = true;
            if <Self as __BitFlags>::RECV_PEEK(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("RECV_PEEK")?;
            }
            if <Self as __BitFlags>::RECV_WAITALL(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("RECV_WAITALL")?;
            }
            let extra_bits = self.bits & !Self::all().bits();
            if extra_bits != 0 {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("0x")?;
                ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
            }
            if first {
                f.write_str("(empty)")?;
            }
            Ok(())
        }
    }
    impl ::bitflags::_core::fmt::Binary for RiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::Octal for RiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::LowerHex for RiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::UpperHex for RiFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
        }
    }
    #[allow(dead_code)]
    impl RiFlags {
        pub const RECV_PEEK: Self = Self { bits: 0b1 };
        pub const RECV_WAITALL: Self = Self { bits: 0b10 };
        /// Returns an empty set of flags.
        #[inline]
        pub const fn empty() -> Self {
            Self { bits: 0 }
        }
        /// Returns the set containing all flags.
        #[inline]
        pub const fn all() -> Self {
            #[allow(non_snake_case)]
            trait __BitFlags {
                const RECV_PEEK: u32 = 0;
                const RECV_WAITALL: u32 = 0;
            }
            #[allow(non_snake_case)]
            impl __BitFlags for RiFlags {
                #[allow(deprecated)]
                const RECV_PEEK: u32 = Self::RECV_PEEK.bits;
                #[allow(deprecated)]
                const RECV_WAITALL: u32 = Self::RECV_WAITALL.bits;
            }
            Self {
                bits: <Self as __BitFlags>::RECV_PEEK
                    | <Self as __BitFlags>::RECV_WAITALL,
            }
        }
        /// Returns the raw value of the flags currently stored.
        #[inline]
        pub const fn bits(&self) -> u32 {
            self.bits
        }
        /// Convert from underlying bit representation, unless that
        /// representation contains bits that do not correspond to a flag.
        #[inline]
        pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
            if (bits & !Self::all().bits()) == 0 {
                ::bitflags::_core::option::Option::Some(Self { bits })
            } else {
                ::bitflags::_core::option::Option::None
            }
        }
        /// Convert from underlying bit representation, dropping any bits
        /// that do not correspond to flags.
        #[inline]
        pub const fn from_bits_truncate(bits: u32) -> Self {
            Self {
                bits: bits & Self::all().bits,
            }
        }
        /// Convert from underlying bit representation, preserving all
        /// bits (even those not corresponding to a defined flag).
        ///
        /// # Safety
        ///
        /// The caller of the `bitflags!` macro can chose to allow or
        /// disallow extra bits for their bitflags type.
        ///
        /// The caller of `from_bits_unchecked()` has to ensure that
        /// all bits correspond to a defined flag or that extra bits
        /// are valid for this bitflags type.
        #[inline]
        pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
            Self { bits }
        }
        /// Returns `true` if no flags are currently stored.
        #[inline]
        pub const fn is_empty(&self) -> bool {
            self.bits() == Self::empty().bits()
        }
        /// Returns `true` if all flags are currently set.
        #[inline]
        pub const fn is_all(&self) -> bool {
            Self::all().bits | self.bits == self.bits
        }
        /// Returns `true` if there are flags common to both `self` and `other`.
        #[inline]
        pub const fn intersects(&self, other: Self) -> bool {
            !(Self {
                bits: self.bits & other.bits,
            })
                .is_empty()
        }
        /// Returns `true` if all of the flags in `other` are contained within `self`.
        #[inline]
        pub const fn contains(&self, other: Self) -> bool {
            (self.bits & other.bits) == other.bits
        }
        /// Inserts the specified flags in-place.
        #[inline]
        pub fn insert(&mut self, other: Self) {
            self.bits |= other.bits;
        }
        /// Removes the specified flags in-place.
        #[inline]
        pub fn remove(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
        /// Toggles the specified flags in-place.
        #[inline]
        pub fn toggle(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
        /// Inserts or removes the specified flags depending on the passed value.
        #[inline]
        pub fn set(&mut self, other: Self, value: bool) {
            if value {
                self.insert(other);
            } else {
                self.remove(other);
            }
        }
        /// Returns the intersection between the flags in `self` and
        /// `other`.
        ///
        /// Specifically, the returned set contains only the flags which are
        /// present in *both* `self` *and* `other`.
        ///
        /// This is equivalent to using the `&` operator (e.g.
        /// [`ops::BitAnd`]), as in `flags & other`.
        ///
        /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
        #[inline]
        #[must_use]
        pub const fn intersection(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
        /// Returns the union of between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags which are
        /// present in *either* `self` *or* `other`, including any which are
        /// present in both (see [`Self::symmetric_difference`] if that
        /// is undesirable).
        ///
        /// This is equivalent to using the `|` operator (e.g.
        /// [`ops::BitOr`]), as in `flags | other`.
        ///
        /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
        #[inline]
        #[must_use]
        pub const fn union(self, other: Self) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
        /// Returns the difference between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags present in
        /// `self`, except for the ones present in `other`.
        ///
        /// It is also conceptually equivalent to the "bit-clear" operation:
        /// `flags & !other` (and this syntax is also supported).
        ///
        /// This is equivalent to using the `-` operator (e.g.
        /// [`ops::Sub`]), as in `flags - other`.
        ///
        /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
        #[inline]
        #[must_use]
        pub const fn difference(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
        /// Returns the [symmetric difference][sym-diff] between the flags
        /// in `self` and `other`.
        ///
        /// Specifically, the returned set contains the flags present which
        /// are present in `self` or `other`, but that are not present in
        /// both. Equivalently, it contains the flags present in *exactly
        /// one* of the sets `self` and `other`.
        ///
        /// This is equivalent to using the `^` operator (e.g.
        /// [`ops::BitXor`]), as in `flags ^ other`.
        ///
        /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
        /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
        #[inline]
        #[must_use]
        pub const fn symmetric_difference(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
        /// Returns the complement of this set of flags.
        ///
        /// Specifically, the returned set contains all the flags which are
        /// not set in `self`, but which are allowed for this type.
        ///
        /// Alternatively, it can be thought of as the set difference
        /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
        ///
        /// This is equivalent to using the `!` operator (e.g.
        /// [`ops::Not`]), as in `!flags`.
        ///
        /// [`Self::all()`]: Self::all
        /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
        #[inline]
        #[must_use]
        pub const fn complement(self) -> Self {
            Self::from_bits_truncate(!self.bits)
        }
    }
    impl ::bitflags::_core::ops::BitOr for RiFlags {
        type Output = Self;
        /// Returns the union of the two sets of flags.
        #[inline]
        fn bitor(self, other: RiFlags) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitOrAssign for RiFlags {
        /// Adds the set of flags.
        #[inline]
        fn bitor_assign(&mut self, other: Self) {
            self.bits |= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitXor for RiFlags {
        type Output = Self;
        /// Returns the left flags, but with all the right flags toggled.
        #[inline]
        fn bitxor(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitXorAssign for RiFlags {
        /// Toggles the set of flags.
        #[inline]
        fn bitxor_assign(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitAnd for RiFlags {
        type Output = Self;
        /// Returns the intersection between the two sets of flags.
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitAndAssign for RiFlags {
        /// Disables all flags disabled in the set.
        #[inline]
        fn bitand_assign(&mut self, other: Self) {
            self.bits &= other.bits;
        }
    }
    impl ::bitflags::_core::ops::Sub for RiFlags {
        type Output = Self;
        /// Returns the set difference of the two sets of flags.
        #[inline]
        fn sub(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::SubAssign for RiFlags {
        /// Disables all flags enabled in the set.
        #[inline]
        fn sub_assign(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
    }
    impl ::bitflags::_core::ops::Not for RiFlags {
        type Output = Self;
        /// Returns the complement of this set of flags.
        #[inline]
        fn not(self) -> Self {
            Self { bits: !self.bits } & Self::all()
        }
    }
    impl ::bitflags::_core::iter::Extend<RiFlags> for RiFlags {
        fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            &mut self,
            iterator: T,
        ) {
            for item in iterator {
                self.insert(item)
            }
        }
    }
    impl ::bitflags::_core::iter::FromIterator<RiFlags> for RiFlags {
        fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            iterator: T,
        ) -> Self {
            let mut result = Self::empty();
            result.extend(iterator);
            result
        }
    }
    pub struct RoFlags {
        bits: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for RoFlags {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for RoFlags {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for RoFlags {
        #[inline]
        fn eq(&self, other: &RoFlags) -> bool {
            self.bits == other.bits
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for RoFlags {}
    #[automatically_derived]
    impl ::core::cmp::Eq for RoFlags {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RoFlags {
        #[inline]
        fn clone(&self) -> RoFlags {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for RoFlags {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RoFlags,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for RoFlags {
        #[inline]
        fn cmp(&self, other: &RoFlags) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for RoFlags {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.bits, state)
        }
    }
    impl ::bitflags::_core::fmt::Debug for RoFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            #[allow(non_snake_case)]
            trait __BitFlags {
                #[inline]
                fn RECV_DATA_TRUNCATED(&self) -> bool {
                    false
                }
            }
            #[allow(non_snake_case)]
            impl __BitFlags for RoFlags {
                #[allow(deprecated)]
                #[inline]
                fn RECV_DATA_TRUNCATED(&self) -> bool {
                    if Self::RECV_DATA_TRUNCATED.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::RECV_DATA_TRUNCATED.bits
                            == Self::RECV_DATA_TRUNCATED.bits
                    }
                }
            }
            let mut first = true;
            if <Self as __BitFlags>::RECV_DATA_TRUNCATED(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("RECV_DATA_TRUNCATED")?;
            }
            let extra_bits = self.bits & !Self::all().bits();
            if extra_bits != 0 {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("0x")?;
                ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
            }
            if first {
                f.write_str("(empty)")?;
            }
            Ok(())
        }
    }
    impl ::bitflags::_core::fmt::Binary for RoFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::Octal for RoFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::LowerHex for RoFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::UpperHex for RoFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
        }
    }
    #[allow(dead_code)]
    impl RoFlags {
        pub const RECV_DATA_TRUNCATED: Self = Self { bits: 0b1 };
        /// Returns an empty set of flags.
        #[inline]
        pub const fn empty() -> Self {
            Self { bits: 0 }
        }
        /// Returns the set containing all flags.
        #[inline]
        pub const fn all() -> Self {
            #[allow(non_snake_case)]
            trait __BitFlags {
                const RECV_DATA_TRUNCATED: u32 = 0;
            }
            #[allow(non_snake_case)]
            impl __BitFlags for RoFlags {
                #[allow(deprecated)]
                const RECV_DATA_TRUNCATED: u32 = Self::RECV_DATA_TRUNCATED.bits;
            }
            Self {
                bits: <Self as __BitFlags>::RECV_DATA_TRUNCATED,
            }
        }
        /// Returns the raw value of the flags currently stored.
        #[inline]
        pub const fn bits(&self) -> u32 {
            self.bits
        }
        /// Convert from underlying bit representation, unless that
        /// representation contains bits that do not correspond to a flag.
        #[inline]
        pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
            if (bits & !Self::all().bits()) == 0 {
                ::bitflags::_core::option::Option::Some(Self { bits })
            } else {
                ::bitflags::_core::option::Option::None
            }
        }
        /// Convert from underlying bit representation, dropping any bits
        /// that do not correspond to flags.
        #[inline]
        pub const fn from_bits_truncate(bits: u32) -> Self {
            Self {
                bits: bits & Self::all().bits,
            }
        }
        /// Convert from underlying bit representation, preserving all
        /// bits (even those not corresponding to a defined flag).
        ///
        /// # Safety
        ///
        /// The caller of the `bitflags!` macro can chose to allow or
        /// disallow extra bits for their bitflags type.
        ///
        /// The caller of `from_bits_unchecked()` has to ensure that
        /// all bits correspond to a defined flag or that extra bits
        /// are valid for this bitflags type.
        #[inline]
        pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
            Self { bits }
        }
        /// Returns `true` if no flags are currently stored.
        #[inline]
        pub const fn is_empty(&self) -> bool {
            self.bits() == Self::empty().bits()
        }
        /// Returns `true` if all flags are currently set.
        #[inline]
        pub const fn is_all(&self) -> bool {
            Self::all().bits | self.bits == self.bits
        }
        /// Returns `true` if there are flags common to both `self` and `other`.
        #[inline]
        pub const fn intersects(&self, other: Self) -> bool {
            !(Self {
                bits: self.bits & other.bits,
            })
                .is_empty()
        }
        /// Returns `true` if all of the flags in `other` are contained within `self`.
        #[inline]
        pub const fn contains(&self, other: Self) -> bool {
            (self.bits & other.bits) == other.bits
        }
        /// Inserts the specified flags in-place.
        #[inline]
        pub fn insert(&mut self, other: Self) {
            self.bits |= other.bits;
        }
        /// Removes the specified flags in-place.
        #[inline]
        pub fn remove(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
        /// Toggles the specified flags in-place.
        #[inline]
        pub fn toggle(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
        /// Inserts or removes the specified flags depending on the passed value.
        #[inline]
        pub fn set(&mut self, other: Self, value: bool) {
            if value {
                self.insert(other);
            } else {
                self.remove(other);
            }
        }
        /// Returns the intersection between the flags in `self` and
        /// `other`.
        ///
        /// Specifically, the returned set contains only the flags which are
        /// present in *both* `self` *and* `other`.
        ///
        /// This is equivalent to using the `&` operator (e.g.
        /// [`ops::BitAnd`]), as in `flags & other`.
        ///
        /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
        #[inline]
        #[must_use]
        pub const fn intersection(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
        /// Returns the union of between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags which are
        /// present in *either* `self` *or* `other`, including any which are
        /// present in both (see [`Self::symmetric_difference`] if that
        /// is undesirable).
        ///
        /// This is equivalent to using the `|` operator (e.g.
        /// [`ops::BitOr`]), as in `flags | other`.
        ///
        /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
        #[inline]
        #[must_use]
        pub const fn union(self, other: Self) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
        /// Returns the difference between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags present in
        /// `self`, except for the ones present in `other`.
        ///
        /// It is also conceptually equivalent to the "bit-clear" operation:
        /// `flags & !other` (and this syntax is also supported).
        ///
        /// This is equivalent to using the `-` operator (e.g.
        /// [`ops::Sub`]), as in `flags - other`.
        ///
        /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
        #[inline]
        #[must_use]
        pub const fn difference(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
        /// Returns the [symmetric difference][sym-diff] between the flags
        /// in `self` and `other`.
        ///
        /// Specifically, the returned set contains the flags present which
        /// are present in `self` or `other`, but that are not present in
        /// both. Equivalently, it contains the flags present in *exactly
        /// one* of the sets `self` and `other`.
        ///
        /// This is equivalent to using the `^` operator (e.g.
        /// [`ops::BitXor`]), as in `flags ^ other`.
        ///
        /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
        /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
        #[inline]
        #[must_use]
        pub const fn symmetric_difference(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
        /// Returns the complement of this set of flags.
        ///
        /// Specifically, the returned set contains all the flags which are
        /// not set in `self`, but which are allowed for this type.
        ///
        /// Alternatively, it can be thought of as the set difference
        /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
        ///
        /// This is equivalent to using the `!` operator (e.g.
        /// [`ops::Not`]), as in `!flags`.
        ///
        /// [`Self::all()`]: Self::all
        /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
        #[inline]
        #[must_use]
        pub const fn complement(self) -> Self {
            Self::from_bits_truncate(!self.bits)
        }
    }
    impl ::bitflags::_core::ops::BitOr for RoFlags {
        type Output = Self;
        /// Returns the union of the two sets of flags.
        #[inline]
        fn bitor(self, other: RoFlags) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitOrAssign for RoFlags {
        /// Adds the set of flags.
        #[inline]
        fn bitor_assign(&mut self, other: Self) {
            self.bits |= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitXor for RoFlags {
        type Output = Self;
        /// Returns the left flags, but with all the right flags toggled.
        #[inline]
        fn bitxor(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitXorAssign for RoFlags {
        /// Toggles the set of flags.
        #[inline]
        fn bitxor_assign(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitAnd for RoFlags {
        type Output = Self;
        /// Returns the intersection between the two sets of flags.
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitAndAssign for RoFlags {
        /// Disables all flags disabled in the set.
        #[inline]
        fn bitand_assign(&mut self, other: Self) {
            self.bits &= other.bits;
        }
    }
    impl ::bitflags::_core::ops::Sub for RoFlags {
        type Output = Self;
        /// Returns the set difference of the two sets of flags.
        #[inline]
        fn sub(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::SubAssign for RoFlags {
        /// Disables all flags enabled in the set.
        #[inline]
        fn sub_assign(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
    }
    impl ::bitflags::_core::ops::Not for RoFlags {
        type Output = Self;
        /// Returns the complement of this set of flags.
        #[inline]
        fn not(self) -> Self {
            Self { bits: !self.bits } & Self::all()
        }
    }
    impl ::bitflags::_core::iter::Extend<RoFlags> for RoFlags {
        fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            &mut self,
            iterator: T,
        ) {
            for item in iterator {
                self.insert(item)
            }
        }
    }
    impl ::bitflags::_core::iter::FromIterator<RoFlags> for RoFlags {
        fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            iterator: T,
        ) -> Self {
            let mut result = Self::empty();
            result.extend(iterator);
            result
        }
    }
    pub struct OFlags {
        bits: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for OFlags {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for OFlags {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for OFlags {
        #[inline]
        fn eq(&self, other: &OFlags) -> bool {
            self.bits == other.bits
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for OFlags {}
    #[automatically_derived]
    impl ::core::cmp::Eq for OFlags {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OFlags {
        #[inline]
        fn clone(&self) -> OFlags {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for OFlags {
        #[inline]
        fn partial_cmp(
            &self,
            other: &OFlags,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for OFlags {
        #[inline]
        fn cmp(&self, other: &OFlags) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for OFlags {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.bits, state)
        }
    }
    impl ::bitflags::_core::fmt::Debug for OFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            #[allow(non_snake_case)]
            trait __BitFlags {
                #[inline]
                fn CREATE(&self) -> bool {
                    false
                }
                #[inline]
                fn DIRECTORY(&self) -> bool {
                    false
                }
                #[inline]
                fn EXCLUSIVE(&self) -> bool {
                    false
                }
                #[inline]
                fn TRUNCATE(&self) -> bool {
                    false
                }
            }
            #[allow(non_snake_case)]
            impl __BitFlags for OFlags {
                #[allow(deprecated)]
                #[inline]
                fn CREATE(&self) -> bool {
                    if Self::CREATE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::CREATE.bits == Self::CREATE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn DIRECTORY(&self) -> bool {
                    if Self::DIRECTORY.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::DIRECTORY.bits == Self::DIRECTORY.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn EXCLUSIVE(&self) -> bool {
                    if Self::EXCLUSIVE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::EXCLUSIVE.bits == Self::EXCLUSIVE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn TRUNCATE(&self) -> bool {
                    if Self::TRUNCATE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::TRUNCATE.bits == Self::TRUNCATE.bits
                    }
                }
            }
            let mut first = true;
            if <Self as __BitFlags>::CREATE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("CREATE")?;
            }
            if <Self as __BitFlags>::DIRECTORY(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("DIRECTORY")?;
            }
            if <Self as __BitFlags>::EXCLUSIVE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("EXCLUSIVE")?;
            }
            if <Self as __BitFlags>::TRUNCATE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("TRUNCATE")?;
            }
            let extra_bits = self.bits & !Self::all().bits();
            if extra_bits != 0 {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("0x")?;
                ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
            }
            if first {
                f.write_str("(empty)")?;
            }
            Ok(())
        }
    }
    impl ::bitflags::_core::fmt::Binary for OFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::Octal for OFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::LowerHex for OFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::UpperHex for OFlags {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
        }
    }
    #[allow(dead_code)]
    impl OFlags {
        pub const CREATE: Self = Self { bits: 0b1 };
        pub const DIRECTORY: Self = Self { bits: 0b10 };
        pub const EXCLUSIVE: Self = Self { bits: 0b100 };
        pub const TRUNCATE: Self = Self { bits: 0b1000 };
        /// Returns an empty set of flags.
        #[inline]
        pub const fn empty() -> Self {
            Self { bits: 0 }
        }
        /// Returns the set containing all flags.
        #[inline]
        pub const fn all() -> Self {
            #[allow(non_snake_case)]
            trait __BitFlags {
                const CREATE: u32 = 0;
                const DIRECTORY: u32 = 0;
                const EXCLUSIVE: u32 = 0;
                const TRUNCATE: u32 = 0;
            }
            #[allow(non_snake_case)]
            impl __BitFlags for OFlags {
                #[allow(deprecated)]
                const CREATE: u32 = Self::CREATE.bits;
                #[allow(deprecated)]
                const DIRECTORY: u32 = Self::DIRECTORY.bits;
                #[allow(deprecated)]
                const EXCLUSIVE: u32 = Self::EXCLUSIVE.bits;
                #[allow(deprecated)]
                const TRUNCATE: u32 = Self::TRUNCATE.bits;
            }
            Self {
                bits: <Self as __BitFlags>::CREATE | <Self as __BitFlags>::DIRECTORY
                    | <Self as __BitFlags>::EXCLUSIVE | <Self as __BitFlags>::TRUNCATE,
            }
        }
        /// Returns the raw value of the flags currently stored.
        #[inline]
        pub const fn bits(&self) -> u32 {
            self.bits
        }
        /// Convert from underlying bit representation, unless that
        /// representation contains bits that do not correspond to a flag.
        #[inline]
        pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
            if (bits & !Self::all().bits()) == 0 {
                ::bitflags::_core::option::Option::Some(Self { bits })
            } else {
                ::bitflags::_core::option::Option::None
            }
        }
        /// Convert from underlying bit representation, dropping any bits
        /// that do not correspond to flags.
        #[inline]
        pub const fn from_bits_truncate(bits: u32) -> Self {
            Self {
                bits: bits & Self::all().bits,
            }
        }
        /// Convert from underlying bit representation, preserving all
        /// bits (even those not corresponding to a defined flag).
        ///
        /// # Safety
        ///
        /// The caller of the `bitflags!` macro can chose to allow or
        /// disallow extra bits for their bitflags type.
        ///
        /// The caller of `from_bits_unchecked()` has to ensure that
        /// all bits correspond to a defined flag or that extra bits
        /// are valid for this bitflags type.
        #[inline]
        pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
            Self { bits }
        }
        /// Returns `true` if no flags are currently stored.
        #[inline]
        pub const fn is_empty(&self) -> bool {
            self.bits() == Self::empty().bits()
        }
        /// Returns `true` if all flags are currently set.
        #[inline]
        pub const fn is_all(&self) -> bool {
            Self::all().bits | self.bits == self.bits
        }
        /// Returns `true` if there are flags common to both `self` and `other`.
        #[inline]
        pub const fn intersects(&self, other: Self) -> bool {
            !(Self {
                bits: self.bits & other.bits,
            })
                .is_empty()
        }
        /// Returns `true` if all of the flags in `other` are contained within `self`.
        #[inline]
        pub const fn contains(&self, other: Self) -> bool {
            (self.bits & other.bits) == other.bits
        }
        /// Inserts the specified flags in-place.
        #[inline]
        pub fn insert(&mut self, other: Self) {
            self.bits |= other.bits;
        }
        /// Removes the specified flags in-place.
        #[inline]
        pub fn remove(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
        /// Toggles the specified flags in-place.
        #[inline]
        pub fn toggle(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
        /// Inserts or removes the specified flags depending on the passed value.
        #[inline]
        pub fn set(&mut self, other: Self, value: bool) {
            if value {
                self.insert(other);
            } else {
                self.remove(other);
            }
        }
        /// Returns the intersection between the flags in `self` and
        /// `other`.
        ///
        /// Specifically, the returned set contains only the flags which are
        /// present in *both* `self` *and* `other`.
        ///
        /// This is equivalent to using the `&` operator (e.g.
        /// [`ops::BitAnd`]), as in `flags & other`.
        ///
        /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
        #[inline]
        #[must_use]
        pub const fn intersection(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
        /// Returns the union of between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags which are
        /// present in *either* `self` *or* `other`, including any which are
        /// present in both (see [`Self::symmetric_difference`] if that
        /// is undesirable).
        ///
        /// This is equivalent to using the `|` operator (e.g.
        /// [`ops::BitOr`]), as in `flags | other`.
        ///
        /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
        #[inline]
        #[must_use]
        pub const fn union(self, other: Self) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
        /// Returns the difference between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags present in
        /// `self`, except for the ones present in `other`.
        ///
        /// It is also conceptually equivalent to the "bit-clear" operation:
        /// `flags & !other` (and this syntax is also supported).
        ///
        /// This is equivalent to using the `-` operator (e.g.
        /// [`ops::Sub`]), as in `flags - other`.
        ///
        /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
        #[inline]
        #[must_use]
        pub const fn difference(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
        /// Returns the [symmetric difference][sym-diff] between the flags
        /// in `self` and `other`.
        ///
        /// Specifically, the returned set contains the flags present which
        /// are present in `self` or `other`, but that are not present in
        /// both. Equivalently, it contains the flags present in *exactly
        /// one* of the sets `self` and `other`.
        ///
        /// This is equivalent to using the `^` operator (e.g.
        /// [`ops::BitXor`]), as in `flags ^ other`.
        ///
        /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
        /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
        #[inline]
        #[must_use]
        pub const fn symmetric_difference(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
        /// Returns the complement of this set of flags.
        ///
        /// Specifically, the returned set contains all the flags which are
        /// not set in `self`, but which are allowed for this type.
        ///
        /// Alternatively, it can be thought of as the set difference
        /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
        ///
        /// This is equivalent to using the `!` operator (e.g.
        /// [`ops::Not`]), as in `!flags`.
        ///
        /// [`Self::all()`]: Self::all
        /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
        #[inline]
        #[must_use]
        pub const fn complement(self) -> Self {
            Self::from_bits_truncate(!self.bits)
        }
    }
    impl ::bitflags::_core::ops::BitOr for OFlags {
        type Output = Self;
        /// Returns the union of the two sets of flags.
        #[inline]
        fn bitor(self, other: OFlags) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitOrAssign for OFlags {
        /// Adds the set of flags.
        #[inline]
        fn bitor_assign(&mut self, other: Self) {
            self.bits |= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitXor for OFlags {
        type Output = Self;
        /// Returns the left flags, but with all the right flags toggled.
        #[inline]
        fn bitxor(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitXorAssign for OFlags {
        /// Toggles the set of flags.
        #[inline]
        fn bitxor_assign(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitAnd for OFlags {
        type Output = Self;
        /// Returns the intersection between the two sets of flags.
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitAndAssign for OFlags {
        /// Disables all flags disabled in the set.
        #[inline]
        fn bitand_assign(&mut self, other: Self) {
            self.bits &= other.bits;
        }
    }
    impl ::bitflags::_core::ops::Sub for OFlags {
        type Output = Self;
        /// Returns the set difference of the two sets of flags.
        #[inline]
        fn sub(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::SubAssign for OFlags {
        /// Disables all flags enabled in the set.
        #[inline]
        fn sub_assign(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
    }
    impl ::bitflags::_core::ops::Not for OFlags {
        type Output = Self;
        /// Returns the complement of this set of flags.
        #[inline]
        fn not(self) -> Self {
            Self { bits: !self.bits } & Self::all()
        }
    }
    impl ::bitflags::_core::iter::Extend<OFlags> for OFlags {
        fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            &mut self,
            iterator: T,
        ) {
            for item in iterator {
                self.insert(item)
            }
        }
    }
    impl ::bitflags::_core::iter::FromIterator<OFlags> for OFlags {
        fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            iterator: T,
        ) -> Self {
            let mut result = Self::empty();
            result.extend(iterator);
            result
        }
    }
    pub struct Filestat {
        pub device_id: u64,
        pub inode: u64,
        pub filetype: FileType,
        pub nlink: u64,
        pub size: u64,
        pub atim: Option<std::time::SystemTime>,
        pub mtim: Option<std::time::SystemTime>,
        pub ctim: Option<std::time::SystemTime>,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Filestat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "device_id",
                "inode",
                "filetype",
                "nlink",
                "size",
                "atim",
                "mtim",
                "ctim",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.device_id,
                &self.inode,
                &self.filetype,
                &self.nlink,
                &self.size,
                &self.atim,
                &self.mtim,
                &&self.ctim,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "Filestat",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Filestat {
        #[inline]
        fn clone(&self) -> Filestat {
            Filestat {
                device_id: ::core::clone::Clone::clone(&self.device_id),
                inode: ::core::clone::Clone::clone(&self.inode),
                filetype: ::core::clone::Clone::clone(&self.filetype),
                nlink: ::core::clone::Clone::clone(&self.nlink),
                size: ::core::clone::Clone::clone(&self.size),
                atim: ::core::clone::Clone::clone(&self.atim),
                mtim: ::core::clone::Clone::clone(&self.mtim),
                ctim: ::core::clone::Clone::clone(&self.ctim),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Filestat {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Filestat {
        #[inline]
        fn eq(&self, other: &Filestat) -> bool {
            self.device_id == other.device_id && self.inode == other.inode
                && self.filetype == other.filetype && self.nlink == other.nlink
                && self.size == other.size && self.atim == other.atim
                && self.mtim == other.mtim && self.ctim == other.ctim
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Filestat {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Filestat {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
            let _: ::core::cmp::AssertParamIsEq<FileType>;
            let _: ::core::cmp::AssertParamIsEq<Option<std::time::SystemTime>>;
            let _: ::core::cmp::AssertParamIsEq<Option<std::time::SystemTime>>;
            let _: ::core::cmp::AssertParamIsEq<Option<std::time::SystemTime>>;
        }
    }
    pub(crate) trait TableFileExt {
        fn get_file(&self, fd: u32) -> Result<Arc<FileEntry>, Error>;
        fn get_file_mut(&mut self, fd: u32) -> Result<&mut FileEntry, Error>;
    }
    impl TableFileExt for crate::table::Table {
        fn get_file(&self, fd: u32) -> Result<Arc<FileEntry>, Error> {
            self.get(fd)
        }
        fn get_file_mut(&mut self, fd: u32) -> Result<&mut FileEntry, Error> {
            self.get_mut(fd)
        }
    }
    pub(crate) struct FileEntry {
        caps: RwLock<FileCaps>,
        file: Box<dyn WasiFile>,
    }
    impl FileEntry {
        pub fn new(caps: FileCaps, file: Box<dyn WasiFile>) -> Self {
            FileEntry {
                caps: RwLock::new(caps),
                file,
            }
        }
        pub fn capable_of(&self, caps: FileCaps) -> Result<(), Error> {
            if self.caps.read().unwrap().contains(caps) {
                Ok(())
            } else {
                let missing = caps & !(*self.caps.read().unwrap());
                let err = if missing.intersects(FileCaps::READ | FileCaps::WRITE) {
                    Error::badf()
                } else {
                    Error::perm()
                };
                Err(
                    err
                        .context({
                            let res = ::alloc::fmt::format(
                                format_args!(
                                    "desired rights {0:?}, has {1:?}", caps, self.caps
                                ),
                            );
                            res
                        }),
                )
            }
        }
        pub fn drop_caps_to(&self, caps: FileCaps) -> Result<(), Error> {
            self.capable_of(caps)?;
            *self.caps.write().unwrap() = caps;
            Ok(())
        }
        pub async fn get_fdstat(&self) -> Result<FdStat, Error> {
            let caps = self.caps.read().unwrap().clone();
            Ok(FdStat {
                filetype: self.file.get_filetype().await?,
                caps,
                flags: self.file.get_fdflags().await?,
            })
        }
    }
    pub trait FileEntryExt {
        fn get_cap(&self, caps: FileCaps) -> Result<&dyn WasiFile, Error>;
        fn get_cap_mut(&mut self, caps: FileCaps) -> Result<&mut dyn WasiFile, Error>;
    }
    impl FileEntryExt for FileEntry {
        fn get_cap(&self, caps: FileCaps) -> Result<&dyn WasiFile, Error> {
            self.capable_of(caps)?;
            Ok(&*self.file)
        }
        fn get_cap_mut(&mut self, caps: FileCaps) -> Result<&mut dyn WasiFile, Error> {
            self.capable_of(caps)?;
            Ok(&mut *self.file)
        }
    }
    pub struct FileCaps {
        bits: u32,
    }
    #[automatically_derived]
    impl ::core::marker::Copy for FileCaps {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for FileCaps {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for FileCaps {
        #[inline]
        fn eq(&self, other: &FileCaps) -> bool {
            self.bits == other.bits
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for FileCaps {}
    #[automatically_derived]
    impl ::core::cmp::Eq for FileCaps {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FileCaps {
        #[inline]
        fn clone(&self) -> FileCaps {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for FileCaps {
        #[inline]
        fn partial_cmp(
            &self,
            other: &FileCaps,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for FileCaps {
        #[inline]
        fn cmp(&self, other: &FileCaps) -> ::core::cmp::Ordering {
            ::core::cmp::Ord::cmp(&self.bits, &other.bits)
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for FileCaps {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.bits, state)
        }
    }
    impl ::bitflags::_core::fmt::Debug for FileCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            #[allow(non_snake_case)]
            trait __BitFlags {
                #[inline]
                fn DATASYNC(&self) -> bool {
                    false
                }
                #[inline]
                fn READ(&self) -> bool {
                    false
                }
                #[inline]
                fn SEEK(&self) -> bool {
                    false
                }
                #[inline]
                fn FDSTAT_SET_FLAGS(&self) -> bool {
                    false
                }
                #[inline]
                fn SYNC(&self) -> bool {
                    false
                }
                #[inline]
                fn TELL(&self) -> bool {
                    false
                }
                #[inline]
                fn WRITE(&self) -> bool {
                    false
                }
                #[inline]
                fn ADVISE(&self) -> bool {
                    false
                }
                #[inline]
                fn ALLOCATE(&self) -> bool {
                    false
                }
                #[inline]
                fn FILESTAT_GET(&self) -> bool {
                    false
                }
                #[inline]
                fn FILESTAT_SET_SIZE(&self) -> bool {
                    false
                }
                #[inline]
                fn FILESTAT_SET_TIMES(&self) -> bool {
                    false
                }
                #[inline]
                fn POLL_READWRITE(&self) -> bool {
                    false
                }
            }
            #[allow(non_snake_case)]
            impl __BitFlags for FileCaps {
                #[allow(deprecated)]
                #[inline]
                fn DATASYNC(&self) -> bool {
                    if Self::DATASYNC.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::DATASYNC.bits == Self::DATASYNC.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn READ(&self) -> bool {
                    if Self::READ.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::READ.bits == Self::READ.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn SEEK(&self) -> bool {
                    if Self::SEEK.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::SEEK.bits == Self::SEEK.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn FDSTAT_SET_FLAGS(&self) -> bool {
                    if Self::FDSTAT_SET_FLAGS.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::FDSTAT_SET_FLAGS.bits
                            == Self::FDSTAT_SET_FLAGS.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn SYNC(&self) -> bool {
                    if Self::SYNC.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::SYNC.bits == Self::SYNC.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn TELL(&self) -> bool {
                    if Self::TELL.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::TELL.bits == Self::TELL.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn WRITE(&self) -> bool {
                    if Self::WRITE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::WRITE.bits == Self::WRITE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn ADVISE(&self) -> bool {
                    if Self::ADVISE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::ADVISE.bits == Self::ADVISE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn ALLOCATE(&self) -> bool {
                    if Self::ALLOCATE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::ALLOCATE.bits == Self::ALLOCATE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn FILESTAT_GET(&self) -> bool {
                    if Self::FILESTAT_GET.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::FILESTAT_GET.bits == Self::FILESTAT_GET.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn FILESTAT_SET_SIZE(&self) -> bool {
                    if Self::FILESTAT_SET_SIZE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::FILESTAT_SET_SIZE.bits
                            == Self::FILESTAT_SET_SIZE.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn FILESTAT_SET_TIMES(&self) -> bool {
                    if Self::FILESTAT_SET_TIMES.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::FILESTAT_SET_TIMES.bits
                            == Self::FILESTAT_SET_TIMES.bits
                    }
                }
                #[allow(deprecated)]
                #[inline]
                fn POLL_READWRITE(&self) -> bool {
                    if Self::POLL_READWRITE.bits == 0 && self.bits != 0 {
                        false
                    } else {
                        self.bits & Self::POLL_READWRITE.bits
                            == Self::POLL_READWRITE.bits
                    }
                }
            }
            let mut first = true;
            if <Self as __BitFlags>::DATASYNC(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("DATASYNC")?;
            }
            if <Self as __BitFlags>::READ(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("READ")?;
            }
            if <Self as __BitFlags>::SEEK(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("SEEK")?;
            }
            if <Self as __BitFlags>::FDSTAT_SET_FLAGS(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("FDSTAT_SET_FLAGS")?;
            }
            if <Self as __BitFlags>::SYNC(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("SYNC")?;
            }
            if <Self as __BitFlags>::TELL(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("TELL")?;
            }
            if <Self as __BitFlags>::WRITE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("WRITE")?;
            }
            if <Self as __BitFlags>::ADVISE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("ADVISE")?;
            }
            if <Self as __BitFlags>::ALLOCATE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("ALLOCATE")?;
            }
            if <Self as __BitFlags>::FILESTAT_GET(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("FILESTAT_GET")?;
            }
            if <Self as __BitFlags>::FILESTAT_SET_SIZE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("FILESTAT_SET_SIZE")?;
            }
            if <Self as __BitFlags>::FILESTAT_SET_TIMES(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("FILESTAT_SET_TIMES")?;
            }
            if <Self as __BitFlags>::POLL_READWRITE(self) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("POLL_READWRITE")?;
            }
            let extra_bits = self.bits & !Self::all().bits();
            if extra_bits != 0 {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str("0x")?;
                ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
            }
            if first {
                f.write_str("(empty)")?;
            }
            Ok(())
        }
    }
    impl ::bitflags::_core::fmt::Binary for FileCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::Octal for FileCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::LowerHex for FileCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
        }
    }
    impl ::bitflags::_core::fmt::UpperHex for FileCaps {
        fn fmt(
            &self,
            f: &mut ::bitflags::_core::fmt::Formatter,
        ) -> ::bitflags::_core::fmt::Result {
            ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
        }
    }
    #[allow(dead_code)]
    impl FileCaps {
        pub const DATASYNC: Self = Self { bits: 0b1 };
        pub const READ: Self = Self { bits: 0b10 };
        pub const SEEK: Self = Self { bits: 0b100 };
        pub const FDSTAT_SET_FLAGS: Self = Self { bits: 0b1000 };
        pub const SYNC: Self = Self { bits: 0b10000 };
        pub const TELL: Self = Self { bits: 0b100000 };
        pub const WRITE: Self = Self { bits: 0b1000000 };
        pub const ADVISE: Self = Self { bits: 0b10000000 };
        pub const ALLOCATE: Self = Self { bits: 0b100000000 };
        pub const FILESTAT_GET: Self = Self { bits: 0b1000000000 };
        pub const FILESTAT_SET_SIZE: Self = Self { bits: 0b10000000000 };
        pub const FILESTAT_SET_TIMES: Self = Self { bits: 0b100000000000 };
        pub const POLL_READWRITE: Self = Self { bits: 0b1000000000000 };
        /// Returns an empty set of flags.
        #[inline]
        pub const fn empty() -> Self {
            Self { bits: 0 }
        }
        /// Returns the set containing all flags.
        #[inline]
        pub const fn all() -> Self {
            #[allow(non_snake_case)]
            trait __BitFlags {
                const DATASYNC: u32 = 0;
                const READ: u32 = 0;
                const SEEK: u32 = 0;
                const FDSTAT_SET_FLAGS: u32 = 0;
                const SYNC: u32 = 0;
                const TELL: u32 = 0;
                const WRITE: u32 = 0;
                const ADVISE: u32 = 0;
                const ALLOCATE: u32 = 0;
                const FILESTAT_GET: u32 = 0;
                const FILESTAT_SET_SIZE: u32 = 0;
                const FILESTAT_SET_TIMES: u32 = 0;
                const POLL_READWRITE: u32 = 0;
            }
            #[allow(non_snake_case)]
            impl __BitFlags for FileCaps {
                #[allow(deprecated)]
                const DATASYNC: u32 = Self::DATASYNC.bits;
                #[allow(deprecated)]
                const READ: u32 = Self::READ.bits;
                #[allow(deprecated)]
                const SEEK: u32 = Self::SEEK.bits;
                #[allow(deprecated)]
                const FDSTAT_SET_FLAGS: u32 = Self::FDSTAT_SET_FLAGS.bits;
                #[allow(deprecated)]
                const SYNC: u32 = Self::SYNC.bits;
                #[allow(deprecated)]
                const TELL: u32 = Self::TELL.bits;
                #[allow(deprecated)]
                const WRITE: u32 = Self::WRITE.bits;
                #[allow(deprecated)]
                const ADVISE: u32 = Self::ADVISE.bits;
                #[allow(deprecated)]
                const ALLOCATE: u32 = Self::ALLOCATE.bits;
                #[allow(deprecated)]
                const FILESTAT_GET: u32 = Self::FILESTAT_GET.bits;
                #[allow(deprecated)]
                const FILESTAT_SET_SIZE: u32 = Self::FILESTAT_SET_SIZE.bits;
                #[allow(deprecated)]
                const FILESTAT_SET_TIMES: u32 = Self::FILESTAT_SET_TIMES.bits;
                #[allow(deprecated)]
                const POLL_READWRITE: u32 = Self::POLL_READWRITE.bits;
            }
            Self {
                bits: <Self as __BitFlags>::DATASYNC | <Self as __BitFlags>::READ
                    | <Self as __BitFlags>::SEEK | <Self as __BitFlags>::FDSTAT_SET_FLAGS
                    | <Self as __BitFlags>::SYNC | <Self as __BitFlags>::TELL
                    | <Self as __BitFlags>::WRITE | <Self as __BitFlags>::ADVISE
                    | <Self as __BitFlags>::ALLOCATE | <Self as __BitFlags>::FILESTAT_GET
                    | <Self as __BitFlags>::FILESTAT_SET_SIZE
                    | <Self as __BitFlags>::FILESTAT_SET_TIMES
                    | <Self as __BitFlags>::POLL_READWRITE,
            }
        }
        /// Returns the raw value of the flags currently stored.
        #[inline]
        pub const fn bits(&self) -> u32 {
            self.bits
        }
        /// Convert from underlying bit representation, unless that
        /// representation contains bits that do not correspond to a flag.
        #[inline]
        pub const fn from_bits(bits: u32) -> ::bitflags::_core::option::Option<Self> {
            if (bits & !Self::all().bits()) == 0 {
                ::bitflags::_core::option::Option::Some(Self { bits })
            } else {
                ::bitflags::_core::option::Option::None
            }
        }
        /// Convert from underlying bit representation, dropping any bits
        /// that do not correspond to flags.
        #[inline]
        pub const fn from_bits_truncate(bits: u32) -> Self {
            Self {
                bits: bits & Self::all().bits,
            }
        }
        /// Convert from underlying bit representation, preserving all
        /// bits (even those not corresponding to a defined flag).
        ///
        /// # Safety
        ///
        /// The caller of the `bitflags!` macro can chose to allow or
        /// disallow extra bits for their bitflags type.
        ///
        /// The caller of `from_bits_unchecked()` has to ensure that
        /// all bits correspond to a defined flag or that extra bits
        /// are valid for this bitflags type.
        #[inline]
        pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
            Self { bits }
        }
        /// Returns `true` if no flags are currently stored.
        #[inline]
        pub const fn is_empty(&self) -> bool {
            self.bits() == Self::empty().bits()
        }
        /// Returns `true` if all flags are currently set.
        #[inline]
        pub const fn is_all(&self) -> bool {
            Self::all().bits | self.bits == self.bits
        }
        /// Returns `true` if there are flags common to both `self` and `other`.
        #[inline]
        pub const fn intersects(&self, other: Self) -> bool {
            !(Self {
                bits: self.bits & other.bits,
            })
                .is_empty()
        }
        /// Returns `true` if all of the flags in `other` are contained within `self`.
        #[inline]
        pub const fn contains(&self, other: Self) -> bool {
            (self.bits & other.bits) == other.bits
        }
        /// Inserts the specified flags in-place.
        #[inline]
        pub fn insert(&mut self, other: Self) {
            self.bits |= other.bits;
        }
        /// Removes the specified flags in-place.
        #[inline]
        pub fn remove(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
        /// Toggles the specified flags in-place.
        #[inline]
        pub fn toggle(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
        /// Inserts or removes the specified flags depending on the passed value.
        #[inline]
        pub fn set(&mut self, other: Self, value: bool) {
            if value {
                self.insert(other);
            } else {
                self.remove(other);
            }
        }
        /// Returns the intersection between the flags in `self` and
        /// `other`.
        ///
        /// Specifically, the returned set contains only the flags which are
        /// present in *both* `self` *and* `other`.
        ///
        /// This is equivalent to using the `&` operator (e.g.
        /// [`ops::BitAnd`]), as in `flags & other`.
        ///
        /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
        #[inline]
        #[must_use]
        pub const fn intersection(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
        /// Returns the union of between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags which are
        /// present in *either* `self` *or* `other`, including any which are
        /// present in both (see [`Self::symmetric_difference`] if that
        /// is undesirable).
        ///
        /// This is equivalent to using the `|` operator (e.g.
        /// [`ops::BitOr`]), as in `flags | other`.
        ///
        /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
        #[inline]
        #[must_use]
        pub const fn union(self, other: Self) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
        /// Returns the difference between the flags in `self` and `other`.
        ///
        /// Specifically, the returned set contains all flags present in
        /// `self`, except for the ones present in `other`.
        ///
        /// It is also conceptually equivalent to the "bit-clear" operation:
        /// `flags & !other` (and this syntax is also supported).
        ///
        /// This is equivalent to using the `-` operator (e.g.
        /// [`ops::Sub`]), as in `flags - other`.
        ///
        /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
        #[inline]
        #[must_use]
        pub const fn difference(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
        /// Returns the [symmetric difference][sym-diff] between the flags
        /// in `self` and `other`.
        ///
        /// Specifically, the returned set contains the flags present which
        /// are present in `self` or `other`, but that are not present in
        /// both. Equivalently, it contains the flags present in *exactly
        /// one* of the sets `self` and `other`.
        ///
        /// This is equivalent to using the `^` operator (e.g.
        /// [`ops::BitXor`]), as in `flags ^ other`.
        ///
        /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
        /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
        #[inline]
        #[must_use]
        pub const fn symmetric_difference(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
        /// Returns the complement of this set of flags.
        ///
        /// Specifically, the returned set contains all the flags which are
        /// not set in `self`, but which are allowed for this type.
        ///
        /// Alternatively, it can be thought of as the set difference
        /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
        ///
        /// This is equivalent to using the `!` operator (e.g.
        /// [`ops::Not`]), as in `!flags`.
        ///
        /// [`Self::all()`]: Self::all
        /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
        #[inline]
        #[must_use]
        pub const fn complement(self) -> Self {
            Self::from_bits_truncate(!self.bits)
        }
    }
    impl ::bitflags::_core::ops::BitOr for FileCaps {
        type Output = Self;
        /// Returns the union of the two sets of flags.
        #[inline]
        fn bitor(self, other: FileCaps) -> Self {
            Self {
                bits: self.bits | other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitOrAssign for FileCaps {
        /// Adds the set of flags.
        #[inline]
        fn bitor_assign(&mut self, other: Self) {
            self.bits |= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitXor for FileCaps {
        type Output = Self;
        /// Returns the left flags, but with all the right flags toggled.
        #[inline]
        fn bitxor(self, other: Self) -> Self {
            Self {
                bits: self.bits ^ other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitXorAssign for FileCaps {
        /// Toggles the set of flags.
        #[inline]
        fn bitxor_assign(&mut self, other: Self) {
            self.bits ^= other.bits;
        }
    }
    impl ::bitflags::_core::ops::BitAnd for FileCaps {
        type Output = Self;
        /// Returns the intersection between the two sets of flags.
        #[inline]
        fn bitand(self, other: Self) -> Self {
            Self {
                bits: self.bits & other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::BitAndAssign for FileCaps {
        /// Disables all flags disabled in the set.
        #[inline]
        fn bitand_assign(&mut self, other: Self) {
            self.bits &= other.bits;
        }
    }
    impl ::bitflags::_core::ops::Sub for FileCaps {
        type Output = Self;
        /// Returns the set difference of the two sets of flags.
        #[inline]
        fn sub(self, other: Self) -> Self {
            Self {
                bits: self.bits & !other.bits,
            }
        }
    }
    impl ::bitflags::_core::ops::SubAssign for FileCaps {
        /// Disables all flags enabled in the set.
        #[inline]
        fn sub_assign(&mut self, other: Self) {
            self.bits &= !other.bits;
        }
    }
    impl ::bitflags::_core::ops::Not for FileCaps {
        type Output = Self;
        /// Returns the complement of this set of flags.
        #[inline]
        fn not(self) -> Self {
            Self { bits: !self.bits } & Self::all()
        }
    }
    impl ::bitflags::_core::iter::Extend<FileCaps> for FileCaps {
        fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            &mut self,
            iterator: T,
        ) {
            for item in iterator {
                self.insert(item)
            }
        }
    }
    impl ::bitflags::_core::iter::FromIterator<FileCaps> for FileCaps {
        fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
            iterator: T,
        ) -> Self {
            let mut result = Self::empty();
            result.extend(iterator);
            result
        }
    }
    pub struct FdStat {
        pub filetype: FileType,
        pub caps: FileCaps,
        pub flags: FdFlags,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for FdStat {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "FdStat",
                "filetype",
                &self.filetype,
                "caps",
                &self.caps,
                "flags",
                &&self.flags,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for FdStat {
        #[inline]
        fn clone(&self) -> FdStat {
            FdStat {
                filetype: ::core::clone::Clone::clone(&self.filetype),
                caps: ::core::clone::Clone::clone(&self.caps),
                flags: ::core::clone::Clone::clone(&self.flags),
            }
        }
    }
    pub enum Advice {
        Normal,
        Sequential,
        Random,
        WillNeed,
        DontNeed,
        NoReuse,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Advice {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    Advice::Normal => "Normal",
                    Advice::Sequential => "Sequential",
                    Advice::Random => "Random",
                    Advice::WillNeed => "WillNeed",
                    Advice::DontNeed => "DontNeed",
                    Advice::NoReuse => "NoReuse",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Advice {
        #[inline]
        fn clone(&self) -> Advice {
            match self {
                Advice::Normal => Advice::Normal,
                Advice::Sequential => Advice::Sequential,
                Advice::Random => Advice::Random,
                Advice::WillNeed => Advice::WillNeed,
                Advice::DontNeed => Advice::DontNeed,
                Advice::NoReuse => Advice::NoReuse,
            }
        }
    }
}
pub mod pipe {
    #![allow(unused_variables, dead_code)]
    //! Virtual pipes.
    //!
    //! These types provide easy implementations of `WasiFile` that mimic much of the behavior of Unix
    //! pipes. These are particularly helpful for redirecting WASI stdio handles to destinations other
    //! than OS files.
    //!
    //! Some convenience constructors are included for common backing types like `Vec<u8>` and `String`,
    //! but the virtual pipes can be instantiated with any `Read` or `Write` type.
    //!
    use crate::file::{FdFlags, FileType, WasiFile};
    use crate::Error;
    use std::any::Any;
    use std::convert::TryInto;
    use std::io::{self, Read, Write};
    use std::sync::{Arc, RwLock};
    /// A virtual pipe read end.
    ///
    /// A variety of `From` impls are provided so that common pipe types are easy to create. For example:
    ///
    /// ```no_run
    /// use wasi_common::{pipe::ReadPipe, WasiCtx, Table};
    /// let stdin = ReadPipe::from("hello from stdin!");
    /// // Brint these instances from elsewhere (e.g. wasi-cap-std-sync):
    /// let random = todo!();
    /// let clocks = todo!();
    /// let sched = todo!();
    /// let table = Table::new();
    /// let mut ctx = WasiCtx::new(random, clocks, sched, table);
    /// ctx.set_stdin(Box::new(stdin.clone()));
    /// ```
    pub struct ReadPipe<R: Read> {
        reader: Arc<RwLock<R>>,
    }
    #[automatically_derived]
    impl<R: ::core::fmt::Debug + Read> ::core::fmt::Debug for ReadPipe<R> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "ReadPipe",
                "reader",
                &&self.reader,
            )
        }
    }
    impl<R: Read> Clone for ReadPipe<R> {
        fn clone(&self) -> Self {
            Self {
                reader: self.reader.clone(),
            }
        }
    }
    impl<R: Read> ReadPipe<R> {
        /// Create a new pipe from a `Read` type.
        ///
        /// All `Handle` read operations delegate to reading from this underlying reader.
        pub fn new(r: R) -> Self {
            Self::from_shared(Arc::new(RwLock::new(r)))
        }
        /// Create a new pipe from a shareable `Read` type.
        ///
        /// All `Handle` read operations delegate to reading from this underlying reader.
        pub fn from_shared(reader: Arc<RwLock<R>>) -> Self {
            Self { reader }
        }
        /// Try to convert this `ReadPipe<R>` back to the underlying `R` type.
        ///
        /// This will fail with `Err(self)` if multiple references to the underlying `R` exist.
        pub fn try_into_inner(mut self) -> Result<R, Self> {
            match Arc::try_unwrap(self.reader) {
                Ok(rc) => Ok(RwLock::into_inner(rc).unwrap()),
                Err(reader) => {
                    self.reader = reader;
                    Err(self)
                }
            }
        }
        fn borrow(&self) -> std::sync::RwLockWriteGuard<R> {
            RwLock::write(&self.reader).unwrap()
        }
    }
    impl From<Vec<u8>> for ReadPipe<io::Cursor<Vec<u8>>> {
        fn from(r: Vec<u8>) -> Self {
            Self::new(io::Cursor::new(r))
        }
    }
    impl From<&[u8]> for ReadPipe<io::Cursor<Vec<u8>>> {
        fn from(r: &[u8]) -> Self {
            Self::from(r.to_vec())
        }
    }
    impl From<String> for ReadPipe<io::Cursor<String>> {
        fn from(r: String) -> Self {
            Self::new(io::Cursor::new(r))
        }
    }
    impl From<&str> for ReadPipe<io::Cursor<String>> {
        fn from(r: &str) -> Self {
            Self::from(r.to_string())
        }
    }
    impl<R: Read + Any + Send + Sync> WasiFile for ReadPipe<R> {
        fn as_any(&self) -> &dyn Any {
            self
        }
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn get_filetype<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<FileType, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<FileType, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<FileType, Error> = { Ok(FileType::Pipe) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn read_vectored<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            bufs: &'life1 mut [io::IoSliceMut<'a>],
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<u64, Error> = {
                    let n = __self.borrow().read_vectored(bufs)?;
                    Ok(n.try_into()?)
                };
                #[allow(unreachable_code)] __ret
            })
        }
    }
    /// A virtual pipe write end.
    ///
    /// ```no_run
    /// use wasi_common::{pipe::WritePipe, WasiCtx, Table};
    /// let stdout = WritePipe::new_in_memory();
    /// // Brint these instances from elsewhere (e.g. wasi-cap-std-sync):
    /// let random = todo!();
    /// let clocks = todo!();
    /// let sched = todo!();
    /// let table = Table::new();
    /// let mut ctx = WasiCtx::new(random, clocks, sched, table);
    /// ctx.set_stdout(Box::new(stdout.clone()));
    /// // use ctx in an instance, then make sure it is dropped:
    /// drop(ctx);
    /// let contents: Vec<u8> = stdout.try_into_inner().expect("sole remaining reference to WritePipe").into_inner();
    /// println!("contents of stdout: {:?}", contents);
    /// ```
    pub struct WritePipe<W: Write> {
        writer: Arc<RwLock<W>>,
    }
    #[automatically_derived]
    impl<W: ::core::fmt::Debug + Write> ::core::fmt::Debug for WritePipe<W> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "WritePipe",
                "writer",
                &&self.writer,
            )
        }
    }
    impl<W: Write> Clone for WritePipe<W> {
        fn clone(&self) -> Self {
            Self {
                writer: self.writer.clone(),
            }
        }
    }
    impl<W: Write> WritePipe<W> {
        /// Create a new pipe from a `Write` type.
        ///
        /// All `Handle` write operations delegate to writing to this underlying writer.
        pub fn new(w: W) -> Self {
            Self::from_shared(Arc::new(RwLock::new(w)))
        }
        /// Create a new pipe from a shareable `Write` type.
        ///
        /// All `Handle` write operations delegate to writing to this underlying writer.
        pub fn from_shared(writer: Arc<RwLock<W>>) -> Self {
            Self { writer }
        }
        /// Try to convert this `WritePipe<W>` back to the underlying `W` type.
        ///
        /// This will fail with `Err(self)` if multiple references to the underlying `W` exist.
        pub fn try_into_inner(mut self) -> Result<W, Self> {
            match Arc::try_unwrap(self.writer) {
                Ok(rc) => Ok(RwLock::into_inner(rc).unwrap()),
                Err(writer) => {
                    self.writer = writer;
                    Err(self)
                }
            }
        }
        fn borrow(&self) -> std::sync::RwLockWriteGuard<W> {
            RwLock::write(&self.writer).unwrap()
        }
    }
    impl WritePipe<io::Cursor<Vec<u8>>> {
        /// Create a new writable virtual pipe backed by a `Vec<u8>` buffer.
        pub fn new_in_memory() -> Self {
            Self::new(io::Cursor::new(::alloc::vec::Vec::new()))
        }
    }
    impl<W: Write + Any + Send + Sync> WasiFile for WritePipe<W> {
        fn as_any(&self) -> &dyn Any {
            self
        }
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn get_filetype<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<FileType, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<FileType, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<FileType, Error> = { Ok(FileType::Pipe) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn get_fdflags<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<FdFlags, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<FdFlags, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<FdFlags, Error> = { Ok(FdFlags::APPEND) };
                #[allow(unreachable_code)] __ret
            })
        }
        #[allow(
            clippy::async_yields_async,
            clippy::let_unit_value,
            clippy::no_effect_underscore_binding,
            clippy::shadow_same,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn write_vectored<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            bufs: &'life1 [io::IoSlice<'a>],
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<u64, Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret)
                    = ::core::option::Option::None::<Result<u64, Error>> {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<u64, Error> = {
                    let n = __self.borrow().write_vectored(bufs)?;
                    Ok(n.try_into()?)
                };
                #[allow(unreachable_code)] __ret
            })
        }
    }
}
pub mod random {
    use cap_rand::RngCore;
    /// Implement `WasiRandom` using a deterministic cycle of bytes.
    pub struct Deterministic {
        cycle: std::iter::Cycle<std::vec::IntoIter<u8>>,
    }
    impl Deterministic {
        pub fn new(bytes: Vec<u8>) -> Self {
            Deterministic {
                cycle: bytes.into_iter().cycle(),
            }
        }
    }
    impl RngCore for Deterministic {
        fn next_u32(&mut self) -> u32 {
            let b0 = self.cycle.next().expect("infinite sequence");
            let b1 = self.cycle.next().expect("infinite sequence");
            let b2 = self.cycle.next().expect("infinite sequence");
            let b3 = self.cycle.next().expect("infinite sequence");
            ((b0 as u32) << 24) + ((b1 as u32) << 16) + ((b2 as u32) << 8) + (b3 as u32)
        }
        fn next_u64(&mut self) -> u64 {
            let w0 = self.next_u32();
            let w1 = self.next_u32();
            ((w0 as u64) << 32) + (w1 as u64)
        }
        fn fill_bytes(&mut self, buf: &mut [u8]) {
            for b in buf.iter_mut() {
                *b = self.cycle.next().expect("infinite sequence");
            }
        }
        fn try_fill_bytes(&mut self, buf: &mut [u8]) -> Result<(), cap_rand::Error> {
            self.fill_bytes(buf);
            Ok(())
        }
    }
}
pub mod sched {
    use crate::clocks::WasiMonotonicClock;
    use crate::file::WasiFile;
    use crate::Error;
    use cap_std::time::Instant;
    pub mod subscription {
        use crate::clocks::WasiMonotonicClock;
        use crate::file::WasiFile;
        use crate::Error;
        use bitflags::bitflags;
        use cap_std::time::{Duration, Instant};
        pub struct RwEventFlags {
            bits: u32,
        }
        #[automatically_derived]
        impl ::core::marker::Copy for RwEventFlags {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for RwEventFlags {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for RwEventFlags {
            #[inline]
            fn eq(&self, other: &RwEventFlags) -> bool {
                self.bits == other.bits
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for RwEventFlags {}
        #[automatically_derived]
        impl ::core::cmp::Eq for RwEventFlags {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<u32>;
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RwEventFlags {
            #[inline]
            fn clone(&self) -> RwEventFlags {
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
        #[automatically_derived]
        impl ::core::cmp::PartialOrd for RwEventFlags {
            #[inline]
            fn partial_cmp(
                &self,
                other: &RwEventFlags,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
            }
        }
        #[automatically_derived]
        impl ::core::cmp::Ord for RwEventFlags {
            #[inline]
            fn cmp(&self, other: &RwEventFlags) -> ::core::cmp::Ordering {
                ::core::cmp::Ord::cmp(&self.bits, &other.bits)
            }
        }
        #[automatically_derived]
        impl ::core::hash::Hash for RwEventFlags {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.bits, state)
            }
        }
        impl ::bitflags::_core::fmt::Debug for RwEventFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                #[allow(non_snake_case)]
                trait __BitFlags {
                    #[inline]
                    fn HANGUP(&self) -> bool {
                        false
                    }
                }
                #[allow(non_snake_case)]
                impl __BitFlags for RwEventFlags {
                    #[allow(deprecated)]
                    #[inline]
                    fn HANGUP(&self) -> bool {
                        if Self::HANGUP.bits == 0 && self.bits != 0 {
                            false
                        } else {
                            self.bits & Self::HANGUP.bits == Self::HANGUP.bits
                        }
                    }
                }
                let mut first = true;
                if <Self as __BitFlags>::HANGUP(self) {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("HANGUP")?;
                }
                let extra_bits = self.bits & !Self::all().bits();
                if extra_bits != 0 {
                    if !first {
                        f.write_str(" | ")?;
                    }
                    first = false;
                    f.write_str("0x")?;
                    ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                }
                if first {
                    f.write_str("(empty)")?;
                }
                Ok(())
            }
        }
        impl ::bitflags::_core::fmt::Binary for RwEventFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::Octal for RwEventFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::LowerHex for RwEventFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
            }
        }
        impl ::bitflags::_core::fmt::UpperHex for RwEventFlags {
            fn fmt(
                &self,
                f: &mut ::bitflags::_core::fmt::Formatter,
            ) -> ::bitflags::_core::fmt::Result {
                ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
            }
        }
        #[allow(dead_code)]
        impl RwEventFlags {
            pub const HANGUP: Self = Self { bits: 0b1 };
            /// Returns an empty set of flags.
            #[inline]
            pub const fn empty() -> Self {
                Self { bits: 0 }
            }
            /// Returns the set containing all flags.
            #[inline]
            pub const fn all() -> Self {
                #[allow(non_snake_case)]
                trait __BitFlags {
                    const HANGUP: u32 = 0;
                }
                #[allow(non_snake_case)]
                impl __BitFlags for RwEventFlags {
                    #[allow(deprecated)]
                    const HANGUP: u32 = Self::HANGUP.bits;
                }
                Self {
                    bits: <Self as __BitFlags>::HANGUP,
                }
            }
            /// Returns the raw value of the flags currently stored.
            #[inline]
            pub const fn bits(&self) -> u32 {
                self.bits
            }
            /// Convert from underlying bit representation, unless that
            /// representation contains bits that do not correspond to a flag.
            #[inline]
            pub const fn from_bits(
                bits: u32,
            ) -> ::bitflags::_core::option::Option<Self> {
                if (bits & !Self::all().bits()) == 0 {
                    ::bitflags::_core::option::Option::Some(Self { bits })
                } else {
                    ::bitflags::_core::option::Option::None
                }
            }
            /// Convert from underlying bit representation, dropping any bits
            /// that do not correspond to flags.
            #[inline]
            pub const fn from_bits_truncate(bits: u32) -> Self {
                Self {
                    bits: bits & Self::all().bits,
                }
            }
            /// Convert from underlying bit representation, preserving all
            /// bits (even those not corresponding to a defined flag).
            ///
            /// # Safety
            ///
            /// The caller of the `bitflags!` macro can chose to allow or
            /// disallow extra bits for their bitflags type.
            ///
            /// The caller of `from_bits_unchecked()` has to ensure that
            /// all bits correspond to a defined flag or that extra bits
            /// are valid for this bitflags type.
            #[inline]
            pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
                Self { bits }
            }
            /// Returns `true` if no flags are currently stored.
            #[inline]
            pub const fn is_empty(&self) -> bool {
                self.bits() == Self::empty().bits()
            }
            /// Returns `true` if all flags are currently set.
            #[inline]
            pub const fn is_all(&self) -> bool {
                Self::all().bits | self.bits == self.bits
            }
            /// Returns `true` if there are flags common to both `self` and `other`.
            #[inline]
            pub const fn intersects(&self, other: Self) -> bool {
                !(Self {
                    bits: self.bits & other.bits,
                })
                    .is_empty()
            }
            /// Returns `true` if all of the flags in `other` are contained within `self`.
            #[inline]
            pub const fn contains(&self, other: Self) -> bool {
                (self.bits & other.bits) == other.bits
            }
            /// Inserts the specified flags in-place.
            #[inline]
            pub fn insert(&mut self, other: Self) {
                self.bits |= other.bits;
            }
            /// Removes the specified flags in-place.
            #[inline]
            pub fn remove(&mut self, other: Self) {
                self.bits &= !other.bits;
            }
            /// Toggles the specified flags in-place.
            #[inline]
            pub fn toggle(&mut self, other: Self) {
                self.bits ^= other.bits;
            }
            /// Inserts or removes the specified flags depending on the passed value.
            #[inline]
            pub fn set(&mut self, other: Self, value: bool) {
                if value {
                    self.insert(other);
                } else {
                    self.remove(other);
                }
            }
            /// Returns the intersection between the flags in `self` and
            /// `other`.
            ///
            /// Specifically, the returned set contains only the flags which are
            /// present in *both* `self` *and* `other`.
            ///
            /// This is equivalent to using the `&` operator (e.g.
            /// [`ops::BitAnd`]), as in `flags & other`.
            ///
            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
            #[inline]
            #[must_use]
            pub const fn intersection(self, other: Self) -> Self {
                Self {
                    bits: self.bits & other.bits,
                }
            }
            /// Returns the union of between the flags in `self` and `other`.
            ///
            /// Specifically, the returned set contains all flags which are
            /// present in *either* `self` *or* `other`, including any which are
            /// present in both (see [`Self::symmetric_difference`] if that
            /// is undesirable).
            ///
            /// This is equivalent to using the `|` operator (e.g.
            /// [`ops::BitOr`]), as in `flags | other`.
            ///
            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
            #[inline]
            #[must_use]
            pub const fn union(self, other: Self) -> Self {
                Self {
                    bits: self.bits | other.bits,
                }
            }
            /// Returns the difference between the flags in `self` and `other`.
            ///
            /// Specifically, the returned set contains all flags present in
            /// `self`, except for the ones present in `other`.
            ///
            /// It is also conceptually equivalent to the "bit-clear" operation:
            /// `flags & !other` (and this syntax is also supported).
            ///
            /// This is equivalent to using the `-` operator (e.g.
            /// [`ops::Sub`]), as in `flags - other`.
            ///
            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
            #[inline]
            #[must_use]
            pub const fn difference(self, other: Self) -> Self {
                Self {
                    bits: self.bits & !other.bits,
                }
            }
            /// Returns the [symmetric difference][sym-diff] between the flags
            /// in `self` and `other`.
            ///
            /// Specifically, the returned set contains the flags present which
            /// are present in `self` or `other`, but that are not present in
            /// both. Equivalently, it contains the flags present in *exactly
            /// one* of the sets `self` and `other`.
            ///
            /// This is equivalent to using the `^` operator (e.g.
            /// [`ops::BitXor`]), as in `flags ^ other`.
            ///
            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
            #[inline]
            #[must_use]
            pub const fn symmetric_difference(self, other: Self) -> Self {
                Self {
                    bits: self.bits ^ other.bits,
                }
            }
            /// Returns the complement of this set of flags.
            ///
            /// Specifically, the returned set contains all the flags which are
            /// not set in `self`, but which are allowed for this type.
            ///
            /// Alternatively, it can be thought of as the set difference
            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
            ///
            /// This is equivalent to using the `!` operator (e.g.
            /// [`ops::Not`]), as in `!flags`.
            ///
            /// [`Self::all()`]: Self::all
            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
            #[inline]
            #[must_use]
            pub const fn complement(self) -> Self {
                Self::from_bits_truncate(!self.bits)
            }
        }
        impl ::bitflags::_core::ops::BitOr for RwEventFlags {
            type Output = Self;
            /// Returns the union of the two sets of flags.
            #[inline]
            fn bitor(self, other: RwEventFlags) -> Self {
                Self {
                    bits: self.bits | other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitOrAssign for RwEventFlags {
            /// Adds the set of flags.
            #[inline]
            fn bitor_assign(&mut self, other: Self) {
                self.bits |= other.bits;
            }
        }
        impl ::bitflags::_core::ops::BitXor for RwEventFlags {
            type Output = Self;
            /// Returns the left flags, but with all the right flags toggled.
            #[inline]
            fn bitxor(self, other: Self) -> Self {
                Self {
                    bits: self.bits ^ other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitXorAssign for RwEventFlags {
            /// Toggles the set of flags.
            #[inline]
            fn bitxor_assign(&mut self, other: Self) {
                self.bits ^= other.bits;
            }
        }
        impl ::bitflags::_core::ops::BitAnd for RwEventFlags {
            type Output = Self;
            /// Returns the intersection between the two sets of flags.
            #[inline]
            fn bitand(self, other: Self) -> Self {
                Self {
                    bits: self.bits & other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::BitAndAssign for RwEventFlags {
            /// Disables all flags disabled in the set.
            #[inline]
            fn bitand_assign(&mut self, other: Self) {
                self.bits &= other.bits;
            }
        }
        impl ::bitflags::_core::ops::Sub for RwEventFlags {
            type Output = Self;
            /// Returns the set difference of the two sets of flags.
            #[inline]
            fn sub(self, other: Self) -> Self {
                Self {
                    bits: self.bits & !other.bits,
                }
            }
        }
        impl ::bitflags::_core::ops::SubAssign for RwEventFlags {
            /// Disables all flags enabled in the set.
            #[inline]
            fn sub_assign(&mut self, other: Self) {
                self.bits &= !other.bits;
            }
        }
        impl ::bitflags::_core::ops::Not for RwEventFlags {
            type Output = Self;
            /// Returns the complement of this set of flags.
            #[inline]
            fn not(self) -> Self {
                Self { bits: !self.bits } & Self::all()
            }
        }
        impl ::bitflags::_core::iter::Extend<RwEventFlags> for RwEventFlags {
            fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                &mut self,
                iterator: T,
            ) {
                for item in iterator {
                    self.insert(item)
                }
            }
        }
        impl ::bitflags::_core::iter::FromIterator<RwEventFlags> for RwEventFlags {
            fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                iterator: T,
            ) -> Self {
                let mut result = Self::empty();
                result.extend(iterator);
                result
            }
        }
        pub struct RwSubscription<'a> {
            pub file: &'a dyn WasiFile,
            status: Option<Result<(u64, RwEventFlags), Error>>,
        }
        impl<'a> RwSubscription<'a> {
            pub fn new(file: &'a dyn WasiFile) -> Self {
                Self { file, status: None }
            }
            pub fn complete(&mut self, size: u64, flags: RwEventFlags) {
                self.status = Some(Ok((size, flags)));
            }
            pub fn error(&mut self, error: Error) {
                self.status = Some(Err(error));
            }
            pub fn result(&mut self) -> Option<Result<(u64, RwEventFlags), Error>> {
                self.status.take()
            }
        }
        pub struct MonotonicClockSubscription<'a> {
            pub clock: &'a dyn WasiMonotonicClock,
            pub deadline: Instant,
            pub precision: Duration,
        }
        impl<'a> MonotonicClockSubscription<'a> {
            pub fn now(&self) -> Instant {
                self.clock.now(self.precision)
            }
            pub fn duration_until(&self) -> Option<Duration> {
                self.deadline.checked_duration_since(self.now())
            }
            pub fn result(&self) -> Option<Result<(), Error>> {
                if self.now().checked_duration_since(self.deadline).is_some() {
                    Some(Ok(()))
                } else {
                    None
                }
            }
        }
        pub enum Subscription<'a> {
            Read(RwSubscription<'a>),
            Write(RwSubscription<'a>),
            MonotonicClock(MonotonicClockSubscription<'a>),
        }
        pub enum SubscriptionResult {
            Read(Result<(u64, RwEventFlags), Error>),
            Write(Result<(u64, RwEventFlags), Error>),
            MonotonicClock(Result<(), Error>),
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for SubscriptionResult {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    SubscriptionResult::Read(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Read",
                            &__self_0,
                        )
                    }
                    SubscriptionResult::Write(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "Write",
                            &__self_0,
                        )
                    }
                    SubscriptionResult::MonotonicClock(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "MonotonicClock",
                            &__self_0,
                        )
                    }
                }
            }
        }
        impl SubscriptionResult {
            pub fn from_subscription(s: Subscription) -> Option<SubscriptionResult> {
                match s {
                    Subscription::Read(mut s) => s.result().map(SubscriptionResult::Read),
                    Subscription::Write(mut s) => {
                        s.result().map(SubscriptionResult::Write)
                    }
                    Subscription::MonotonicClock(s) => {
                        s.result().map(SubscriptionResult::MonotonicClock)
                    }
                }
            }
        }
    }
    pub use cap_std::time::Duration;
    pub use subscription::{
        MonotonicClockSubscription, RwEventFlags, RwSubscription, Subscription,
        SubscriptionResult,
    };
    pub trait WasiSched: Send + Sync {
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn poll_oneoff<'a, 'life0, 'life1, 'async_trait>(
            &'life0 self,
            poll: &'life1 mut Poll<'a>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'a: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn sched_yield<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn sleep<'life0, 'async_trait>(
            &'life0 self,
            duration: Duration,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                    Output = Result<(), Error>,
                > + ::core::marker::Send + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
    }
    pub struct Userdata(u64);
    #[automatically_derived]
    impl ::core::fmt::Debug for Userdata {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Userdata", &&self.0)
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Userdata {}
    #[automatically_derived]
    impl ::core::clone::Clone for Userdata {
        #[inline]
        fn clone(&self) -> Userdata {
            let _: ::core::clone::AssertParamIsClone<u64>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Userdata {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Userdata {
        #[inline]
        fn eq(&self, other: &Userdata) -> bool {
            self.0 == other.0
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Userdata {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Userdata {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u64>;
        }
    }
    impl From<u64> for Userdata {
        fn from(u: u64) -> Userdata {
            Userdata(u)
        }
    }
    impl From<Userdata> for u64 {
        fn from(u: Userdata) -> u64 {
            u.0
        }
    }
    pub type PollResults = Vec<(SubscriptionResult, Userdata)>;
    pub struct Poll<'a> {
        subs: Vec<(Subscription<'a>, Userdata)>,
    }
    impl<'a> Poll<'a> {
        pub fn new() -> Self {
            Self { subs: Vec::new() }
        }
        pub fn subscribe_monotonic_clock(
            &mut self,
            clock: &'a dyn WasiMonotonicClock,
            deadline: Instant,
            precision: Duration,
            ud: Userdata,
        ) {
            self.subs
                .push((
                    Subscription::MonotonicClock(MonotonicClockSubscription {
                        clock,
                        deadline,
                        precision,
                    }),
                    ud,
                ));
        }
        pub fn subscribe_read(&mut self, file: &'a dyn WasiFile, ud: Userdata) {
            self.subs.push((Subscription::Read(RwSubscription::new(file)), ud));
        }
        pub fn subscribe_write(&mut self, file: &'a dyn WasiFile, ud: Userdata) {
            self.subs.push((Subscription::Write(RwSubscription::new(file)), ud));
        }
        pub fn results(self) -> Vec<(SubscriptionResult, Userdata)> {
            self.subs
                .into_iter()
                .filter_map(|(s, ud)| {
                    SubscriptionResult::from_subscription(s).map(|r| (r, ud))
                })
                .collect()
        }
        pub fn is_empty(&self) -> bool {
            self.subs.is_empty()
        }
        pub fn earliest_clock_deadline(
            &self,
        ) -> Option<&MonotonicClockSubscription<'a>> {
            self.subs
                .iter()
                .filter_map(|(s, _ud)| match s {
                    Subscription::MonotonicClock(t) => Some(t),
                    _ => None,
                })
                .min_by(|a, b| a.deadline.cmp(&b.deadline))
        }
        pub fn rw_subscriptions<'b>(
            &'b mut self,
        ) -> impl Iterator<Item = &'b mut Subscription<'a>> {
            self.subs
                .iter_mut()
                .filter_map(|(s, _ud)| match s {
                    Subscription::Read { .. } | Subscription::Write { .. } => Some(s),
                    _ => None,
                })
        }
    }
}
pub mod snapshots {
    //! One goal of `wasi-common` is for multiple WASI snapshots to provide an
    //! interface to the same underlying `crate::WasiCtx`. This provides us a path
    //! to evolve WASI by allowing the same WASI Command to import functions from
    //! different snapshots - e.g. the user could use Rust's `std` which imports
    //! snapshot 1, but also depend directly on the `wasi` crate which imports
    //! some future snapshot 2. Right now, this amounts to supporting snapshot 1
    //! and "snapshot 0" aka wasi_unstable at once.
    //!
    //! The architectural rules for snapshots are:
    //!
    //! * Snapshots are arranged into modules under `crate::snapshots::`.
    //!
    //! * Each snapshot should invoke `wiggle::from_witx!` with `ctx:
    //! crate::WasiCtx` in its module, and impl all of the required traits.
    //!
    //!* Snapshots can be implemented in terms of other snapshots. For example,
    //! snapshot 0 is mostly implemented by calling the snapshot 1 implementation,
    //! and converting its own types back and forth with the snapshot 1 types. In a
    //! few cases, that is not feasible, so snapshot 0 carries its own
    //! implementations in terms of the `WasiFile` and `WasiSched` traits.
    //!
    //! * Snapshots can be implemented in terms of the `Wasi*` traits given by
    //! `WasiCtx`. No further downcasting via the `as_any` escape hatch is
    //! permitted.
    pub mod preview_0 {
        use crate::file::{FileCaps, FileEntryExt, TableFileExt};
        use crate::sched::{
            subscription::{RwEventFlags, SubscriptionResult},
            Poll, Userdata,
        };
        use crate::snapshots::preview_1::types as snapshot1_types;
        use crate::snapshots::preview_1::wasi_snapshot_preview1::WasiSnapshotPreview1 as Snapshot1;
        use crate::snapshots::preview_1::MAX_SHARED_BUFFER_SIZE;
        use crate::{ErrorExt, WasiCtx};
        use cap_std::time::Duration;
        use std::collections::HashSet;
        use std::convert::{TryFrom, TryInto};
        use std::io::{IoSlice, IoSliceMut};
        use std::ops::Deref;
        use wiggle::GuestPtr;
        pub mod types {
            use std::convert::TryFrom;
            pub type Size = u32;
            pub type Filesize = u64;
            pub type Timestamp = u64;
            pub enum Clockid {
                Realtime,
                Monotonic,
                ProcessCputimeId,
                ThreadCputimeId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Clockid {
                #[inline]
                fn clone(&self) -> Clockid {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Clockid {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Clockid::Realtime => "Realtime",
                            Clockid::Monotonic => "Monotonic",
                            Clockid::ProcessCputimeId => "ProcessCputimeId",
                            Clockid::ThreadCputimeId => "ThreadCputimeId",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Clockid {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Clockid {
                #[inline]
                fn eq(&self, other: &Clockid) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Clockid {}
            impl TryFrom<u32> for Clockid {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u32) -> Result<Clockid, wiggle::GuestError> {
                    match value {
                        0 => Ok(Clockid::Realtime),
                        1 => Ok(Clockid::Monotonic),
                        2 => Ok(Clockid::ProcessCputimeId),
                        3 => Ok(Clockid::ThreadCputimeId),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Clockid")),
                    }
                }
            }
            impl TryFrom<i32> for Clockid {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Clockid, wiggle::GuestError> {
                    Clockid::try_from(u32::try_from(value)?)
                }
            }
            impl From<Clockid> for u32 {
                #[inline]
                fn from(v: Clockid) -> u32 {
                    match v {
                        Clockid::Realtime => 0,
                        Clockid::Monotonic => 1,
                        Clockid::ProcessCputimeId => 2,
                        Clockid::ThreadCputimeId => 3,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Clockid {
                #[inline]
                fn guest_size() -> u32 {
                    4u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u32>().read()?;
                    match tag {
                        0 => Ok(Clockid::Realtime),
                        1 => Ok(Clockid::Monotonic),
                        2 => Ok(Clockid::ProcessCputimeId),
                        3 => Ok(Clockid::ThreadCputimeId),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Clockid")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Clockid::Realtime => {
                            location.cast().write(0usize as u32)?;
                        }
                        Clockid::Monotonic => {
                            location.cast().write(1usize as u32)?;
                        }
                        Clockid::ProcessCputimeId => {
                            location.cast().write(2usize as u32)?;
                        }
                        Clockid::ThreadCputimeId => {
                            location.cast().write(3usize as u32)?;
                        }
                    }
                    Ok(())
                }
            }
            pub enum Errno {
                Success,
                TooBig,
                Acces,
                Addrinuse,
                Addrnotavail,
                Afnosupport,
                Again,
                Already,
                Badf,
                Badmsg,
                Busy,
                Canceled,
                Child,
                Connaborted,
                Connrefused,
                Connreset,
                Deadlk,
                Destaddrreq,
                Dom,
                Dquot,
                Exist,
                Fault,
                Fbig,
                Hostunreach,
                Idrm,
                Ilseq,
                Inprogress,
                Intr,
                Inval,
                Io,
                Isconn,
                Isdir,
                Loop,
                Mfile,
                Mlink,
                Msgsize,
                Multihop,
                Nametoolong,
                Netdown,
                Netreset,
                Netunreach,
                Nfile,
                Nobufs,
                Nodev,
                Noent,
                Noexec,
                Nolck,
                Nolink,
                Nomem,
                Nomsg,
                Noprotoopt,
                Nospc,
                Nosys,
                Notconn,
                Notdir,
                Notempty,
                Notrecoverable,
                Notsock,
                Notsup,
                Notty,
                Nxio,
                Overflow,
                Ownerdead,
                Perm,
                Pipe,
                Proto,
                Protonosupport,
                Prototype,
                Range,
                Rofs,
                Spipe,
                Srch,
                Stale,
                Timedout,
                Txtbsy,
                Xdev,
                Notcapable,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Errno {
                #[inline]
                fn clone(&self) -> Errno {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Errno {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Errno::Success => "Success",
                            Errno::TooBig => "TooBig",
                            Errno::Acces => "Acces",
                            Errno::Addrinuse => "Addrinuse",
                            Errno::Addrnotavail => "Addrnotavail",
                            Errno::Afnosupport => "Afnosupport",
                            Errno::Again => "Again",
                            Errno::Already => "Already",
                            Errno::Badf => "Badf",
                            Errno::Badmsg => "Badmsg",
                            Errno::Busy => "Busy",
                            Errno::Canceled => "Canceled",
                            Errno::Child => "Child",
                            Errno::Connaborted => "Connaborted",
                            Errno::Connrefused => "Connrefused",
                            Errno::Connreset => "Connreset",
                            Errno::Deadlk => "Deadlk",
                            Errno::Destaddrreq => "Destaddrreq",
                            Errno::Dom => "Dom",
                            Errno::Dquot => "Dquot",
                            Errno::Exist => "Exist",
                            Errno::Fault => "Fault",
                            Errno::Fbig => "Fbig",
                            Errno::Hostunreach => "Hostunreach",
                            Errno::Idrm => "Idrm",
                            Errno::Ilseq => "Ilseq",
                            Errno::Inprogress => "Inprogress",
                            Errno::Intr => "Intr",
                            Errno::Inval => "Inval",
                            Errno::Io => "Io",
                            Errno::Isconn => "Isconn",
                            Errno::Isdir => "Isdir",
                            Errno::Loop => "Loop",
                            Errno::Mfile => "Mfile",
                            Errno::Mlink => "Mlink",
                            Errno::Msgsize => "Msgsize",
                            Errno::Multihop => "Multihop",
                            Errno::Nametoolong => "Nametoolong",
                            Errno::Netdown => "Netdown",
                            Errno::Netreset => "Netreset",
                            Errno::Netunreach => "Netunreach",
                            Errno::Nfile => "Nfile",
                            Errno::Nobufs => "Nobufs",
                            Errno::Nodev => "Nodev",
                            Errno::Noent => "Noent",
                            Errno::Noexec => "Noexec",
                            Errno::Nolck => "Nolck",
                            Errno::Nolink => "Nolink",
                            Errno::Nomem => "Nomem",
                            Errno::Nomsg => "Nomsg",
                            Errno::Noprotoopt => "Noprotoopt",
                            Errno::Nospc => "Nospc",
                            Errno::Nosys => "Nosys",
                            Errno::Notconn => "Notconn",
                            Errno::Notdir => "Notdir",
                            Errno::Notempty => "Notempty",
                            Errno::Notrecoverable => "Notrecoverable",
                            Errno::Notsock => "Notsock",
                            Errno::Notsup => "Notsup",
                            Errno::Notty => "Notty",
                            Errno::Nxio => "Nxio",
                            Errno::Overflow => "Overflow",
                            Errno::Ownerdead => "Ownerdead",
                            Errno::Perm => "Perm",
                            Errno::Pipe => "Pipe",
                            Errno::Proto => "Proto",
                            Errno::Protonosupport => "Protonosupport",
                            Errno::Prototype => "Prototype",
                            Errno::Range => "Range",
                            Errno::Rofs => "Rofs",
                            Errno::Spipe => "Spipe",
                            Errno::Srch => "Srch",
                            Errno::Stale => "Stale",
                            Errno::Timedout => "Timedout",
                            Errno::Txtbsy => "Txtbsy",
                            Errno::Xdev => "Xdev",
                            Errno::Notcapable => "Notcapable",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Errno {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Errno {
                #[inline]
                fn eq(&self, other: &Errno) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Errno {}
            impl std::fmt::Display for Errno {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for Errno {}
            impl TryFrom<u16> for Errno {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Errno, wiggle::GuestError> {
                    match value {
                        0 => Ok(Errno::Success),
                        1 => Ok(Errno::TooBig),
                        2 => Ok(Errno::Acces),
                        3 => Ok(Errno::Addrinuse),
                        4 => Ok(Errno::Addrnotavail),
                        5 => Ok(Errno::Afnosupport),
                        6 => Ok(Errno::Again),
                        7 => Ok(Errno::Already),
                        8 => Ok(Errno::Badf),
                        9 => Ok(Errno::Badmsg),
                        10 => Ok(Errno::Busy),
                        11 => Ok(Errno::Canceled),
                        12 => Ok(Errno::Child),
                        13 => Ok(Errno::Connaborted),
                        14 => Ok(Errno::Connrefused),
                        15 => Ok(Errno::Connreset),
                        16 => Ok(Errno::Deadlk),
                        17 => Ok(Errno::Destaddrreq),
                        18 => Ok(Errno::Dom),
                        19 => Ok(Errno::Dquot),
                        20 => Ok(Errno::Exist),
                        21 => Ok(Errno::Fault),
                        22 => Ok(Errno::Fbig),
                        23 => Ok(Errno::Hostunreach),
                        24 => Ok(Errno::Idrm),
                        25 => Ok(Errno::Ilseq),
                        26 => Ok(Errno::Inprogress),
                        27 => Ok(Errno::Intr),
                        28 => Ok(Errno::Inval),
                        29 => Ok(Errno::Io),
                        30 => Ok(Errno::Isconn),
                        31 => Ok(Errno::Isdir),
                        32 => Ok(Errno::Loop),
                        33 => Ok(Errno::Mfile),
                        34 => Ok(Errno::Mlink),
                        35 => Ok(Errno::Msgsize),
                        36 => Ok(Errno::Multihop),
                        37 => Ok(Errno::Nametoolong),
                        38 => Ok(Errno::Netdown),
                        39 => Ok(Errno::Netreset),
                        40 => Ok(Errno::Netunreach),
                        41 => Ok(Errno::Nfile),
                        42 => Ok(Errno::Nobufs),
                        43 => Ok(Errno::Nodev),
                        44 => Ok(Errno::Noent),
                        45 => Ok(Errno::Noexec),
                        46 => Ok(Errno::Nolck),
                        47 => Ok(Errno::Nolink),
                        48 => Ok(Errno::Nomem),
                        49 => Ok(Errno::Nomsg),
                        50 => Ok(Errno::Noprotoopt),
                        51 => Ok(Errno::Nospc),
                        52 => Ok(Errno::Nosys),
                        53 => Ok(Errno::Notconn),
                        54 => Ok(Errno::Notdir),
                        55 => Ok(Errno::Notempty),
                        56 => Ok(Errno::Notrecoverable),
                        57 => Ok(Errno::Notsock),
                        58 => Ok(Errno::Notsup),
                        59 => Ok(Errno::Notty),
                        60 => Ok(Errno::Nxio),
                        61 => Ok(Errno::Overflow),
                        62 => Ok(Errno::Ownerdead),
                        63 => Ok(Errno::Perm),
                        64 => Ok(Errno::Pipe),
                        65 => Ok(Errno::Proto),
                        66 => Ok(Errno::Protonosupport),
                        67 => Ok(Errno::Prototype),
                        68 => Ok(Errno::Range),
                        69 => Ok(Errno::Rofs),
                        70 => Ok(Errno::Spipe),
                        71 => Ok(Errno::Srch),
                        72 => Ok(Errno::Stale),
                        73 => Ok(Errno::Timedout),
                        74 => Ok(Errno::Txtbsy),
                        75 => Ok(Errno::Xdev),
                        76 => Ok(Errno::Notcapable),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Errno")),
                    }
                }
            }
            impl TryFrom<i32> for Errno {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Errno, wiggle::GuestError> {
                    Errno::try_from(u16::try_from(value)?)
                }
            }
            impl From<Errno> for u16 {
                #[inline]
                fn from(v: Errno) -> u16 {
                    match v {
                        Errno::Success => 0,
                        Errno::TooBig => 1,
                        Errno::Acces => 2,
                        Errno::Addrinuse => 3,
                        Errno::Addrnotavail => 4,
                        Errno::Afnosupport => 5,
                        Errno::Again => 6,
                        Errno::Already => 7,
                        Errno::Badf => 8,
                        Errno::Badmsg => 9,
                        Errno::Busy => 10,
                        Errno::Canceled => 11,
                        Errno::Child => 12,
                        Errno::Connaborted => 13,
                        Errno::Connrefused => 14,
                        Errno::Connreset => 15,
                        Errno::Deadlk => 16,
                        Errno::Destaddrreq => 17,
                        Errno::Dom => 18,
                        Errno::Dquot => 19,
                        Errno::Exist => 20,
                        Errno::Fault => 21,
                        Errno::Fbig => 22,
                        Errno::Hostunreach => 23,
                        Errno::Idrm => 24,
                        Errno::Ilseq => 25,
                        Errno::Inprogress => 26,
                        Errno::Intr => 27,
                        Errno::Inval => 28,
                        Errno::Io => 29,
                        Errno::Isconn => 30,
                        Errno::Isdir => 31,
                        Errno::Loop => 32,
                        Errno::Mfile => 33,
                        Errno::Mlink => 34,
                        Errno::Msgsize => 35,
                        Errno::Multihop => 36,
                        Errno::Nametoolong => 37,
                        Errno::Netdown => 38,
                        Errno::Netreset => 39,
                        Errno::Netunreach => 40,
                        Errno::Nfile => 41,
                        Errno::Nobufs => 42,
                        Errno::Nodev => 43,
                        Errno::Noent => 44,
                        Errno::Noexec => 45,
                        Errno::Nolck => 46,
                        Errno::Nolink => 47,
                        Errno::Nomem => 48,
                        Errno::Nomsg => 49,
                        Errno::Noprotoopt => 50,
                        Errno::Nospc => 51,
                        Errno::Nosys => 52,
                        Errno::Notconn => 53,
                        Errno::Notdir => 54,
                        Errno::Notempty => 55,
                        Errno::Notrecoverable => 56,
                        Errno::Notsock => 57,
                        Errno::Notsup => 58,
                        Errno::Notty => 59,
                        Errno::Nxio => 60,
                        Errno::Overflow => 61,
                        Errno::Ownerdead => 62,
                        Errno::Perm => 63,
                        Errno::Pipe => 64,
                        Errno::Proto => 65,
                        Errno::Protonosupport => 66,
                        Errno::Prototype => 67,
                        Errno::Range => 68,
                        Errno::Rofs => 69,
                        Errno::Spipe => 70,
                        Errno::Srch => 71,
                        Errno::Stale => 72,
                        Errno::Timedout => 73,
                        Errno::Txtbsy => 74,
                        Errno::Xdev => 75,
                        Errno::Notcapable => 76,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Errno {
                #[inline]
                fn guest_size() -> u32 {
                    2u32
                }
                #[inline]
                fn guest_align() -> usize {
                    2usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u16>().read()?;
                    match tag {
                        0 => Ok(Errno::Success),
                        1 => Ok(Errno::TooBig),
                        2 => Ok(Errno::Acces),
                        3 => Ok(Errno::Addrinuse),
                        4 => Ok(Errno::Addrnotavail),
                        5 => Ok(Errno::Afnosupport),
                        6 => Ok(Errno::Again),
                        7 => Ok(Errno::Already),
                        8 => Ok(Errno::Badf),
                        9 => Ok(Errno::Badmsg),
                        10 => Ok(Errno::Busy),
                        11 => Ok(Errno::Canceled),
                        12 => Ok(Errno::Child),
                        13 => Ok(Errno::Connaborted),
                        14 => Ok(Errno::Connrefused),
                        15 => Ok(Errno::Connreset),
                        16 => Ok(Errno::Deadlk),
                        17 => Ok(Errno::Destaddrreq),
                        18 => Ok(Errno::Dom),
                        19 => Ok(Errno::Dquot),
                        20 => Ok(Errno::Exist),
                        21 => Ok(Errno::Fault),
                        22 => Ok(Errno::Fbig),
                        23 => Ok(Errno::Hostunreach),
                        24 => Ok(Errno::Idrm),
                        25 => Ok(Errno::Ilseq),
                        26 => Ok(Errno::Inprogress),
                        27 => Ok(Errno::Intr),
                        28 => Ok(Errno::Inval),
                        29 => Ok(Errno::Io),
                        30 => Ok(Errno::Isconn),
                        31 => Ok(Errno::Isdir),
                        32 => Ok(Errno::Loop),
                        33 => Ok(Errno::Mfile),
                        34 => Ok(Errno::Mlink),
                        35 => Ok(Errno::Msgsize),
                        36 => Ok(Errno::Multihop),
                        37 => Ok(Errno::Nametoolong),
                        38 => Ok(Errno::Netdown),
                        39 => Ok(Errno::Netreset),
                        40 => Ok(Errno::Netunreach),
                        41 => Ok(Errno::Nfile),
                        42 => Ok(Errno::Nobufs),
                        43 => Ok(Errno::Nodev),
                        44 => Ok(Errno::Noent),
                        45 => Ok(Errno::Noexec),
                        46 => Ok(Errno::Nolck),
                        47 => Ok(Errno::Nolink),
                        48 => Ok(Errno::Nomem),
                        49 => Ok(Errno::Nomsg),
                        50 => Ok(Errno::Noprotoopt),
                        51 => Ok(Errno::Nospc),
                        52 => Ok(Errno::Nosys),
                        53 => Ok(Errno::Notconn),
                        54 => Ok(Errno::Notdir),
                        55 => Ok(Errno::Notempty),
                        56 => Ok(Errno::Notrecoverable),
                        57 => Ok(Errno::Notsock),
                        58 => Ok(Errno::Notsup),
                        59 => Ok(Errno::Notty),
                        60 => Ok(Errno::Nxio),
                        61 => Ok(Errno::Overflow),
                        62 => Ok(Errno::Ownerdead),
                        63 => Ok(Errno::Perm),
                        64 => Ok(Errno::Pipe),
                        65 => Ok(Errno::Proto),
                        66 => Ok(Errno::Protonosupport),
                        67 => Ok(Errno::Prototype),
                        68 => Ok(Errno::Range),
                        69 => Ok(Errno::Rofs),
                        70 => Ok(Errno::Spipe),
                        71 => Ok(Errno::Srch),
                        72 => Ok(Errno::Stale),
                        73 => Ok(Errno::Timedout),
                        74 => Ok(Errno::Txtbsy),
                        75 => Ok(Errno::Xdev),
                        76 => Ok(Errno::Notcapable),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Errno")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Errno::Success => {
                            location.cast().write(0usize as u16)?;
                        }
                        Errno::TooBig => {
                            location.cast().write(1usize as u16)?;
                        }
                        Errno::Acces => {
                            location.cast().write(2usize as u16)?;
                        }
                        Errno::Addrinuse => {
                            location.cast().write(3usize as u16)?;
                        }
                        Errno::Addrnotavail => {
                            location.cast().write(4usize as u16)?;
                        }
                        Errno::Afnosupport => {
                            location.cast().write(5usize as u16)?;
                        }
                        Errno::Again => {
                            location.cast().write(6usize as u16)?;
                        }
                        Errno::Already => {
                            location.cast().write(7usize as u16)?;
                        }
                        Errno::Badf => {
                            location.cast().write(8usize as u16)?;
                        }
                        Errno::Badmsg => {
                            location.cast().write(9usize as u16)?;
                        }
                        Errno::Busy => {
                            location.cast().write(10usize as u16)?;
                        }
                        Errno::Canceled => {
                            location.cast().write(11usize as u16)?;
                        }
                        Errno::Child => {
                            location.cast().write(12usize as u16)?;
                        }
                        Errno::Connaborted => {
                            location.cast().write(13usize as u16)?;
                        }
                        Errno::Connrefused => {
                            location.cast().write(14usize as u16)?;
                        }
                        Errno::Connreset => {
                            location.cast().write(15usize as u16)?;
                        }
                        Errno::Deadlk => {
                            location.cast().write(16usize as u16)?;
                        }
                        Errno::Destaddrreq => {
                            location.cast().write(17usize as u16)?;
                        }
                        Errno::Dom => {
                            location.cast().write(18usize as u16)?;
                        }
                        Errno::Dquot => {
                            location.cast().write(19usize as u16)?;
                        }
                        Errno::Exist => {
                            location.cast().write(20usize as u16)?;
                        }
                        Errno::Fault => {
                            location.cast().write(21usize as u16)?;
                        }
                        Errno::Fbig => {
                            location.cast().write(22usize as u16)?;
                        }
                        Errno::Hostunreach => {
                            location.cast().write(23usize as u16)?;
                        }
                        Errno::Idrm => {
                            location.cast().write(24usize as u16)?;
                        }
                        Errno::Ilseq => {
                            location.cast().write(25usize as u16)?;
                        }
                        Errno::Inprogress => {
                            location.cast().write(26usize as u16)?;
                        }
                        Errno::Intr => {
                            location.cast().write(27usize as u16)?;
                        }
                        Errno::Inval => {
                            location.cast().write(28usize as u16)?;
                        }
                        Errno::Io => {
                            location.cast().write(29usize as u16)?;
                        }
                        Errno::Isconn => {
                            location.cast().write(30usize as u16)?;
                        }
                        Errno::Isdir => {
                            location.cast().write(31usize as u16)?;
                        }
                        Errno::Loop => {
                            location.cast().write(32usize as u16)?;
                        }
                        Errno::Mfile => {
                            location.cast().write(33usize as u16)?;
                        }
                        Errno::Mlink => {
                            location.cast().write(34usize as u16)?;
                        }
                        Errno::Msgsize => {
                            location.cast().write(35usize as u16)?;
                        }
                        Errno::Multihop => {
                            location.cast().write(36usize as u16)?;
                        }
                        Errno::Nametoolong => {
                            location.cast().write(37usize as u16)?;
                        }
                        Errno::Netdown => {
                            location.cast().write(38usize as u16)?;
                        }
                        Errno::Netreset => {
                            location.cast().write(39usize as u16)?;
                        }
                        Errno::Netunreach => {
                            location.cast().write(40usize as u16)?;
                        }
                        Errno::Nfile => {
                            location.cast().write(41usize as u16)?;
                        }
                        Errno::Nobufs => {
                            location.cast().write(42usize as u16)?;
                        }
                        Errno::Nodev => {
                            location.cast().write(43usize as u16)?;
                        }
                        Errno::Noent => {
                            location.cast().write(44usize as u16)?;
                        }
                        Errno::Noexec => {
                            location.cast().write(45usize as u16)?;
                        }
                        Errno::Nolck => {
                            location.cast().write(46usize as u16)?;
                        }
                        Errno::Nolink => {
                            location.cast().write(47usize as u16)?;
                        }
                        Errno::Nomem => {
                            location.cast().write(48usize as u16)?;
                        }
                        Errno::Nomsg => {
                            location.cast().write(49usize as u16)?;
                        }
                        Errno::Noprotoopt => {
                            location.cast().write(50usize as u16)?;
                        }
                        Errno::Nospc => {
                            location.cast().write(51usize as u16)?;
                        }
                        Errno::Nosys => {
                            location.cast().write(52usize as u16)?;
                        }
                        Errno::Notconn => {
                            location.cast().write(53usize as u16)?;
                        }
                        Errno::Notdir => {
                            location.cast().write(54usize as u16)?;
                        }
                        Errno::Notempty => {
                            location.cast().write(55usize as u16)?;
                        }
                        Errno::Notrecoverable => {
                            location.cast().write(56usize as u16)?;
                        }
                        Errno::Notsock => {
                            location.cast().write(57usize as u16)?;
                        }
                        Errno::Notsup => {
                            location.cast().write(58usize as u16)?;
                        }
                        Errno::Notty => {
                            location.cast().write(59usize as u16)?;
                        }
                        Errno::Nxio => {
                            location.cast().write(60usize as u16)?;
                        }
                        Errno::Overflow => {
                            location.cast().write(61usize as u16)?;
                        }
                        Errno::Ownerdead => {
                            location.cast().write(62usize as u16)?;
                        }
                        Errno::Perm => {
                            location.cast().write(63usize as u16)?;
                        }
                        Errno::Pipe => {
                            location.cast().write(64usize as u16)?;
                        }
                        Errno::Proto => {
                            location.cast().write(65usize as u16)?;
                        }
                        Errno::Protonosupport => {
                            location.cast().write(66usize as u16)?;
                        }
                        Errno::Prototype => {
                            location.cast().write(67usize as u16)?;
                        }
                        Errno::Range => {
                            location.cast().write(68usize as u16)?;
                        }
                        Errno::Rofs => {
                            location.cast().write(69usize as u16)?;
                        }
                        Errno::Spipe => {
                            location.cast().write(70usize as u16)?;
                        }
                        Errno::Srch => {
                            location.cast().write(71usize as u16)?;
                        }
                        Errno::Stale => {
                            location.cast().write(72usize as u16)?;
                        }
                        Errno::Timedout => {
                            location.cast().write(73usize as u16)?;
                        }
                        Errno::Txtbsy => {
                            location.cast().write(74usize as u16)?;
                        }
                        Errno::Xdev => {
                            location.cast().write(75usize as u16)?;
                        }
                        Errno::Notcapable => {
                            location.cast().write(76usize as u16)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Error {
                inner: anyhow::Error,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Error {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Error",
                        "inner",
                        &&self.inner,
                    )
                }
            }
            impl std::fmt::Display for Error {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.write_fmt(format_args!("{0}", self.inner))
                }
            }
            impl std::error::Error for Error {
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    self.inner.source()
                }
            }
            impl Error {
                pub fn trap(inner: anyhow::Error) -> Error {
                    Self { inner }
                }
                pub fn downcast(self) -> Result<Errno, anyhow::Error> {
                    self.inner.downcast()
                }
                pub fn downcast_ref(&self) -> Option<&Errno> {
                    self.inner.downcast_ref()
                }
                pub fn context(self, s: impl Into<String>) -> Self {
                    Self {
                        inner: self.inner.context(s.into()),
                    }
                }
            }
            impl From<Errno> for Error {
                fn from(abi: Errno) -> Error {
                    Error {
                        inner: anyhow::Error::from(abi),
                    }
                }
            }
            pub struct Rights {
                bits: u64,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Rights {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Rights {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Rights {
                #[inline]
                fn eq(&self, other: &Rights) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Rights {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Rights {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Rights {
                #[inline]
                fn clone(&self) -> Rights {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Rights {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Rights,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Rights {
                #[inline]
                fn cmp(&self, other: &Rights) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Rights {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn FD_DATASYNC(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_READ(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_SEEK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_FDSTAT_SET_FLAGS(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_SYNC(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_TELL(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_WRITE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_ADVISE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_ALLOCATE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_CREATE_DIRECTORY(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_CREATE_FILE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_LINK_SOURCE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_LINK_TARGET(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_OPEN(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_READDIR(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_READLINK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_RENAME_SOURCE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_RENAME_TARGET(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_FILESTAT_GET(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_FILESTAT_SET_SIZE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_FILESTAT_SET_TIMES(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_FILESTAT_GET(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_FILESTAT_SET_SIZE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_FILESTAT_SET_TIMES(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_SYMLINK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_REMOVE_DIRECTORY(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_UNLINK_FILE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn POLL_FD_READWRITE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn SOCK_SHUTDOWN(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Rights {
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_DATASYNC(&self) -> bool {
                            if Self::FD_DATASYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_DATASYNC.bits == Self::FD_DATASYNC.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_READ(&self) -> bool {
                            if Self::FD_READ.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_READ.bits == Self::FD_READ.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_SEEK(&self) -> bool {
                            if Self::FD_SEEK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_SEEK.bits == Self::FD_SEEK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_FDSTAT_SET_FLAGS(&self) -> bool {
                            if Self::FD_FDSTAT_SET_FLAGS.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_FDSTAT_SET_FLAGS.bits
                                    == Self::FD_FDSTAT_SET_FLAGS.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_SYNC(&self) -> bool {
                            if Self::FD_SYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_SYNC.bits == Self::FD_SYNC.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_TELL(&self) -> bool {
                            if Self::FD_TELL.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_TELL.bits == Self::FD_TELL.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_WRITE(&self) -> bool {
                            if Self::FD_WRITE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_WRITE.bits == Self::FD_WRITE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_ADVISE(&self) -> bool {
                            if Self::FD_ADVISE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_ADVISE.bits == Self::FD_ADVISE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_ALLOCATE(&self) -> bool {
                            if Self::FD_ALLOCATE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_ALLOCATE.bits == Self::FD_ALLOCATE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_CREATE_DIRECTORY(&self) -> bool {
                            if Self::PATH_CREATE_DIRECTORY.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_CREATE_DIRECTORY.bits
                                    == Self::PATH_CREATE_DIRECTORY.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_CREATE_FILE(&self) -> bool {
                            if Self::PATH_CREATE_FILE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_CREATE_FILE.bits
                                    == Self::PATH_CREATE_FILE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_LINK_SOURCE(&self) -> bool {
                            if Self::PATH_LINK_SOURCE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_LINK_SOURCE.bits
                                    == Self::PATH_LINK_SOURCE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_LINK_TARGET(&self) -> bool {
                            if Self::PATH_LINK_TARGET.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_LINK_TARGET.bits
                                    == Self::PATH_LINK_TARGET.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_OPEN(&self) -> bool {
                            if Self::PATH_OPEN.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_OPEN.bits == Self::PATH_OPEN.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_READDIR(&self) -> bool {
                            if Self::FD_READDIR.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_READDIR.bits == Self::FD_READDIR.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_READLINK(&self) -> bool {
                            if Self::PATH_READLINK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_READLINK.bits
                                    == Self::PATH_READLINK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_RENAME_SOURCE(&self) -> bool {
                            if Self::PATH_RENAME_SOURCE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_RENAME_SOURCE.bits
                                    == Self::PATH_RENAME_SOURCE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_RENAME_TARGET(&self) -> bool {
                            if Self::PATH_RENAME_TARGET.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_RENAME_TARGET.bits
                                    == Self::PATH_RENAME_TARGET.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_FILESTAT_GET(&self) -> bool {
                            if Self::PATH_FILESTAT_GET.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_FILESTAT_GET.bits
                                    == Self::PATH_FILESTAT_GET.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_FILESTAT_SET_SIZE(&self) -> bool {
                            if Self::PATH_FILESTAT_SET_SIZE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_FILESTAT_SET_SIZE.bits
                                    == Self::PATH_FILESTAT_SET_SIZE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_FILESTAT_SET_TIMES(&self) -> bool {
                            if Self::PATH_FILESTAT_SET_TIMES.bits == 0 && self.bits != 0
                            {
                                false
                            } else {
                                self.bits & Self::PATH_FILESTAT_SET_TIMES.bits
                                    == Self::PATH_FILESTAT_SET_TIMES.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_FILESTAT_GET(&self) -> bool {
                            if Self::FD_FILESTAT_GET.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_FILESTAT_GET.bits
                                    == Self::FD_FILESTAT_GET.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_FILESTAT_SET_SIZE(&self) -> bool {
                            if Self::FD_FILESTAT_SET_SIZE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_FILESTAT_SET_SIZE.bits
                                    == Self::FD_FILESTAT_SET_SIZE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_FILESTAT_SET_TIMES(&self) -> bool {
                            if Self::FD_FILESTAT_SET_TIMES.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_FILESTAT_SET_TIMES.bits
                                    == Self::FD_FILESTAT_SET_TIMES.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_SYMLINK(&self) -> bool {
                            if Self::PATH_SYMLINK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_SYMLINK.bits
                                    == Self::PATH_SYMLINK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_REMOVE_DIRECTORY(&self) -> bool {
                            if Self::PATH_REMOVE_DIRECTORY.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_REMOVE_DIRECTORY.bits
                                    == Self::PATH_REMOVE_DIRECTORY.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_UNLINK_FILE(&self) -> bool {
                            if Self::PATH_UNLINK_FILE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_UNLINK_FILE.bits
                                    == Self::PATH_UNLINK_FILE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn POLL_FD_READWRITE(&self) -> bool {
                            if Self::POLL_FD_READWRITE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::POLL_FD_READWRITE.bits
                                    == Self::POLL_FD_READWRITE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn SOCK_SHUTDOWN(&self) -> bool {
                            if Self::SOCK_SHUTDOWN.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::SOCK_SHUTDOWN.bits
                                    == Self::SOCK_SHUTDOWN.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::FD_DATASYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_DATASYNC")?;
                    }
                    if <Self as __BitFlags>::FD_READ(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_READ")?;
                    }
                    if <Self as __BitFlags>::FD_SEEK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_SEEK")?;
                    }
                    if <Self as __BitFlags>::FD_FDSTAT_SET_FLAGS(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_FDSTAT_SET_FLAGS")?;
                    }
                    if <Self as __BitFlags>::FD_SYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_SYNC")?;
                    }
                    if <Self as __BitFlags>::FD_TELL(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_TELL")?;
                    }
                    if <Self as __BitFlags>::FD_WRITE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_WRITE")?;
                    }
                    if <Self as __BitFlags>::FD_ADVISE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_ADVISE")?;
                    }
                    if <Self as __BitFlags>::FD_ALLOCATE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_ALLOCATE")?;
                    }
                    if <Self as __BitFlags>::PATH_CREATE_DIRECTORY(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_CREATE_DIRECTORY")?;
                    }
                    if <Self as __BitFlags>::PATH_CREATE_FILE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_CREATE_FILE")?;
                    }
                    if <Self as __BitFlags>::PATH_LINK_SOURCE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_LINK_SOURCE")?;
                    }
                    if <Self as __BitFlags>::PATH_LINK_TARGET(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_LINK_TARGET")?;
                    }
                    if <Self as __BitFlags>::PATH_OPEN(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_OPEN")?;
                    }
                    if <Self as __BitFlags>::FD_READDIR(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_READDIR")?;
                    }
                    if <Self as __BitFlags>::PATH_READLINK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_READLINK")?;
                    }
                    if <Self as __BitFlags>::PATH_RENAME_SOURCE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_RENAME_SOURCE")?;
                    }
                    if <Self as __BitFlags>::PATH_RENAME_TARGET(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_RENAME_TARGET")?;
                    }
                    if <Self as __BitFlags>::PATH_FILESTAT_GET(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_FILESTAT_GET")?;
                    }
                    if <Self as __BitFlags>::PATH_FILESTAT_SET_SIZE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_FILESTAT_SET_SIZE")?;
                    }
                    if <Self as __BitFlags>::PATH_FILESTAT_SET_TIMES(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_FILESTAT_SET_TIMES")?;
                    }
                    if <Self as __BitFlags>::FD_FILESTAT_GET(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_FILESTAT_GET")?;
                    }
                    if <Self as __BitFlags>::FD_FILESTAT_SET_SIZE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_FILESTAT_SET_SIZE")?;
                    }
                    if <Self as __BitFlags>::FD_FILESTAT_SET_TIMES(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_FILESTAT_SET_TIMES")?;
                    }
                    if <Self as __BitFlags>::PATH_SYMLINK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_SYMLINK")?;
                    }
                    if <Self as __BitFlags>::PATH_REMOVE_DIRECTORY(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_REMOVE_DIRECTORY")?;
                    }
                    if <Self as __BitFlags>::PATH_UNLINK_FILE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_UNLINK_FILE")?;
                    }
                    if <Self as __BitFlags>::POLL_FD_READWRITE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("POLL_FD_READWRITE")?;
                    }
                    if <Self as __BitFlags>::SOCK_SHUTDOWN(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SOCK_SHUTDOWN")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Rights {
                pub const FD_DATASYNC: Self = Self { bits: 1 };
                pub const FD_READ: Self = Self { bits: 2 };
                pub const FD_SEEK: Self = Self { bits: 4 };
                pub const FD_FDSTAT_SET_FLAGS: Self = Self { bits: 8 };
                pub const FD_SYNC: Self = Self { bits: 16 };
                pub const FD_TELL: Self = Self { bits: 32 };
                pub const FD_WRITE: Self = Self { bits: 64 };
                pub const FD_ADVISE: Self = Self { bits: 128 };
                pub const FD_ALLOCATE: Self = Self { bits: 256 };
                pub const PATH_CREATE_DIRECTORY: Self = Self { bits: 512 };
                pub const PATH_CREATE_FILE: Self = Self { bits: 1024 };
                pub const PATH_LINK_SOURCE: Self = Self { bits: 2048 };
                pub const PATH_LINK_TARGET: Self = Self { bits: 4096 };
                pub const PATH_OPEN: Self = Self { bits: 8192 };
                pub const FD_READDIR: Self = Self { bits: 16384 };
                pub const PATH_READLINK: Self = Self { bits: 32768 };
                pub const PATH_RENAME_SOURCE: Self = Self { bits: 65536 };
                pub const PATH_RENAME_TARGET: Self = Self { bits: 131072 };
                pub const PATH_FILESTAT_GET: Self = Self { bits: 262144 };
                pub const PATH_FILESTAT_SET_SIZE: Self = Self { bits: 524288 };
                pub const PATH_FILESTAT_SET_TIMES: Self = Self { bits: 1048576 };
                pub const FD_FILESTAT_GET: Self = Self { bits: 2097152 };
                pub const FD_FILESTAT_SET_SIZE: Self = Self { bits: 4194304 };
                pub const FD_FILESTAT_SET_TIMES: Self = Self { bits: 8388608 };
                pub const PATH_SYMLINK: Self = Self { bits: 16777216 };
                pub const PATH_REMOVE_DIRECTORY: Self = Self { bits: 33554432 };
                pub const PATH_UNLINK_FILE: Self = Self { bits: 67108864 };
                pub const POLL_FD_READWRITE: Self = Self { bits: 134217728 };
                pub const SOCK_SHUTDOWN: Self = Self { bits: 268435456 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const FD_DATASYNC: u64 = 0;
                        const FD_READ: u64 = 0;
                        const FD_SEEK: u64 = 0;
                        const FD_FDSTAT_SET_FLAGS: u64 = 0;
                        const FD_SYNC: u64 = 0;
                        const FD_TELL: u64 = 0;
                        const FD_WRITE: u64 = 0;
                        const FD_ADVISE: u64 = 0;
                        const FD_ALLOCATE: u64 = 0;
                        const PATH_CREATE_DIRECTORY: u64 = 0;
                        const PATH_CREATE_FILE: u64 = 0;
                        const PATH_LINK_SOURCE: u64 = 0;
                        const PATH_LINK_TARGET: u64 = 0;
                        const PATH_OPEN: u64 = 0;
                        const FD_READDIR: u64 = 0;
                        const PATH_READLINK: u64 = 0;
                        const PATH_RENAME_SOURCE: u64 = 0;
                        const PATH_RENAME_TARGET: u64 = 0;
                        const PATH_FILESTAT_GET: u64 = 0;
                        const PATH_FILESTAT_SET_SIZE: u64 = 0;
                        const PATH_FILESTAT_SET_TIMES: u64 = 0;
                        const FD_FILESTAT_GET: u64 = 0;
                        const FD_FILESTAT_SET_SIZE: u64 = 0;
                        const FD_FILESTAT_SET_TIMES: u64 = 0;
                        const PATH_SYMLINK: u64 = 0;
                        const PATH_REMOVE_DIRECTORY: u64 = 0;
                        const PATH_UNLINK_FILE: u64 = 0;
                        const POLL_FD_READWRITE: u64 = 0;
                        const SOCK_SHUTDOWN: u64 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Rights {
                        #[allow(deprecated)]
                        const FD_DATASYNC: u64 = Self::FD_DATASYNC.bits;
                        #[allow(deprecated)]
                        const FD_READ: u64 = Self::FD_READ.bits;
                        #[allow(deprecated)]
                        const FD_SEEK: u64 = Self::FD_SEEK.bits;
                        #[allow(deprecated)]
                        const FD_FDSTAT_SET_FLAGS: u64 = Self::FD_FDSTAT_SET_FLAGS.bits;
                        #[allow(deprecated)]
                        const FD_SYNC: u64 = Self::FD_SYNC.bits;
                        #[allow(deprecated)]
                        const FD_TELL: u64 = Self::FD_TELL.bits;
                        #[allow(deprecated)]
                        const FD_WRITE: u64 = Self::FD_WRITE.bits;
                        #[allow(deprecated)]
                        const FD_ADVISE: u64 = Self::FD_ADVISE.bits;
                        #[allow(deprecated)]
                        const FD_ALLOCATE: u64 = Self::FD_ALLOCATE.bits;
                        #[allow(deprecated)]
                        const PATH_CREATE_DIRECTORY: u64 = Self::PATH_CREATE_DIRECTORY
                            .bits;
                        #[allow(deprecated)]
                        const PATH_CREATE_FILE: u64 = Self::PATH_CREATE_FILE.bits;
                        #[allow(deprecated)]
                        const PATH_LINK_SOURCE: u64 = Self::PATH_LINK_SOURCE.bits;
                        #[allow(deprecated)]
                        const PATH_LINK_TARGET: u64 = Self::PATH_LINK_TARGET.bits;
                        #[allow(deprecated)]
                        const PATH_OPEN: u64 = Self::PATH_OPEN.bits;
                        #[allow(deprecated)]
                        const FD_READDIR: u64 = Self::FD_READDIR.bits;
                        #[allow(deprecated)]
                        const PATH_READLINK: u64 = Self::PATH_READLINK.bits;
                        #[allow(deprecated)]
                        const PATH_RENAME_SOURCE: u64 = Self::PATH_RENAME_SOURCE.bits;
                        #[allow(deprecated)]
                        const PATH_RENAME_TARGET: u64 = Self::PATH_RENAME_TARGET.bits;
                        #[allow(deprecated)]
                        const PATH_FILESTAT_GET: u64 = Self::PATH_FILESTAT_GET.bits;
                        #[allow(deprecated)]
                        const PATH_FILESTAT_SET_SIZE: u64 = Self::PATH_FILESTAT_SET_SIZE
                            .bits;
                        #[allow(deprecated)]
                        const PATH_FILESTAT_SET_TIMES: u64 = Self::PATH_FILESTAT_SET_TIMES
                            .bits;
                        #[allow(deprecated)]
                        const FD_FILESTAT_GET: u64 = Self::FD_FILESTAT_GET.bits;
                        #[allow(deprecated)]
                        const FD_FILESTAT_SET_SIZE: u64 = Self::FD_FILESTAT_SET_SIZE
                            .bits;
                        #[allow(deprecated)]
                        const FD_FILESTAT_SET_TIMES: u64 = Self::FD_FILESTAT_SET_TIMES
                            .bits;
                        #[allow(deprecated)]
                        const PATH_SYMLINK: u64 = Self::PATH_SYMLINK.bits;
                        #[allow(deprecated)]
                        const PATH_REMOVE_DIRECTORY: u64 = Self::PATH_REMOVE_DIRECTORY
                            .bits;
                        #[allow(deprecated)]
                        const PATH_UNLINK_FILE: u64 = Self::PATH_UNLINK_FILE.bits;
                        #[allow(deprecated)]
                        const POLL_FD_READWRITE: u64 = Self::POLL_FD_READWRITE.bits;
                        #[allow(deprecated)]
                        const SOCK_SHUTDOWN: u64 = Self::SOCK_SHUTDOWN.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::FD_DATASYNC
                            | <Self as __BitFlags>::FD_READ
                            | <Self as __BitFlags>::FD_SEEK
                            | <Self as __BitFlags>::FD_FDSTAT_SET_FLAGS
                            | <Self as __BitFlags>::FD_SYNC
                            | <Self as __BitFlags>::FD_TELL
                            | <Self as __BitFlags>::FD_WRITE
                            | <Self as __BitFlags>::FD_ADVISE
                            | <Self as __BitFlags>::FD_ALLOCATE
                            | <Self as __BitFlags>::PATH_CREATE_DIRECTORY
                            | <Self as __BitFlags>::PATH_CREATE_FILE
                            | <Self as __BitFlags>::PATH_LINK_SOURCE
                            | <Self as __BitFlags>::PATH_LINK_TARGET
                            | <Self as __BitFlags>::PATH_OPEN
                            | <Self as __BitFlags>::FD_READDIR
                            | <Self as __BitFlags>::PATH_READLINK
                            | <Self as __BitFlags>::PATH_RENAME_SOURCE
                            | <Self as __BitFlags>::PATH_RENAME_TARGET
                            | <Self as __BitFlags>::PATH_FILESTAT_GET
                            | <Self as __BitFlags>::PATH_FILESTAT_SET_SIZE
                            | <Self as __BitFlags>::PATH_FILESTAT_SET_TIMES
                            | <Self as __BitFlags>::FD_FILESTAT_GET
                            | <Self as __BitFlags>::FD_FILESTAT_SET_SIZE
                            | <Self as __BitFlags>::FD_FILESTAT_SET_TIMES
                            | <Self as __BitFlags>::PATH_SYMLINK
                            | <Self as __BitFlags>::PATH_REMOVE_DIRECTORY
                            | <Self as __BitFlags>::PATH_UNLINK_FILE
                            | <Self as __BitFlags>::POLL_FD_READWRITE
                            | <Self as __BitFlags>::SOCK_SHUTDOWN,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u64 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u64,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u64) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u64) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Rights {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Rights) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Rights {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Rights {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Rights {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Rights {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Rights {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Rights {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Rights {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Rights {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Rights> for Rights {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Rights> for Rights {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Rights {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Rights")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u64> for Rights {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u64) -> Result<Self, wiggle::GuestError> {
                    if u64::from(!Rights::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Rights"))
                    } else {
                        Ok(Rights { bits: value })
                    }
                }
            }
            impl TryFrom<i64> for Rights {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i64) -> Result<Self, wiggle::GuestError> {
                    Rights::try_from(u64::try_from(value)?)
                }
            }
            impl From<Rights> for u64 {
                #[inline]
                fn from(e: Rights) -> u64 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Rights {
                #[inline]
                fn guest_size() -> u32 {
                    u64::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u64::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Rights>,
                ) -> Result<Rights, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u64::read(&location.cast())?;
                    let value = Rights::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Rights>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u64 = u64::from(val);
                    u64::write(&location.cast(), val)
                }
            }
            #[repr(transparent)]
            pub struct Fd(u32);
            #[automatically_derived]
            impl ::core::marker::Copy for Fd {}
            #[automatically_derived]
            impl ::core::clone::Clone for Fd {
                #[inline]
                fn clone(&self) -> Fd {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Fd {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Fd", &&self.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Fd {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Fd {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Fd {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Fd {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Fd {
                #[inline]
                fn eq(&self, other: &Fd) -> bool {
                    self.0 == other.0
                }
            }
            impl Fd {
                #[inline]
                pub unsafe fn inner(&self) -> u32 {
                    self.0
                }
            }
            impl From<Fd> for u32 {
                #[inline]
                fn from(e: Fd) -> u32 {
                    e.0
                }
            }
            impl From<Fd> for i32 {
                #[inline]
                fn from(e: Fd) -> i32 {
                    e.0 as i32
                }
            }
            impl From<u32> for Fd {
                #[inline]
                fn from(e: u32) -> Fd {
                    Fd(e)
                }
            }
            impl From<i32> for Fd {
                #[inline]
                fn from(e: i32) -> Fd {
                    Fd(e as u32)
                }
            }
            impl ::std::fmt::Display for Fd {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_fmt(format_args!("{0}({1})", "Fd", self.0))
                }
            }
            impl<'a> wiggle::GuestType<'a> for Fd {
                #[inline]
                fn guest_size() -> u32 {
                    4u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                #[inline]
                fn read(
                    location: &wiggle::GuestPtr<'a, Fd>,
                ) -> Result<Fd, wiggle::GuestError> {
                    Ok(Fd(u32::read(&location.cast())?))
                }
                #[inline]
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    u32::write(&location.cast(), val.0)
                }
            }
            pub struct Iovec<'a> {
                pub buf: wiggle::GuestPtr<'a, u8>,
                pub buf_len: Size,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for Iovec<'a> {
                #[inline]
                fn clone(&self) -> Iovec<'a> {
                    Iovec {
                        buf: ::core::clone::Clone::clone(&self.buf),
                        buf_len: ::core::clone::Clone::clone(&self.buf_len),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for Iovec<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Iovec",
                        "buf",
                        &self.buf,
                        "buf_len",
                        &&self.buf_len,
                    )
                }
            }
            impl<'a> wiggle::GuestType<'a> for Iovec<'a> {
                #[inline]
                fn guest_size() -> u32 {
                    8u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let buf = <wiggle::GuestPtr<
                        u8,
                    > as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let buf_len = <Size as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(4u32)?.cast(),
                    )?;
                    Ok(Iovec { buf, buf_len })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.buf,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(4u32)?.cast(),
                        val.buf_len,
                    )?;
                    Ok(())
                }
            }
            pub struct Ciovec<'a> {
                pub buf: wiggle::GuestPtr<'a, u8>,
                pub buf_len: Size,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for Ciovec<'a> {
                #[inline]
                fn clone(&self) -> Ciovec<'a> {
                    Ciovec {
                        buf: ::core::clone::Clone::clone(&self.buf),
                        buf_len: ::core::clone::Clone::clone(&self.buf_len),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for Ciovec<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Ciovec",
                        "buf",
                        &self.buf,
                        "buf_len",
                        &&self.buf_len,
                    )
                }
            }
            impl<'a> wiggle::GuestType<'a> for Ciovec<'a> {
                #[inline]
                fn guest_size() -> u32 {
                    8u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let buf = <wiggle::GuestPtr<
                        u8,
                    > as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let buf_len = <Size as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(4u32)?.cast(),
                    )?;
                    Ok(Ciovec { buf, buf_len })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.buf,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(4u32)?.cast(),
                        val.buf_len,
                    )?;
                    Ok(())
                }
            }
            pub type IovecArray<'a> = wiggle::GuestPtr<'a, [Iovec<'a>]>;
            pub type CiovecArray<'a> = wiggle::GuestPtr<'a, [Ciovec<'a>]>;
            pub type Filedelta = i64;
            pub enum Whence {
                Cur,
                End,
                Set,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Whence {
                #[inline]
                fn clone(&self) -> Whence {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Whence {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Whence::Cur => "Cur",
                            Whence::End => "End",
                            Whence::Set => "Set",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Whence {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Whence {
                #[inline]
                fn eq(&self, other: &Whence) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Whence {}
            impl TryFrom<u8> for Whence {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Whence, wiggle::GuestError> {
                    match value {
                        0 => Ok(Whence::Cur),
                        1 => Ok(Whence::End),
                        2 => Ok(Whence::Set),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Whence")),
                    }
                }
            }
            impl TryFrom<i32> for Whence {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Whence, wiggle::GuestError> {
                    Whence::try_from(u8::try_from(value)?)
                }
            }
            impl From<Whence> for u8 {
                #[inline]
                fn from(v: Whence) -> u8 {
                    match v {
                        Whence::Cur => 0,
                        Whence::End => 1,
                        Whence::Set => 2,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Whence {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Whence::Cur),
                        1 => Ok(Whence::End),
                        2 => Ok(Whence::Set),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Whence")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Whence::Cur => {
                            location.cast().write(0usize as u8)?;
                        }
                        Whence::End => {
                            location.cast().write(1usize as u8)?;
                        }
                        Whence::Set => {
                            location.cast().write(2usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub type Dircookie = u64;
            pub type Dirnamlen = u32;
            pub type Inode = u64;
            pub enum Filetype {
                Unknown,
                BlockDevice,
                CharacterDevice,
                Directory,
                RegularFile,
                SocketDgram,
                SocketStream,
                SymbolicLink,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Filetype {
                #[inline]
                fn clone(&self) -> Filetype {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Filetype {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Filetype::Unknown => "Unknown",
                            Filetype::BlockDevice => "BlockDevice",
                            Filetype::CharacterDevice => "CharacterDevice",
                            Filetype::Directory => "Directory",
                            Filetype::RegularFile => "RegularFile",
                            Filetype::SocketDgram => "SocketDgram",
                            Filetype::SocketStream => "SocketStream",
                            Filetype::SymbolicLink => "SymbolicLink",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Filetype {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Filetype {
                #[inline]
                fn eq(&self, other: &Filetype) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Filetype {}
            impl TryFrom<u8> for Filetype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Filetype, wiggle::GuestError> {
                    match value {
                        0 => Ok(Filetype::Unknown),
                        1 => Ok(Filetype::BlockDevice),
                        2 => Ok(Filetype::CharacterDevice),
                        3 => Ok(Filetype::Directory),
                        4 => Ok(Filetype::RegularFile),
                        5 => Ok(Filetype::SocketDgram),
                        6 => Ok(Filetype::SocketStream),
                        7 => Ok(Filetype::SymbolicLink),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Filetype")),
                    }
                }
            }
            impl TryFrom<i32> for Filetype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Filetype, wiggle::GuestError> {
                    Filetype::try_from(u8::try_from(value)?)
                }
            }
            impl From<Filetype> for u8 {
                #[inline]
                fn from(v: Filetype) -> u8 {
                    match v {
                        Filetype::Unknown => 0,
                        Filetype::BlockDevice => 1,
                        Filetype::CharacterDevice => 2,
                        Filetype::Directory => 3,
                        Filetype::RegularFile => 4,
                        Filetype::SocketDgram => 5,
                        Filetype::SocketStream => 6,
                        Filetype::SymbolicLink => 7,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Filetype {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Filetype::Unknown),
                        1 => Ok(Filetype::BlockDevice),
                        2 => Ok(Filetype::CharacterDevice),
                        3 => Ok(Filetype::Directory),
                        4 => Ok(Filetype::RegularFile),
                        5 => Ok(Filetype::SocketDgram),
                        6 => Ok(Filetype::SocketStream),
                        7 => Ok(Filetype::SymbolicLink),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Filetype")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Filetype::Unknown => {
                            location.cast().write(0usize as u8)?;
                        }
                        Filetype::BlockDevice => {
                            location.cast().write(1usize as u8)?;
                        }
                        Filetype::CharacterDevice => {
                            location.cast().write(2usize as u8)?;
                        }
                        Filetype::Directory => {
                            location.cast().write(3usize as u8)?;
                        }
                        Filetype::RegularFile => {
                            location.cast().write(4usize as u8)?;
                        }
                        Filetype::SocketDgram => {
                            location.cast().write(5usize as u8)?;
                        }
                        Filetype::SocketStream => {
                            location.cast().write(6usize as u8)?;
                        }
                        Filetype::SymbolicLink => {
                            location.cast().write(7usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Dirent {
                pub d_next: Dircookie,
                pub d_ino: Inode,
                pub d_namlen: Dirnamlen,
                pub d_type: Filetype,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Dirent {
                #[inline]
                fn clone(&self) -> Dirent {
                    Dirent {
                        d_next: ::core::clone::Clone::clone(&self.d_next),
                        d_ino: ::core::clone::Clone::clone(&self.d_ino),
                        d_namlen: ::core::clone::Clone::clone(&self.d_namlen),
                        d_type: ::core::clone::Clone::clone(&self.d_type),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Dirent {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Dirent",
                        "d_next",
                        &self.d_next,
                        "d_ino",
                        &self.d_ino,
                        "d_namlen",
                        &self.d_namlen,
                        "d_type",
                        &&self.d_type,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Dirent {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Dirent {
                #[inline]
                fn eq(&self, other: &Dirent) -> bool {
                    self.d_next == other.d_next && self.d_ino == other.d_ino
                        && self.d_namlen == other.d_namlen && self.d_type == other.d_type
                }
            }
            impl<'a> wiggle::GuestType<'a> for Dirent {
                #[inline]
                fn guest_size() -> u32 {
                    24u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let d_next = <Dircookie as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let d_ino = <Inode as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let d_namlen = <Dirnamlen as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    let d_type = <Filetype as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(20u32)?.cast(),
                    )?;
                    Ok(Dirent {
                        d_next,
                        d_ino,
                        d_namlen,
                        d_type,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.d_next,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.d_ino,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.d_namlen,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(20u32)?.cast(),
                        val.d_type,
                    )?;
                    Ok(())
                }
            }
            pub enum Advice {
                Normal,
                Sequential,
                Random,
                Willneed,
                Dontneed,
                Noreuse,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Advice {
                #[inline]
                fn clone(&self) -> Advice {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Advice {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Advice::Normal => "Normal",
                            Advice::Sequential => "Sequential",
                            Advice::Random => "Random",
                            Advice::Willneed => "Willneed",
                            Advice::Dontneed => "Dontneed",
                            Advice::Noreuse => "Noreuse",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Advice {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Advice {
                #[inline]
                fn eq(&self, other: &Advice) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Advice {}
            impl TryFrom<u8> for Advice {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Advice, wiggle::GuestError> {
                    match value {
                        0 => Ok(Advice::Normal),
                        1 => Ok(Advice::Sequential),
                        2 => Ok(Advice::Random),
                        3 => Ok(Advice::Willneed),
                        4 => Ok(Advice::Dontneed),
                        5 => Ok(Advice::Noreuse),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Advice")),
                    }
                }
            }
            impl TryFrom<i32> for Advice {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Advice, wiggle::GuestError> {
                    Advice::try_from(u8::try_from(value)?)
                }
            }
            impl From<Advice> for u8 {
                #[inline]
                fn from(v: Advice) -> u8 {
                    match v {
                        Advice::Normal => 0,
                        Advice::Sequential => 1,
                        Advice::Random => 2,
                        Advice::Willneed => 3,
                        Advice::Dontneed => 4,
                        Advice::Noreuse => 5,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Advice {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Advice::Normal),
                        1 => Ok(Advice::Sequential),
                        2 => Ok(Advice::Random),
                        3 => Ok(Advice::Willneed),
                        4 => Ok(Advice::Dontneed),
                        5 => Ok(Advice::Noreuse),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Advice")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Advice::Normal => {
                            location.cast().write(0usize as u8)?;
                        }
                        Advice::Sequential => {
                            location.cast().write(1usize as u8)?;
                        }
                        Advice::Random => {
                            location.cast().write(2usize as u8)?;
                        }
                        Advice::Willneed => {
                            location.cast().write(3usize as u8)?;
                        }
                        Advice::Dontneed => {
                            location.cast().write(4usize as u8)?;
                        }
                        Advice::Noreuse => {
                            location.cast().write(5usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Fdflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Fdflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Fdflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Fdflags {
                #[inline]
                fn eq(&self, other: &Fdflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Fdflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Fdflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Fdflags {
                #[inline]
                fn clone(&self) -> Fdflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Fdflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Fdflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Fdflags {
                #[inline]
                fn cmp(&self, other: &Fdflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Fdflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn APPEND(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn DSYNC(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn NONBLOCK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn RSYNC(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn SYNC(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Fdflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn APPEND(&self) -> bool {
                            if Self::APPEND.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::APPEND.bits == Self::APPEND.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn DSYNC(&self) -> bool {
                            if Self::DSYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::DSYNC.bits == Self::DSYNC.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn NONBLOCK(&self) -> bool {
                            if Self::NONBLOCK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::NONBLOCK.bits == Self::NONBLOCK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn RSYNC(&self) -> bool {
                            if Self::RSYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RSYNC.bits == Self::RSYNC.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn SYNC(&self) -> bool {
                            if Self::SYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::SYNC.bits == Self::SYNC.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::APPEND(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("APPEND")?;
                    }
                    if <Self as __BitFlags>::DSYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("DSYNC")?;
                    }
                    if <Self as __BitFlags>::NONBLOCK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("NONBLOCK")?;
                    }
                    if <Self as __BitFlags>::RSYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RSYNC")?;
                    }
                    if <Self as __BitFlags>::SYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SYNC")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Fdflags {
                pub const APPEND: Self = Self { bits: 1 };
                pub const DSYNC: Self = Self { bits: 2 };
                pub const NONBLOCK: Self = Self { bits: 4 };
                pub const RSYNC: Self = Self { bits: 8 };
                pub const SYNC: Self = Self { bits: 16 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const APPEND: u16 = 0;
                        const DSYNC: u16 = 0;
                        const NONBLOCK: u16 = 0;
                        const RSYNC: u16 = 0;
                        const SYNC: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Fdflags {
                        #[allow(deprecated)]
                        const APPEND: u16 = Self::APPEND.bits;
                        #[allow(deprecated)]
                        const DSYNC: u16 = Self::DSYNC.bits;
                        #[allow(deprecated)]
                        const NONBLOCK: u16 = Self::NONBLOCK.bits;
                        #[allow(deprecated)]
                        const RSYNC: u16 = Self::RSYNC.bits;
                        #[allow(deprecated)]
                        const SYNC: u16 = Self::SYNC.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::APPEND | <Self as __BitFlags>::DSYNC
                            | <Self as __BitFlags>::NONBLOCK
                            | <Self as __BitFlags>::RSYNC | <Self as __BitFlags>::SYNC,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Fdflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Fdflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Fdflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Fdflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Fdflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Fdflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Fdflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Fdflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Fdflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Fdflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Fdflags> for Fdflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Fdflags> for Fdflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Fdflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Fdflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Fdflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Fdflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Fdflags"))
                    } else {
                        Ok(Fdflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Fdflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Fdflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Fdflags> for u16 {
                #[inline]
                fn from(e: Fdflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Fdflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Fdflags>,
                ) -> Result<Fdflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Fdflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Fdflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct Fdstat {
                pub fs_filetype: Filetype,
                pub fs_flags: Fdflags,
                pub fs_rights_base: Rights,
                pub fs_rights_inheriting: Rights,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Fdstat {
                #[inline]
                fn clone(&self) -> Fdstat {
                    Fdstat {
                        fs_filetype: ::core::clone::Clone::clone(&self.fs_filetype),
                        fs_flags: ::core::clone::Clone::clone(&self.fs_flags),
                        fs_rights_base: ::core::clone::Clone::clone(
                            &self.fs_rights_base,
                        ),
                        fs_rights_inheriting: ::core::clone::Clone::clone(
                            &self.fs_rights_inheriting,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Fdstat {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Fdstat",
                        "fs_filetype",
                        &self.fs_filetype,
                        "fs_flags",
                        &self.fs_flags,
                        "fs_rights_base",
                        &self.fs_rights_base,
                        "fs_rights_inheriting",
                        &&self.fs_rights_inheriting,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Fdstat {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Fdstat {
                #[inline]
                fn eq(&self, other: &Fdstat) -> bool {
                    self.fs_filetype == other.fs_filetype
                        && self.fs_flags == other.fs_flags
                        && self.fs_rights_base == other.fs_rights_base
                        && self.fs_rights_inheriting == other.fs_rights_inheriting
                }
            }
            impl<'a> wiggle::GuestType<'a> for Fdstat {
                #[inline]
                fn guest_size() -> u32 {
                    24u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let fs_filetype = <Filetype as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let fs_flags = <Fdflags as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(2u32)?.cast(),
                    )?;
                    let fs_rights_base = <Rights as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let fs_rights_inheriting = <Rights as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    Ok(Fdstat {
                        fs_filetype,
                        fs_flags,
                        fs_rights_base,
                        fs_rights_inheriting,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.fs_filetype,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(2u32)?.cast(),
                        val.fs_flags,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.fs_rights_base,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.fs_rights_inheriting,
                    )?;
                    Ok(())
                }
            }
            pub type Device = u64;
            pub struct Fstflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Fstflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Fstflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Fstflags {
                #[inline]
                fn eq(&self, other: &Fstflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Fstflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Fstflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Fstflags {
                #[inline]
                fn clone(&self) -> Fstflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Fstflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Fstflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Fstflags {
                #[inline]
                fn cmp(&self, other: &Fstflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Fstflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn ATIM(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn ATIM_NOW(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn MTIM(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn MTIM_NOW(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Fstflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn ATIM(&self) -> bool {
                            if Self::ATIM.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::ATIM.bits == Self::ATIM.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn ATIM_NOW(&self) -> bool {
                            if Self::ATIM_NOW.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::ATIM_NOW.bits == Self::ATIM_NOW.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn MTIM(&self) -> bool {
                            if Self::MTIM.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::MTIM.bits == Self::MTIM.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn MTIM_NOW(&self) -> bool {
                            if Self::MTIM_NOW.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::MTIM_NOW.bits == Self::MTIM_NOW.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::ATIM(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("ATIM")?;
                    }
                    if <Self as __BitFlags>::ATIM_NOW(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("ATIM_NOW")?;
                    }
                    if <Self as __BitFlags>::MTIM(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("MTIM")?;
                    }
                    if <Self as __BitFlags>::MTIM_NOW(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("MTIM_NOW")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Fstflags {
                pub const ATIM: Self = Self { bits: 1 };
                pub const ATIM_NOW: Self = Self { bits: 2 };
                pub const MTIM: Self = Self { bits: 4 };
                pub const MTIM_NOW: Self = Self { bits: 8 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const ATIM: u16 = 0;
                        const ATIM_NOW: u16 = 0;
                        const MTIM: u16 = 0;
                        const MTIM_NOW: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Fstflags {
                        #[allow(deprecated)]
                        const ATIM: u16 = Self::ATIM.bits;
                        #[allow(deprecated)]
                        const ATIM_NOW: u16 = Self::ATIM_NOW.bits;
                        #[allow(deprecated)]
                        const MTIM: u16 = Self::MTIM.bits;
                        #[allow(deprecated)]
                        const MTIM_NOW: u16 = Self::MTIM_NOW.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::ATIM | <Self as __BitFlags>::ATIM_NOW
                            | <Self as __BitFlags>::MTIM | <Self as __BitFlags>::MTIM_NOW,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Fstflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Fstflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Fstflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Fstflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Fstflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Fstflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Fstflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Fstflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Fstflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Fstflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Fstflags> for Fstflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Fstflags> for Fstflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Fstflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Fstflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Fstflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Fstflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Fstflags"))
                    } else {
                        Ok(Fstflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Fstflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Fstflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Fstflags> for u16 {
                #[inline]
                fn from(e: Fstflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Fstflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Fstflags>,
                ) -> Result<Fstflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Fstflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Fstflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct Lookupflags {
                bits: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Lookupflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Lookupflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Lookupflags {
                #[inline]
                fn eq(&self, other: &Lookupflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Lookupflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Lookupflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Lookupflags {
                #[inline]
                fn clone(&self) -> Lookupflags {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Lookupflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Lookupflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Lookupflags {
                #[inline]
                fn cmp(&self, other: &Lookupflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Lookupflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn SYMLINK_FOLLOW(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Lookupflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn SYMLINK_FOLLOW(&self) -> bool {
                            if Self::SYMLINK_FOLLOW.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::SYMLINK_FOLLOW.bits
                                    == Self::SYMLINK_FOLLOW.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::SYMLINK_FOLLOW(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SYMLINK_FOLLOW")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Lookupflags {
                pub const SYMLINK_FOLLOW: Self = Self { bits: 1 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const SYMLINK_FOLLOW: u32 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Lookupflags {
                        #[allow(deprecated)]
                        const SYMLINK_FOLLOW: u32 = Self::SYMLINK_FOLLOW.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::SYMLINK_FOLLOW,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u32 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u32,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u32) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Lookupflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Lookupflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Lookupflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Lookupflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Lookupflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Lookupflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Lookupflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Lookupflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Lookupflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Lookupflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Lookupflags> for Lookupflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Lookupflags> for Lookupflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Lookupflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Lookupflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u32> for Lookupflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u32) -> Result<Self, wiggle::GuestError> {
                    if u32::from(!Lookupflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Lookupflags"))
                    } else {
                        Ok(Lookupflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Lookupflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Lookupflags::try_from(u32::try_from(value)?)
                }
            }
            impl From<Lookupflags> for u32 {
                #[inline]
                fn from(e: Lookupflags) -> u32 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Lookupflags {
                #[inline]
                fn guest_size() -> u32 {
                    u32::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u32::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Lookupflags>,
                ) -> Result<Lookupflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u32::read(&location.cast())?;
                    let value = Lookupflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Lookupflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u32 = u32::from(val);
                    u32::write(&location.cast(), val)
                }
            }
            pub struct Oflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Oflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Oflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Oflags {
                #[inline]
                fn eq(&self, other: &Oflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Oflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Oflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Oflags {
                #[inline]
                fn clone(&self) -> Oflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Oflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Oflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Oflags {
                #[inline]
                fn cmp(&self, other: &Oflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Oflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn CREAT(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn DIRECTORY(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn EXCL(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn TRUNC(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Oflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn CREAT(&self) -> bool {
                            if Self::CREAT.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::CREAT.bits == Self::CREAT.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn DIRECTORY(&self) -> bool {
                            if Self::DIRECTORY.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::DIRECTORY.bits == Self::DIRECTORY.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn EXCL(&self) -> bool {
                            if Self::EXCL.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::EXCL.bits == Self::EXCL.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn TRUNC(&self) -> bool {
                            if Self::TRUNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::TRUNC.bits == Self::TRUNC.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::CREAT(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("CREAT")?;
                    }
                    if <Self as __BitFlags>::DIRECTORY(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("DIRECTORY")?;
                    }
                    if <Self as __BitFlags>::EXCL(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("EXCL")?;
                    }
                    if <Self as __BitFlags>::TRUNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("TRUNC")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Oflags {
                pub const CREAT: Self = Self { bits: 1 };
                pub const DIRECTORY: Self = Self { bits: 2 };
                pub const EXCL: Self = Self { bits: 4 };
                pub const TRUNC: Self = Self { bits: 8 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const CREAT: u16 = 0;
                        const DIRECTORY: u16 = 0;
                        const EXCL: u16 = 0;
                        const TRUNC: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Oflags {
                        #[allow(deprecated)]
                        const CREAT: u16 = Self::CREAT.bits;
                        #[allow(deprecated)]
                        const DIRECTORY: u16 = Self::DIRECTORY.bits;
                        #[allow(deprecated)]
                        const EXCL: u16 = Self::EXCL.bits;
                        #[allow(deprecated)]
                        const TRUNC: u16 = Self::TRUNC.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::CREAT
                            | <Self as __BitFlags>::DIRECTORY
                            | <Self as __BitFlags>::EXCL | <Self as __BitFlags>::TRUNC,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Oflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Oflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Oflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Oflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Oflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Oflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Oflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Oflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Oflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Oflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Oflags> for Oflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Oflags> for Oflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Oflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Oflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Oflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Oflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Oflags"))
                    } else {
                        Ok(Oflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Oflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Oflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Oflags> for u16 {
                #[inline]
                fn from(e: Oflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Oflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Oflags>,
                ) -> Result<Oflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Oflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Oflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub type Linkcount = u32;
            pub struct Filestat {
                pub dev: Device,
                pub ino: Inode,
                pub filetype: Filetype,
                pub nlink: Linkcount,
                pub size: Filesize,
                pub atim: Timestamp,
                pub mtim: Timestamp,
                pub ctim: Timestamp,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Filestat {
                #[inline]
                fn clone(&self) -> Filestat {
                    Filestat {
                        dev: ::core::clone::Clone::clone(&self.dev),
                        ino: ::core::clone::Clone::clone(&self.ino),
                        filetype: ::core::clone::Clone::clone(&self.filetype),
                        nlink: ::core::clone::Clone::clone(&self.nlink),
                        size: ::core::clone::Clone::clone(&self.size),
                        atim: ::core::clone::Clone::clone(&self.atim),
                        mtim: ::core::clone::Clone::clone(&self.mtim),
                        ctim: ::core::clone::Clone::clone(&self.ctim),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Filestat {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "dev",
                        "ino",
                        "filetype",
                        "nlink",
                        "size",
                        "atim",
                        "mtim",
                        "ctim",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dev,
                        &self.ino,
                        &self.filetype,
                        &self.nlink,
                        &self.size,
                        &self.atim,
                        &self.mtim,
                        &&self.ctim,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Filestat",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Filestat {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Filestat {
                #[inline]
                fn eq(&self, other: &Filestat) -> bool {
                    self.dev == other.dev && self.ino == other.ino
                        && self.filetype == other.filetype && self.nlink == other.nlink
                        && self.size == other.size && self.atim == other.atim
                        && self.mtim == other.mtim && self.ctim == other.ctim
                }
            }
            impl<'a> wiggle::GuestType<'a> for Filestat {
                #[inline]
                fn guest_size() -> u32 {
                    56u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let dev = <Device as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let ino = <Inode as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let filetype = <Filetype as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    let nlink = <Linkcount as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(20u32)?.cast(),
                    )?;
                    let size = <Filesize as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(24u32)?.cast(),
                    )?;
                    let atim = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(32u32)?.cast(),
                    )?;
                    let mtim = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(40u32)?.cast(),
                    )?;
                    let ctim = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(48u32)?.cast(),
                    )?;
                    Ok(Filestat {
                        dev,
                        ino,
                        filetype,
                        nlink,
                        size,
                        atim,
                        mtim,
                        ctim,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.dev,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.ino,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.filetype,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(20u32)?.cast(),
                        val.nlink,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(24u32)?.cast(),
                        val.size,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(32u32)?.cast(),
                        val.atim,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(40u32)?.cast(),
                        val.mtim,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(48u32)?.cast(),
                        val.ctim,
                    )?;
                    Ok(())
                }
            }
            pub type Userdata = u64;
            pub enum Eventtype {
                Clock,
                FdRead,
                FdWrite,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Eventtype {
                #[inline]
                fn clone(&self) -> Eventtype {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Eventtype {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Eventtype::Clock => "Clock",
                            Eventtype::FdRead => "FdRead",
                            Eventtype::FdWrite => "FdWrite",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Eventtype {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Eventtype {
                #[inline]
                fn eq(&self, other: &Eventtype) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Eventtype {}
            impl TryFrom<u8> for Eventtype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Eventtype, wiggle::GuestError> {
                    match value {
                        0 => Ok(Eventtype::Clock),
                        1 => Ok(Eventtype::FdRead),
                        2 => Ok(Eventtype::FdWrite),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Eventtype")),
                    }
                }
            }
            impl TryFrom<i32> for Eventtype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Eventtype, wiggle::GuestError> {
                    Eventtype::try_from(u8::try_from(value)?)
                }
            }
            impl From<Eventtype> for u8 {
                #[inline]
                fn from(v: Eventtype) -> u8 {
                    match v {
                        Eventtype::Clock => 0,
                        Eventtype::FdRead => 1,
                        Eventtype::FdWrite => 2,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Eventtype {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Eventtype::Clock),
                        1 => Ok(Eventtype::FdRead),
                        2 => Ok(Eventtype::FdWrite),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Eventtype")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Eventtype::Clock => {
                            location.cast().write(0usize as u8)?;
                        }
                        Eventtype::FdRead => {
                            location.cast().write(1usize as u8)?;
                        }
                        Eventtype::FdWrite => {
                            location.cast().write(2usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Eventrwflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Eventrwflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Eventrwflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Eventrwflags {
                #[inline]
                fn eq(&self, other: &Eventrwflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Eventrwflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Eventrwflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Eventrwflags {
                #[inline]
                fn clone(&self) -> Eventrwflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Eventrwflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Eventrwflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Eventrwflags {
                #[inline]
                fn cmp(&self, other: &Eventrwflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Eventrwflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn FD_READWRITE_HANGUP(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Eventrwflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_READWRITE_HANGUP(&self) -> bool {
                            if Self::FD_READWRITE_HANGUP.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_READWRITE_HANGUP.bits
                                    == Self::FD_READWRITE_HANGUP.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::FD_READWRITE_HANGUP(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_READWRITE_HANGUP")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Eventrwflags {
                pub const FD_READWRITE_HANGUP: Self = Self { bits: 1 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const FD_READWRITE_HANGUP: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Eventrwflags {
                        #[allow(deprecated)]
                        const FD_READWRITE_HANGUP: u16 = Self::FD_READWRITE_HANGUP.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::FD_READWRITE_HANGUP,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Eventrwflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Eventrwflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Eventrwflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Eventrwflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Eventrwflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Eventrwflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Eventrwflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Eventrwflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Eventrwflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Eventrwflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Eventrwflags> for Eventrwflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Eventrwflags> for Eventrwflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Eventrwflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Eventrwflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Eventrwflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Eventrwflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Eventrwflags"))
                    } else {
                        Ok(Eventrwflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Eventrwflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Eventrwflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Eventrwflags> for u16 {
                #[inline]
                fn from(e: Eventrwflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Eventrwflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Eventrwflags>,
                ) -> Result<Eventrwflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Eventrwflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Eventrwflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct EventFdReadwrite {
                pub nbytes: Filesize,
                pub flags: Eventrwflags,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for EventFdReadwrite {
                #[inline]
                fn clone(&self) -> EventFdReadwrite {
                    EventFdReadwrite {
                        nbytes: ::core::clone::Clone::clone(&self.nbytes),
                        flags: ::core::clone::Clone::clone(&self.flags),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for EventFdReadwrite {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "EventFdReadwrite",
                        "nbytes",
                        &self.nbytes,
                        "flags",
                        &&self.flags,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for EventFdReadwrite {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for EventFdReadwrite {
                #[inline]
                fn eq(&self, other: &EventFdReadwrite) -> bool {
                    self.nbytes == other.nbytes && self.flags == other.flags
                }
            }
            impl<'a> wiggle::GuestType<'a> for EventFdReadwrite {
                #[inline]
                fn guest_size() -> u32 {
                    16u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let nbytes = <Filesize as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let flags = <Eventrwflags as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    Ok(EventFdReadwrite { nbytes, flags })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.nbytes,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.flags,
                    )?;
                    Ok(())
                }
            }
            pub struct Event {
                pub userdata: Userdata,
                pub error: Errno,
                pub type_: Eventtype,
                pub fd_readwrite: EventFdReadwrite,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Event {
                #[inline]
                fn clone(&self) -> Event {
                    Event {
                        userdata: ::core::clone::Clone::clone(&self.userdata),
                        error: ::core::clone::Clone::clone(&self.error),
                        type_: ::core::clone::Clone::clone(&self.type_),
                        fd_readwrite: ::core::clone::Clone::clone(&self.fd_readwrite),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Event {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Event",
                        "userdata",
                        &self.userdata,
                        "error",
                        &self.error,
                        "type_",
                        &self.type_,
                        "fd_readwrite",
                        &&self.fd_readwrite,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Event {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Event {
                #[inline]
                fn eq(&self, other: &Event) -> bool {
                    self.userdata == other.userdata && self.error == other.error
                        && self.type_ == other.type_
                        && self.fd_readwrite == other.fd_readwrite
                }
            }
            impl<'a> wiggle::GuestType<'a> for Event {
                #[inline]
                fn guest_size() -> u32 {
                    32u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let userdata = <Userdata as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let error = <Errno as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let type_ = <Eventtype as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(10u32)?.cast(),
                    )?;
                    let fd_readwrite = <EventFdReadwrite as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    Ok(Event {
                        userdata,
                        error,
                        type_,
                        fd_readwrite,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.userdata,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.error,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(10u32)?.cast(),
                        val.type_,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.fd_readwrite,
                    )?;
                    Ok(())
                }
            }
            pub struct Subclockflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Subclockflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Subclockflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Subclockflags {
                #[inline]
                fn eq(&self, other: &Subclockflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Subclockflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Subclockflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Subclockflags {
                #[inline]
                fn clone(&self) -> Subclockflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Subclockflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Subclockflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Subclockflags {
                #[inline]
                fn cmp(&self, other: &Subclockflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Subclockflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn SUBSCRIPTION_CLOCK_ABSTIME(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Subclockflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn SUBSCRIPTION_CLOCK_ABSTIME(&self) -> bool {
                            if Self::SUBSCRIPTION_CLOCK_ABSTIME.bits == 0
                                && self.bits != 0
                            {
                                false
                            } else {
                                self.bits & Self::SUBSCRIPTION_CLOCK_ABSTIME.bits
                                    == Self::SUBSCRIPTION_CLOCK_ABSTIME.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::SUBSCRIPTION_CLOCK_ABSTIME(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SUBSCRIPTION_CLOCK_ABSTIME")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Subclockflags {
                pub const SUBSCRIPTION_CLOCK_ABSTIME: Self = Self { bits: 1 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const SUBSCRIPTION_CLOCK_ABSTIME: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Subclockflags {
                        #[allow(deprecated)]
                        const SUBSCRIPTION_CLOCK_ABSTIME: u16 = Self::SUBSCRIPTION_CLOCK_ABSTIME
                            .bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::SUBSCRIPTION_CLOCK_ABSTIME,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Subclockflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Subclockflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Subclockflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Subclockflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Subclockflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Subclockflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Subclockflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Subclockflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Subclockflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Subclockflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Subclockflags> for Subclockflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Subclockflags> for Subclockflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Subclockflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Subclockflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Subclockflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Subclockflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Subclockflags"))
                    } else {
                        Ok(Subclockflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Subclockflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Subclockflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Subclockflags> for u16 {
                #[inline]
                fn from(e: Subclockflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Subclockflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Subclockflags>,
                ) -> Result<Subclockflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Subclockflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Subclockflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct SubscriptionClock {
                pub identifier: Userdata,
                pub id: Clockid,
                pub timeout: Timestamp,
                pub precision: Timestamp,
                pub flags: Subclockflags,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SubscriptionClock {
                #[inline]
                fn clone(&self) -> SubscriptionClock {
                    SubscriptionClock {
                        identifier: ::core::clone::Clone::clone(&self.identifier),
                        id: ::core::clone::Clone::clone(&self.id),
                        timeout: ::core::clone::Clone::clone(&self.timeout),
                        precision: ::core::clone::Clone::clone(&self.precision),
                        flags: ::core::clone::Clone::clone(&self.flags),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubscriptionClock {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field5_finish(
                        f,
                        "SubscriptionClock",
                        "identifier",
                        &self.identifier,
                        "id",
                        &self.id,
                        "timeout",
                        &self.timeout,
                        "precision",
                        &self.precision,
                        "flags",
                        &&self.flags,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SubscriptionClock {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SubscriptionClock {
                #[inline]
                fn eq(&self, other: &SubscriptionClock) -> bool {
                    self.identifier == other.identifier && self.id == other.id
                        && self.timeout == other.timeout
                        && self.precision == other.precision && self.flags == other.flags
                }
            }
            impl<'a> wiggle::GuestType<'a> for SubscriptionClock {
                #[inline]
                fn guest_size() -> u32 {
                    40u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let identifier = <Userdata as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let id = <Clockid as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let timeout = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    let precision = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(24u32)?.cast(),
                    )?;
                    let flags = <Subclockflags as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(32u32)?.cast(),
                    )?;
                    Ok(SubscriptionClock {
                        identifier,
                        id,
                        timeout,
                        precision,
                        flags,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.identifier,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.id,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.timeout,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(24u32)?.cast(),
                        val.precision,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(32u32)?.cast(),
                        val.flags,
                    )?;
                    Ok(())
                }
            }
            pub struct SubscriptionFdReadwrite {
                pub file_descriptor: Fd,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SubscriptionFdReadwrite {
                #[inline]
                fn clone(&self) -> SubscriptionFdReadwrite {
                    SubscriptionFdReadwrite {
                        file_descriptor: ::core::clone::Clone::clone(
                            &self.file_descriptor,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubscriptionFdReadwrite {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SubscriptionFdReadwrite",
                        "file_descriptor",
                        &&self.file_descriptor,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SubscriptionFdReadwrite {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SubscriptionFdReadwrite {
                #[inline]
                fn eq(&self, other: &SubscriptionFdReadwrite) -> bool {
                    self.file_descriptor == other.file_descriptor
                }
            }
            impl<'a> wiggle::GuestType<'a> for SubscriptionFdReadwrite {
                #[inline]
                fn guest_size() -> u32 {
                    4u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let file_descriptor = <Fd as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    Ok(SubscriptionFdReadwrite {
                        file_descriptor,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.file_descriptor,
                    )?;
                    Ok(())
                }
            }
            pub enum SubscriptionU {
                Clock(SubscriptionClock),
                FdRead(SubscriptionFdReadwrite),
                FdWrite(SubscriptionFdReadwrite),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SubscriptionU {
                #[inline]
                fn clone(&self) -> SubscriptionU {
                    match self {
                        SubscriptionU::Clock(__self_0) => {
                            SubscriptionU::Clock(::core::clone::Clone::clone(__self_0))
                        }
                        SubscriptionU::FdRead(__self_0) => {
                            SubscriptionU::FdRead(::core::clone::Clone::clone(__self_0))
                        }
                        SubscriptionU::FdWrite(__self_0) => {
                            SubscriptionU::FdWrite(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubscriptionU {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        SubscriptionU::Clock(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Clock",
                                &__self_0,
                            )
                        }
                        SubscriptionU::FdRead(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FdRead",
                                &__self_0,
                            )
                        }
                        SubscriptionU::FdWrite(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FdWrite",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SubscriptionU {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SubscriptionU {
                #[inline]
                fn eq(&self, other: &SubscriptionU) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                SubscriptionU::Clock(__self_0),
                                SubscriptionU::Clock(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                SubscriptionU::FdRead(__self_0),
                                SubscriptionU::FdRead(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                SubscriptionU::FdWrite(__self_0),
                                SubscriptionU::FdWrite(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            impl<'a> wiggle::GuestType<'a> for SubscriptionU {
                #[inline]
                fn guest_size() -> u32 {
                    48u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => {
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            let variant_val = <SubscriptionClock as wiggle::GuestType>::read(
                                &variant_ptr.cast(),
                            )?;
                            Ok(SubscriptionU::Clock(variant_val))
                        }
                        1 => {
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            let variant_val = <SubscriptionFdReadwrite as wiggle::GuestType>::read(
                                &variant_ptr.cast(),
                            )?;
                            Ok(SubscriptionU::FdRead(variant_val))
                        }
                        2 => {
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            let variant_val = <SubscriptionFdReadwrite as wiggle::GuestType>::read(
                                &variant_ptr.cast(),
                            )?;
                            Ok(SubscriptionU::FdWrite(variant_val))
                        }
                        _ => Err(wiggle::GuestError::InvalidEnumValue("SubscriptionU")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        SubscriptionU::Clock(contents) => {
                            location.cast().write(0usize as u8)?;
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            <SubscriptionClock as wiggle::GuestType>::write(
                                &variant_ptr.cast(),
                                contents,
                            )?;
                        }
                        SubscriptionU::FdRead(contents) => {
                            location.cast().write(1usize as u8)?;
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            <SubscriptionFdReadwrite as wiggle::GuestType>::write(
                                &variant_ptr.cast(),
                                contents,
                            )?;
                        }
                        SubscriptionU::FdWrite(contents) => {
                            location.cast().write(2usize as u8)?;
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            <SubscriptionFdReadwrite as wiggle::GuestType>::write(
                                &variant_ptr.cast(),
                                contents,
                            )?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Subscription {
                pub userdata: Userdata,
                pub u: SubscriptionU,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Subscription {
                #[inline]
                fn clone(&self) -> Subscription {
                    Subscription {
                        userdata: ::core::clone::Clone::clone(&self.userdata),
                        u: ::core::clone::Clone::clone(&self.u),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Subscription {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Subscription",
                        "userdata",
                        &self.userdata,
                        "u",
                        &&self.u,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Subscription {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Subscription {
                #[inline]
                fn eq(&self, other: &Subscription) -> bool {
                    self.userdata == other.userdata && self.u == other.u
                }
            }
            impl<'a> wiggle::GuestType<'a> for Subscription {
                #[inline]
                fn guest_size() -> u32 {
                    56u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let userdata = <Userdata as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let u = <SubscriptionU as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    Ok(Subscription { userdata, u })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.userdata,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.u,
                    )?;
                    Ok(())
                }
            }
            pub type Exitcode = u32;
            pub enum Signal {
                None,
                Hup,
                Int,
                Quit,
                Ill,
                Trap,
                Abrt,
                Bus,
                Fpe,
                Kill,
                Usr1,
                Segv,
                Usr2,
                Pipe,
                Alrm,
                Term,
                Chld,
                Cont,
                Stop,
                Tstp,
                Ttin,
                Ttou,
                Urg,
                Xcpu,
                Xfsz,
                Vtalrm,
                Prof,
                Winch,
                Poll,
                Pwr,
                Sys,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Signal {
                #[inline]
                fn clone(&self) -> Signal {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Signal {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Signal::None => "None",
                            Signal::Hup => "Hup",
                            Signal::Int => "Int",
                            Signal::Quit => "Quit",
                            Signal::Ill => "Ill",
                            Signal::Trap => "Trap",
                            Signal::Abrt => "Abrt",
                            Signal::Bus => "Bus",
                            Signal::Fpe => "Fpe",
                            Signal::Kill => "Kill",
                            Signal::Usr1 => "Usr1",
                            Signal::Segv => "Segv",
                            Signal::Usr2 => "Usr2",
                            Signal::Pipe => "Pipe",
                            Signal::Alrm => "Alrm",
                            Signal::Term => "Term",
                            Signal::Chld => "Chld",
                            Signal::Cont => "Cont",
                            Signal::Stop => "Stop",
                            Signal::Tstp => "Tstp",
                            Signal::Ttin => "Ttin",
                            Signal::Ttou => "Ttou",
                            Signal::Urg => "Urg",
                            Signal::Xcpu => "Xcpu",
                            Signal::Xfsz => "Xfsz",
                            Signal::Vtalrm => "Vtalrm",
                            Signal::Prof => "Prof",
                            Signal::Winch => "Winch",
                            Signal::Poll => "Poll",
                            Signal::Pwr => "Pwr",
                            Signal::Sys => "Sys",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Signal {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Signal {
                #[inline]
                fn eq(&self, other: &Signal) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Signal {}
            impl TryFrom<u8> for Signal {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Signal, wiggle::GuestError> {
                    match value {
                        0 => Ok(Signal::None),
                        1 => Ok(Signal::Hup),
                        2 => Ok(Signal::Int),
                        3 => Ok(Signal::Quit),
                        4 => Ok(Signal::Ill),
                        5 => Ok(Signal::Trap),
                        6 => Ok(Signal::Abrt),
                        7 => Ok(Signal::Bus),
                        8 => Ok(Signal::Fpe),
                        9 => Ok(Signal::Kill),
                        10 => Ok(Signal::Usr1),
                        11 => Ok(Signal::Segv),
                        12 => Ok(Signal::Usr2),
                        13 => Ok(Signal::Pipe),
                        14 => Ok(Signal::Alrm),
                        15 => Ok(Signal::Term),
                        16 => Ok(Signal::Chld),
                        17 => Ok(Signal::Cont),
                        18 => Ok(Signal::Stop),
                        19 => Ok(Signal::Tstp),
                        20 => Ok(Signal::Ttin),
                        21 => Ok(Signal::Ttou),
                        22 => Ok(Signal::Urg),
                        23 => Ok(Signal::Xcpu),
                        24 => Ok(Signal::Xfsz),
                        25 => Ok(Signal::Vtalrm),
                        26 => Ok(Signal::Prof),
                        27 => Ok(Signal::Winch),
                        28 => Ok(Signal::Poll),
                        29 => Ok(Signal::Pwr),
                        30 => Ok(Signal::Sys),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Signal")),
                    }
                }
            }
            impl TryFrom<i32> for Signal {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Signal, wiggle::GuestError> {
                    Signal::try_from(u8::try_from(value)?)
                }
            }
            impl From<Signal> for u8 {
                #[inline]
                fn from(v: Signal) -> u8 {
                    match v {
                        Signal::None => 0,
                        Signal::Hup => 1,
                        Signal::Int => 2,
                        Signal::Quit => 3,
                        Signal::Ill => 4,
                        Signal::Trap => 5,
                        Signal::Abrt => 6,
                        Signal::Bus => 7,
                        Signal::Fpe => 8,
                        Signal::Kill => 9,
                        Signal::Usr1 => 10,
                        Signal::Segv => 11,
                        Signal::Usr2 => 12,
                        Signal::Pipe => 13,
                        Signal::Alrm => 14,
                        Signal::Term => 15,
                        Signal::Chld => 16,
                        Signal::Cont => 17,
                        Signal::Stop => 18,
                        Signal::Tstp => 19,
                        Signal::Ttin => 20,
                        Signal::Ttou => 21,
                        Signal::Urg => 22,
                        Signal::Xcpu => 23,
                        Signal::Xfsz => 24,
                        Signal::Vtalrm => 25,
                        Signal::Prof => 26,
                        Signal::Winch => 27,
                        Signal::Poll => 28,
                        Signal::Pwr => 29,
                        Signal::Sys => 30,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Signal {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Signal::None),
                        1 => Ok(Signal::Hup),
                        2 => Ok(Signal::Int),
                        3 => Ok(Signal::Quit),
                        4 => Ok(Signal::Ill),
                        5 => Ok(Signal::Trap),
                        6 => Ok(Signal::Abrt),
                        7 => Ok(Signal::Bus),
                        8 => Ok(Signal::Fpe),
                        9 => Ok(Signal::Kill),
                        10 => Ok(Signal::Usr1),
                        11 => Ok(Signal::Segv),
                        12 => Ok(Signal::Usr2),
                        13 => Ok(Signal::Pipe),
                        14 => Ok(Signal::Alrm),
                        15 => Ok(Signal::Term),
                        16 => Ok(Signal::Chld),
                        17 => Ok(Signal::Cont),
                        18 => Ok(Signal::Stop),
                        19 => Ok(Signal::Tstp),
                        20 => Ok(Signal::Ttin),
                        21 => Ok(Signal::Ttou),
                        22 => Ok(Signal::Urg),
                        23 => Ok(Signal::Xcpu),
                        24 => Ok(Signal::Xfsz),
                        25 => Ok(Signal::Vtalrm),
                        26 => Ok(Signal::Prof),
                        27 => Ok(Signal::Winch),
                        28 => Ok(Signal::Poll),
                        29 => Ok(Signal::Pwr),
                        30 => Ok(Signal::Sys),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Signal")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Signal::None => {
                            location.cast().write(0usize as u8)?;
                        }
                        Signal::Hup => {
                            location.cast().write(1usize as u8)?;
                        }
                        Signal::Int => {
                            location.cast().write(2usize as u8)?;
                        }
                        Signal::Quit => {
                            location.cast().write(3usize as u8)?;
                        }
                        Signal::Ill => {
                            location.cast().write(4usize as u8)?;
                        }
                        Signal::Trap => {
                            location.cast().write(5usize as u8)?;
                        }
                        Signal::Abrt => {
                            location.cast().write(6usize as u8)?;
                        }
                        Signal::Bus => {
                            location.cast().write(7usize as u8)?;
                        }
                        Signal::Fpe => {
                            location.cast().write(8usize as u8)?;
                        }
                        Signal::Kill => {
                            location.cast().write(9usize as u8)?;
                        }
                        Signal::Usr1 => {
                            location.cast().write(10usize as u8)?;
                        }
                        Signal::Segv => {
                            location.cast().write(11usize as u8)?;
                        }
                        Signal::Usr2 => {
                            location.cast().write(12usize as u8)?;
                        }
                        Signal::Pipe => {
                            location.cast().write(13usize as u8)?;
                        }
                        Signal::Alrm => {
                            location.cast().write(14usize as u8)?;
                        }
                        Signal::Term => {
                            location.cast().write(15usize as u8)?;
                        }
                        Signal::Chld => {
                            location.cast().write(16usize as u8)?;
                        }
                        Signal::Cont => {
                            location.cast().write(17usize as u8)?;
                        }
                        Signal::Stop => {
                            location.cast().write(18usize as u8)?;
                        }
                        Signal::Tstp => {
                            location.cast().write(19usize as u8)?;
                        }
                        Signal::Ttin => {
                            location.cast().write(20usize as u8)?;
                        }
                        Signal::Ttou => {
                            location.cast().write(21usize as u8)?;
                        }
                        Signal::Urg => {
                            location.cast().write(22usize as u8)?;
                        }
                        Signal::Xcpu => {
                            location.cast().write(23usize as u8)?;
                        }
                        Signal::Xfsz => {
                            location.cast().write(24usize as u8)?;
                        }
                        Signal::Vtalrm => {
                            location.cast().write(25usize as u8)?;
                        }
                        Signal::Prof => {
                            location.cast().write(26usize as u8)?;
                        }
                        Signal::Winch => {
                            location.cast().write(27usize as u8)?;
                        }
                        Signal::Poll => {
                            location.cast().write(28usize as u8)?;
                        }
                        Signal::Pwr => {
                            location.cast().write(29usize as u8)?;
                        }
                        Signal::Sys => {
                            location.cast().write(30usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Riflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Riflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Riflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Riflags {
                #[inline]
                fn eq(&self, other: &Riflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Riflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Riflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Riflags {
                #[inline]
                fn clone(&self) -> Riflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Riflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Riflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Riflags {
                #[inline]
                fn cmp(&self, other: &Riflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Riflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn RECV_PEEK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn RECV_WAITALL(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Riflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn RECV_PEEK(&self) -> bool {
                            if Self::RECV_PEEK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RECV_PEEK.bits == Self::RECV_PEEK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn RECV_WAITALL(&self) -> bool {
                            if Self::RECV_WAITALL.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RECV_WAITALL.bits
                                    == Self::RECV_WAITALL.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::RECV_PEEK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RECV_PEEK")?;
                    }
                    if <Self as __BitFlags>::RECV_WAITALL(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RECV_WAITALL")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Riflags {
                pub const RECV_PEEK: Self = Self { bits: 1 };
                pub const RECV_WAITALL: Self = Self { bits: 2 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const RECV_PEEK: u16 = 0;
                        const RECV_WAITALL: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Riflags {
                        #[allow(deprecated)]
                        const RECV_PEEK: u16 = Self::RECV_PEEK.bits;
                        #[allow(deprecated)]
                        const RECV_WAITALL: u16 = Self::RECV_WAITALL.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::RECV_PEEK
                            | <Self as __BitFlags>::RECV_WAITALL,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Riflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Riflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Riflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Riflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Riflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Riflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Riflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Riflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Riflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Riflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Riflags> for Riflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Riflags> for Riflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Riflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Riflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Riflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Riflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Riflags"))
                    } else {
                        Ok(Riflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Riflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Riflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Riflags> for u16 {
                #[inline]
                fn from(e: Riflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Riflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Riflags>,
                ) -> Result<Riflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Riflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Riflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct Roflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Roflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Roflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Roflags {
                #[inline]
                fn eq(&self, other: &Roflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Roflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Roflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Roflags {
                #[inline]
                fn clone(&self) -> Roflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Roflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Roflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Roflags {
                #[inline]
                fn cmp(&self, other: &Roflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Roflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn RECV_DATA_TRUNCATED(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Roflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn RECV_DATA_TRUNCATED(&self) -> bool {
                            if Self::RECV_DATA_TRUNCATED.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RECV_DATA_TRUNCATED.bits
                                    == Self::RECV_DATA_TRUNCATED.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::RECV_DATA_TRUNCATED(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RECV_DATA_TRUNCATED")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Roflags {
                pub const RECV_DATA_TRUNCATED: Self = Self { bits: 1 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const RECV_DATA_TRUNCATED: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Roflags {
                        #[allow(deprecated)]
                        const RECV_DATA_TRUNCATED: u16 = Self::RECV_DATA_TRUNCATED.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::RECV_DATA_TRUNCATED,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Roflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Roflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Roflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Roflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Roflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Roflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Roflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Roflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Roflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Roflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Roflags> for Roflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Roflags> for Roflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Roflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Roflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Roflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Roflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Roflags"))
                    } else {
                        Ok(Roflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Roflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Roflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Roflags> for u16 {
                #[inline]
                fn from(e: Roflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Roflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Roflags>,
                ) -> Result<Roflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Roflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Roflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub type Siflags = u16;
            pub struct Sdflags {
                bits: u8,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Sdflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Sdflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Sdflags {
                #[inline]
                fn eq(&self, other: &Sdflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Sdflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Sdflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u8>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Sdflags {
                #[inline]
                fn clone(&self) -> Sdflags {
                    let _: ::core::clone::AssertParamIsClone<u8>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Sdflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Sdflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Sdflags {
                #[inline]
                fn cmp(&self, other: &Sdflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Sdflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn RD(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn WR(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Sdflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn RD(&self) -> bool {
                            if Self::RD.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RD.bits == Self::RD.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn WR(&self) -> bool {
                            if Self::WR.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::WR.bits == Self::WR.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::RD(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RD")?;
                    }
                    if <Self as __BitFlags>::WR(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("WR")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Sdflags {
                pub const RD: Self = Self { bits: 1 };
                pub const WR: Self = Self { bits: 2 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const RD: u8 = 0;
                        const WR: u8 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Sdflags {
                        #[allow(deprecated)]
                        const RD: u8 = Self::RD.bits;
                        #[allow(deprecated)]
                        const WR: u8 = Self::WR.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::RD | <Self as __BitFlags>::WR,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u8 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u8,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u8) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u8) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Sdflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Sdflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Sdflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Sdflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Sdflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Sdflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Sdflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Sdflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Sdflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Sdflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Sdflags> for Sdflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Sdflags> for Sdflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Sdflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Sdflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u8> for Sdflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Self, wiggle::GuestError> {
                    if u8::from(!Sdflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Sdflags"))
                    } else {
                        Ok(Sdflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Sdflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Sdflags::try_from(u8::try_from(value)?)
                }
            }
            impl From<Sdflags> for u8 {
                #[inline]
                fn from(e: Sdflags) -> u8 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Sdflags {
                #[inline]
                fn guest_size() -> u32 {
                    u8::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u8::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Sdflags>,
                ) -> Result<Sdflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u8::read(&location.cast())?;
                    let value = Sdflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Sdflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u8 = u8::from(val);
                    u8::write(&location.cast(), val)
                }
            }
            pub enum Preopentype {
                Dir,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Preopentype {
                #[inline]
                fn clone(&self) -> Preopentype {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Preopentype {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Dir")
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Preopentype {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Preopentype {
                #[inline]
                fn eq(&self, other: &Preopentype) -> bool {
                    true
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Preopentype {}
            impl TryFrom<u8> for Preopentype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Preopentype, wiggle::GuestError> {
                    match value {
                        0 => Ok(Preopentype::Dir),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Preopentype")),
                    }
                }
            }
            impl TryFrom<i32> for Preopentype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Preopentype, wiggle::GuestError> {
                    Preopentype::try_from(u8::try_from(value)?)
                }
            }
            impl From<Preopentype> for u8 {
                #[inline]
                fn from(v: Preopentype) -> u8 {
                    match v {
                        Preopentype::Dir => 0,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Preopentype {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Preopentype::Dir),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Preopentype")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Preopentype::Dir => {
                            location.cast().write(0usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct PrestatDir {
                pub pr_name_len: Size,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PrestatDir {
                #[inline]
                fn clone(&self) -> PrestatDir {
                    PrestatDir {
                        pr_name_len: ::core::clone::Clone::clone(&self.pr_name_len),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PrestatDir {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "PrestatDir",
                        "pr_name_len",
                        &&self.pr_name_len,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PrestatDir {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PrestatDir {
                #[inline]
                fn eq(&self, other: &PrestatDir) -> bool {
                    self.pr_name_len == other.pr_name_len
                }
            }
            impl<'a> wiggle::GuestType<'a> for PrestatDir {
                #[inline]
                fn guest_size() -> u32 {
                    4u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let pr_name_len = <Size as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    Ok(PrestatDir { pr_name_len })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.pr_name_len,
                    )?;
                    Ok(())
                }
            }
            pub enum Prestat {
                Dir(PrestatDir),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Prestat {
                #[inline]
                fn clone(&self) -> Prestat {
                    match self {
                        Prestat::Dir(__self_0) => {
                            Prestat::Dir(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Prestat {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        Prestat::Dir(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Dir",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Prestat {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Prestat {
                #[inline]
                fn eq(&self, other: &Prestat) -> bool {
                    match (self, other) {
                        (Prestat::Dir(__self_0), Prestat::Dir(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Prestat {
                #[inline]
                fn guest_size() -> u32 {
                    8u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => {
                            let variant_ptr = location.cast::<u8>().add(4u32)?;
                            let variant_val = <PrestatDir as wiggle::GuestType>::read(
                                &variant_ptr.cast(),
                            )?;
                            Ok(Prestat::Dir(variant_val))
                        }
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Prestat")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Prestat::Dir(contents) => {
                            location.cast().write(0usize as u8)?;
                            let variant_ptr = location.cast::<u8>().add(4u32)?;
                            <PrestatDir as wiggle::GuestType>::write(
                                &variant_ptr.cast(),
                                contents,
                            )?;
                        }
                    }
                    Ok(())
                }
            }
            pub trait UserErrorConversion {}
        }
        pub mod wasi_unstable {
            use super::types::*;
            pub use super::types::UserErrorConversion;
            #[allow(unreachable_code)]
            pub fn args_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"args_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"args_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let argv = wiggle::GuestPtr::<
                        wiggle::GuestPtr<'_, u8>,
                    >::new(memory, arg0 as u32);
                    let argv_buf = wiggle::GuestPtr::<u8>::new(memory, arg1 as u32);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["argv", "argv_buf"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&argv) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&argv_buf) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&argv) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&argv_buf) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::args_get(ctx, &argv, &argv_buf).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn args_sizes_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"args_sizes_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"args_sizes_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let ret = WasiUnstable::args_sizes_get(ctx).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                let (t0, t1) = e;
                                wiggle::GuestPtr::<Size>::new(memory, arg1 as u32)
                                    .write(t1)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "args_sizes_get",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                wiggle::GuestPtr::<Size>::new(memory, arg0 as u32)
                                    .write(t0)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "args_sizes_get",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn environ_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"environ_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"environ_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let environ = wiggle::GuestPtr::<
                        wiggle::GuestPtr<'_, u8>,
                    >::new(memory, arg0 as u32);
                    let environ_buf = wiggle::GuestPtr::<u8>::new(memory, arg1 as u32);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["environ", "environ_buf"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&environ) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&environ_buf) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&environ) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&environ_buf) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::environ_get(ctx, &environ, &environ_buf)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn environ_sizes_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"environ_sizes_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"environ_sizes_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let ret = WasiUnstable::environ_sizes_get(ctx).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                let (t0, t1) = e;
                                wiggle::GuestPtr::<Size>::new(memory, arg1 as u32)
                                    .write(t1)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "environ_sizes_get",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                wiggle::GuestPtr::<Size>::new(memory, arg0 as u32)
                                    .write(t0)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "environ_sizes_get",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn clock_res_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"clock_res_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"clock_res_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let id = Clockid::try_from(arg0)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "clock_res_get",
                                location: "convert Clockid",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["id"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&id) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&id) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::clock_res_get(ctx, id).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Timestamp>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "clock_res_get",
                                            location: "write timestamp",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn clock_time_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"clock_time_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"clock_time_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let id = Clockid::try_from(arg0)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "clock_time_get",
                                location: "convert Clockid",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let precision = arg1 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["id", "precision"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&id) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&precision) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&id) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&precision) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::clock_time_get(ctx, id, precision).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Timestamp>::new(memory, arg2 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "clock_time_get",
                                            location: "write timestamp",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_advise<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i64,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_advise" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_advise" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let offset = arg1 as u64;
                    let len = arg2 as u64;
                    let advice = Advice::try_from(arg3)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "fd_advise",
                                location: "convert Advice",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "offset", "len", "advice"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&len) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&advice) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&len) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&advice) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_advise(ctx, fd, offset, len, advice)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_allocate<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i64,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_allocate" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_allocate" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let offset = arg1 as u64;
                    let len = arg2 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "offset", "len"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&len) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&len) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_allocate(ctx, fd, offset, len).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_close<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_close" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_close" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_close(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_datasync<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_datasync" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_datasync" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_datasync(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_fdstat_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_fdstat_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_fdstat_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_fdstat_get(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Fdstat>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_fdstat_get",
                                            location: "write fdstat",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_fdstat_set_flags<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_fdstat_set_flags" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_fdstat_set_flags" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let flags = Fdflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "fd_fdstat_set_flags",
                                location: "convert Fdflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_fdstat_set_flags(ctx, fd, flags).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_fdstat_set_rights<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i64,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_fdstat_set_rights" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_fdstat_set_rights" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let fs_rights_base = Rights::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "fd_fdstat_set_rights",
                                location: "convert Rights",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let fs_rights_inheriting = Rights::try_from(arg2)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "fd_fdstat_set_rights",
                                location: "convert Rights",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "fs_rights_base", "fs_rights_inheriting"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::debug(&fs_rights_base) as &Value,
                                                ),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::debug(&fs_rights_inheriting)
                                                        as &Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::debug(&fs_rights_base) as &Value,
                                                                            ),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::debug(&fs_rights_inheriting)
                                                                                    as &Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_fdstat_set_rights(
                            ctx,
                            fd,
                            fs_rights_base,
                            fs_rights_inheriting,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_filestat_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_filestat_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_filestat_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_filestat_get(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Filestat>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_filestat_get",
                                            location: "write filestat",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_filestat_set_size<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_filestat_set_size" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_filestat_set_size" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let size = arg1 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "size"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&size) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&size) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_filestat_set_size(ctx, fd, size).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_filestat_set_times<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i64,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_filestat_set_times" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_filestat_set_times" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let atim = arg1 as u64;
                    let mtim = arg2 as u64;
                    let fst_flags = Fstflags::try_from(arg3)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "fd_filestat_set_times",
                                location: "convert Fstflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "atim", "mtim", "fst_flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&atim) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&mtim) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&fst_flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&atim) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&mtim) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&fst_flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_filestat_set_times(
                            ctx,
                            fd,
                            atim,
                            mtim,
                            fst_flags,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_pread<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i64,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_pread" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_pread" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let iovs = wiggle::GuestPtr::<
                        [Iovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let offset = arg3 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "iovs", "offset"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_pread(ctx, fd, &iovs, offset).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_pread",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_prestat_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_prestat_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_prestat_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_prestat_get(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Prestat>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_prestat_get",
                                            location: "write prestat",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_prestat_dir_name<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_prestat_dir_name" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_prestat_dir_name" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<u8>::new(memory, arg1 as u32);
                    let path_len = arg2 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path", "path_len"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&path_len) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&path_len) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_prestat_dir_name(ctx, fd, &path, path_len)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_pwrite<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i64,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_pwrite" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_pwrite" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let iovs = wiggle::GuestPtr::<
                        [Ciovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let offset = arg3 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "iovs", "offset"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_pwrite(ctx, fd, &iovs, offset).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_pwrite",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_read<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_read" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_read" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let iovs = wiggle::GuestPtr::<
                        [Iovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "iovs"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_read(ctx, fd, &iovs).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg3 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_read",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_readdir<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i64,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_readdir" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_readdir" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let buf = wiggle::GuestPtr::<u8>::new(memory, arg1 as u32);
                    let buf_len = arg2 as u32;
                    let cookie = arg3 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "buf", "buf_len", "cookie"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&cookie) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&cookie) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_readdir(ctx, fd, &buf, buf_len, cookie)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_readdir",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_renumber<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_renumber" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_renumber" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let to = Fd::from(arg1);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "to"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&to) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&to) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_renumber(ctx, fd, to).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_seek<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i32,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_seek" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_seek" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let offset = arg1;
                    let whence = Whence::try_from(arg2)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "fd_seek",
                                location: "convert Whence",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "offset", "whence"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&whence) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&whence) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_seek(ctx, fd, offset, whence).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Filesize>::new(memory, arg3 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_seek",
                                            location: "write filesize",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_sync<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_sync" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_sync" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_sync(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_tell<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_tell" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_tell" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_tell(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Filesize>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_tell",
                                            location: "write filesize",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_write<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_write" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_write" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let iovs = wiggle::GuestPtr::<
                        [Ciovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "iovs"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::fd_write(ctx, fd, &iovs).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg3 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "fd_write",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_create_directory<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_create_directory" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_create_directory" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_create_directory(ctx, fd, &path).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_filestat_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_filestat_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_filestat_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let flags = Lookupflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_filestat_get",
                                location: "convert Lookupflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg2 as u32, arg3 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "flags", "path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_filestat_get(ctx, fd, flags, &path)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Filestat>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "path_filestat_get",
                                            location: "write filestat",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_filestat_set_times<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i64,
                arg5: i64,
                arg6: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_filestat_set_times" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_filestat_set_times" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let flags = Lookupflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_filestat_set_times",
                                location: "convert Lookupflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg2 as u32, arg3 as u32));
                    let atim = arg4 as u64;
                    let mtim = arg5 as u64;
                    let fst_flags = Fstflags::try_from(arg6)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_filestat_set_times",
                                location: "convert Fstflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "flags", "path", "atim", "mtim", "fst_flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&atim) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&mtim) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&fst_flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&atim) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&mtim) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&fst_flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_filestat_set_times(
                            ctx,
                            fd,
                            flags,
                            &path,
                            atim,
                            mtim,
                            fst_flags,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_link<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i32,
                arg6: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_link" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_link" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let old_fd = Fd::from(arg0);
                    let old_flags = Lookupflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_link",
                                location: "convert Lookupflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let old_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg2 as u32, arg3 as u32));
                    let new_fd = Fd::from(arg4);
                    let new_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg5 as u32, arg6 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["old_fd", "old_flags", "old_path", "new_fd", "new_path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&old_fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&old_flags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&new_fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&old_fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&old_flags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&new_fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_link(
                            ctx,
                            old_fd,
                            old_flags,
                            &old_path,
                            new_fd,
                            &new_path,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_open<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i64,
                arg6: i64,
                arg7: i32,
                arg8: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_open" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_open" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let dirflags = Lookupflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_open",
                                location: "convert Lookupflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg2 as u32, arg3 as u32));
                    let oflags = Oflags::try_from(arg4)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_open",
                                location: "convert Oflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let fs_rights_base = Rights::try_from(arg5)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_open",
                                location: "convert Rights",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let fs_rights_inheriting = Rights::try_from(arg6)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_open",
                                location: "convert Rights",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let fdflags = Fdflags::try_from(arg7)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "path_open",
                                location: "convert Fdflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &[
                                            "fd",
                                            "dirflags",
                                            "path",
                                            "oflags",
                                            "fs_rights_base",
                                            "fs_rights_inheriting",
                                            "fdflags",
                                        ],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&dirflags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&oflags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::debug(&fs_rights_base) as &Value,
                                                ),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::debug(&fs_rights_inheriting)
                                                        as &Value,
                                                ),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&fdflags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&dirflags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&oflags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::debug(&fs_rights_base) as &Value,
                                                                            ),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::debug(&fs_rights_inheriting)
                                                                                    as &Value,
                                                                            ),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&fdflags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_open(
                            ctx,
                            fd,
                            dirflags,
                            &path,
                            oflags,
                            fs_rights_base,
                            fs_rights_inheriting,
                            fdflags,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Fd>::new(memory, arg8 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "path_open",
                                            location: "write fd",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_readlink<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_readlink" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_readlink" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let buf = wiggle::GuestPtr::<u8>::new(memory, arg3 as u32);
                    let buf_len = arg4 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path", "buf", "buf_len"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_readlink(ctx, fd, &path, &buf, buf_len)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg5 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "path_readlink",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_remove_directory<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_remove_directory" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_remove_directory" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_remove_directory(ctx, fd, &path).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_rename<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_rename" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_rename" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let old_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let new_fd = Fd::from(arg3);
                    let new_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg4 as u32, arg5 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "old_path", "new_fd", "new_path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&new_fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&new_fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_rename(
                            ctx,
                            fd,
                            &old_path,
                            new_fd,
                            &new_path,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_symlink<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_symlink" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_symlink" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let old_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg0 as u32, arg1 as u32));
                    let fd = Fd::from(arg2);
                    let new_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg3 as u32, arg4 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["old_path", "fd", "new_path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_symlink(ctx, &old_path, fd, &new_path)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_unlink_file<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_unlink_file" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_unlink_file" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::path_unlink_file(ctx, fd, &path).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn poll_oneoff<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"poll_oneoff" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"poll_oneoff" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let in_ = wiggle::GuestPtr::<Subscription>::new(memory, arg0 as u32);
                    let out = wiggle::GuestPtr::<Event>::new(memory, arg1 as u32);
                    let nsubscriptions = arg2 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["in_", "out", "nsubscriptions"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&in_) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&out) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::display(&nsubscriptions) as &Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&in_) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&out) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::display(&nsubscriptions) as &Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::poll_oneoff(ctx, &in_, &out, nsubscriptions)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg3 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "poll_oneoff",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn proc_exit<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<()>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"proc_exit" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"proc_exit" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let rval = arg0 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["rval"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&rval) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&rval) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::proc_exit(ctx, rval).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Err(ret);
                    return Ok(());
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn proc_raise<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"proc_raise" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"proc_raise" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let sig = Signal::try_from(arg0)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "proc_raise",
                                location: "convert Signal",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["sig"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&sig) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&sig) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::proc_raise(ctx, sig).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sched_yield<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sched_yield" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sched_yield" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let ret = WasiUnstable::sched_yield(ctx).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn random_get<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"random_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"random_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let buf = wiggle::GuestPtr::<u8>::new(memory, arg0 as u32);
                    let buf_len = arg1 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["buf", "buf_len"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::random_get(ctx, &buf, buf_len).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sock_recv<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sock_recv" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sock_recv" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let ri_data = wiggle::GuestPtr::<
                        [Iovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let ri_flags = Riflags::try_from(arg3)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "sock_recv",
                                location: "convert Riflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "ri_data", "ri_flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ri_data) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ri_flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ri_data) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ri_flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::sock_recv(ctx, fd, &ri_data, ri_flags).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                let (t0, t1) = e;
                                wiggle::GuestPtr::<Roflags>::new(memory, arg5 as u32)
                                    .write(t1)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "sock_recv",
                                            location: "write roflags",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(t0)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "sock_recv",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sock_send<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sock_send" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sock_send" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let si_data = wiggle::GuestPtr::<
                        [Ciovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let si_flags = u16::try_from(arg3)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "sock_send",
                                location: "convert u16",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "si_data", "si_flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&si_data) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&si_flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&si_data) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&si_flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::sock_send(ctx, fd, &si_data, si_flags).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_unstable",
                                            funcname: "sock_send",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sock_shutdown<'a>(
                ctx: &'a mut (impl WasiUnstable),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_0::wasi_unstable",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                Some(17u32),
                                Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_unstable" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sock_shutdown" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_unstable" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sock_shutdown" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let how = Sdflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_unstable",
                                funcname: "sock_shutdown",
                                location: "convert Sdflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "how"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&how) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&how) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiUnstable::sock_shutdown(ctx, fd, how).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_0.rs:17",
                                    "wasi_common::snapshots::preview_0::wasi_unstable",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_0.rs"),
                                    Some(17u32),
                                    Some("wasi_common::snapshots::preview_0::wasi_unstable"),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            pub trait WasiUnstable {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn args_get<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    argv: &'life1 wiggle::GuestPtr<'a, wiggle::GuestPtr<'a, u8>>,
                    argv_buf: &'life2 wiggle::GuestPtr<'a, u8>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn args_sizes_get<'life0, 'async_trait>(
                    &'life0 mut self,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(Size, Size), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn environ_get<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    environ: &'life1 wiggle::GuestPtr<'a, wiggle::GuestPtr<'a, u8>>,
                    environ_buf: &'life2 wiggle::GuestPtr<'a, u8>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn environ_sizes_get<'life0, 'async_trait>(
                    &'life0 mut self,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(Size, Size), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn clock_res_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    id: Clockid,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Timestamp, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn clock_time_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    id: Clockid,
                    precision: Timestamp,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Timestamp, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_advise<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    offset: Filesize,
                    len: Filesize,
                    advice: Advice,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_allocate<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    offset: Filesize,
                    len: Filesize,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_close<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_datasync<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_fdstat_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Fdstat, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_fdstat_set_flags<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    flags: Fdflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_fdstat_set_rights<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    fs_rights_base: Rights,
                    fs_rights_inheriting: Rights,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_filestat_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Filestat, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_filestat_set_size<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    size: Filesize,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_filestat_set_times<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    atim: Timestamp,
                    mtim: Timestamp,
                    fst_flags: Fstflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_pread<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    iovs: &'life1 IovecArray<'a>,
                    offset: Filesize,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_prestat_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Prestat, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_prestat_dir_name<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, u8>,
                    path_len: Size,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_pwrite<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    iovs: &'life1 CiovecArray<'a>,
                    offset: Filesize,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_read<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    iovs: &'life1 IovecArray<'a>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_readdir<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    buf: &'life1 wiggle::GuestPtr<'a, u8>,
                    buf_len: Size,
                    cookie: Dircookie,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_renumber<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    to: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_seek<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    offset: Filedelta,
                    whence: Whence,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Filesize, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_sync<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_tell<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Filesize, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_write<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    iovs: &'life1 CiovecArray<'a>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_create_directory<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_filestat_get<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    flags: Lookupflags,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Filestat, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_filestat_set_times<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    flags: Lookupflags,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                    atim: Timestamp,
                    mtim: Timestamp,
                    fst_flags: Fstflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_link<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    old_fd: Fd,
                    old_flags: Lookupflags,
                    old_path: &'life1 wiggle::GuestPtr<'a, str>,
                    new_fd: Fd,
                    new_path: &'life2 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_open<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    dirflags: Lookupflags,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                    oflags: Oflags,
                    fs_rights_base: Rights,
                    fs_rights_inheriting: Rights,
                    fdflags: Fdflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Fd, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_readlink<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                    buf: &'life2 wiggle::GuestPtr<'a, u8>,
                    buf_len: Size,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_remove_directory<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_rename<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    old_path: &'life1 wiggle::GuestPtr<'a, str>,
                    new_fd: Fd,
                    new_path: &'life2 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_symlink<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    old_path: &'life1 wiggle::GuestPtr<'a, str>,
                    fd: Fd,
                    new_path: &'life2 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_unlink_file<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn poll_oneoff<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    in_: &'life1 wiggle::GuestPtr<'a, Subscription>,
                    out: &'life2 wiggle::GuestPtr<'a, Event>,
                    nsubscriptions: Size,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn proc_exit<'life0, 'async_trait>(
                    &'life0 mut self,
                    rval: Exitcode,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wiggle::anyhow::Error,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn proc_raise<'life0, 'async_trait>(
                    &'life0 mut self,
                    sig: Signal,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sched_yield<'life0, 'async_trait>(
                    &'life0 mut self,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn random_get<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    buf: &'life1 wiggle::GuestPtr<'a, u8>,
                    buf_len: Size,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sock_recv<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    ri_data: &'life1 IovecArray<'a>,
                    ri_flags: Riflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(Size, Roflags), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sock_send<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    si_data: &'life1 CiovecArray<'a>,
                    si_flags: Siflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sock_shutdown<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    how: Sdflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
        }
        use types::Error;
        impl ErrorExt for Error {
            fn not_found() -> Self {
                types::Errno::Noent.into()
            }
            fn too_big() -> Self {
                types::Errno::TooBig.into()
            }
            fn badf() -> Self {
                types::Errno::Badf.into()
            }
            fn exist() -> Self {
                types::Errno::Exist.into()
            }
            fn illegal_byte_sequence() -> Self {
                types::Errno::Ilseq.into()
            }
            fn invalid_argument() -> Self {
                types::Errno::Inval.into()
            }
            fn io() -> Self {
                types::Errno::Io.into()
            }
            fn name_too_long() -> Self {
                types::Errno::Nametoolong.into()
            }
            fn not_dir() -> Self {
                types::Errno::Notdir.into()
            }
            fn not_supported() -> Self {
                types::Errno::Notsup.into()
            }
            fn overflow() -> Self {
                types::Errno::Overflow.into()
            }
            fn range() -> Self {
                types::Errno::Range.into()
            }
            fn seek_pipe() -> Self {
                types::Errno::Spipe.into()
            }
            fn perm() -> Self {
                types::Errno::Perm.into()
            }
        }
        impl wiggle::GuestErrorType for types::Errno {
            fn success() -> Self {
                Self::Success
            }
        }
        impl From<wiggle::GuestError> for Error {
            fn from(err: wiggle::GuestError) -> Error {
                snapshot1_types::Error::from(err).into()
            }
        }
        impl From<snapshot1_types::Error> for Error {
            fn from(error: snapshot1_types::Error) -> Error {
                match error.downcast() {
                    Ok(errno) => Error::from(types::Errno::from(errno)),
                    Err(trap) => Error::trap(trap),
                }
            }
        }
        impl From<std::num::TryFromIntError> for Error {
            fn from(_err: std::num::TryFromIntError) -> Error {
                types::Errno::Overflow.into()
            }
        }
        /// Fd is a newtype wrapper around u32. Unwrap and wrap it.
        impl From<types::Fd> for snapshot1_types::Fd {
            fn from(fd: types::Fd) -> snapshot1_types::Fd {
                u32::from(fd).into()
            }
        }
        /// Fd is a newtype wrapper around u32. Unwrap and wrap it.
        impl From<snapshot1_types::Fd> for types::Fd {
            fn from(fd: snapshot1_types::Fd) -> types::Fd {
                u32::from(fd).into()
            }
        }
        impl From<snapshot1_types::Errno> for types::Errno {
            fn from(e: snapshot1_types::Errno) -> types::Errno {
                match e {
                    <snapshot1_types::Errno>::Success => <types::Errno>::Success,
                    <snapshot1_types::Errno>::TooBig => <types::Errno>::TooBig,
                    <snapshot1_types::Errno>::Acces => <types::Errno>::Acces,
                    <snapshot1_types::Errno>::Addrinuse => <types::Errno>::Addrinuse,
                    <snapshot1_types::Errno>::Addrnotavail => {
                        <types::Errno>::Addrnotavail
                    }
                    <snapshot1_types::Errno>::Afnosupport => <types::Errno>::Afnosupport,
                    <snapshot1_types::Errno>::Again => <types::Errno>::Again,
                    <snapshot1_types::Errno>::Already => <types::Errno>::Already,
                    <snapshot1_types::Errno>::Badf => <types::Errno>::Badf,
                    <snapshot1_types::Errno>::Badmsg => <types::Errno>::Badmsg,
                    <snapshot1_types::Errno>::Busy => <types::Errno>::Busy,
                    <snapshot1_types::Errno>::Canceled => <types::Errno>::Canceled,
                    <snapshot1_types::Errno>::Child => <types::Errno>::Child,
                    <snapshot1_types::Errno>::Connaborted => <types::Errno>::Connaborted,
                    <snapshot1_types::Errno>::Connrefused => <types::Errno>::Connrefused,
                    <snapshot1_types::Errno>::Connreset => <types::Errno>::Connreset,
                    <snapshot1_types::Errno>::Deadlk => <types::Errno>::Deadlk,
                    <snapshot1_types::Errno>::Destaddrreq => <types::Errno>::Destaddrreq,
                    <snapshot1_types::Errno>::Dom => <types::Errno>::Dom,
                    <snapshot1_types::Errno>::Dquot => <types::Errno>::Dquot,
                    <snapshot1_types::Errno>::Exist => <types::Errno>::Exist,
                    <snapshot1_types::Errno>::Fault => <types::Errno>::Fault,
                    <snapshot1_types::Errno>::Fbig => <types::Errno>::Fbig,
                    <snapshot1_types::Errno>::Hostunreach => <types::Errno>::Hostunreach,
                    <snapshot1_types::Errno>::Idrm => <types::Errno>::Idrm,
                    <snapshot1_types::Errno>::Ilseq => <types::Errno>::Ilseq,
                    <snapshot1_types::Errno>::Inprogress => <types::Errno>::Inprogress,
                    <snapshot1_types::Errno>::Intr => <types::Errno>::Intr,
                    <snapshot1_types::Errno>::Inval => <types::Errno>::Inval,
                    <snapshot1_types::Errno>::Io => <types::Errno>::Io,
                    <snapshot1_types::Errno>::Isconn => <types::Errno>::Isconn,
                    <snapshot1_types::Errno>::Isdir => <types::Errno>::Isdir,
                    <snapshot1_types::Errno>::Loop => <types::Errno>::Loop,
                    <snapshot1_types::Errno>::Mfile => <types::Errno>::Mfile,
                    <snapshot1_types::Errno>::Mlink => <types::Errno>::Mlink,
                    <snapshot1_types::Errno>::Msgsize => <types::Errno>::Msgsize,
                    <snapshot1_types::Errno>::Multihop => <types::Errno>::Multihop,
                    <snapshot1_types::Errno>::Nametoolong => <types::Errno>::Nametoolong,
                    <snapshot1_types::Errno>::Netdown => <types::Errno>::Netdown,
                    <snapshot1_types::Errno>::Netreset => <types::Errno>::Netreset,
                    <snapshot1_types::Errno>::Netunreach => <types::Errno>::Netunreach,
                    <snapshot1_types::Errno>::Nfile => <types::Errno>::Nfile,
                    <snapshot1_types::Errno>::Nobufs => <types::Errno>::Nobufs,
                    <snapshot1_types::Errno>::Nodev => <types::Errno>::Nodev,
                    <snapshot1_types::Errno>::Noent => <types::Errno>::Noent,
                    <snapshot1_types::Errno>::Noexec => <types::Errno>::Noexec,
                    <snapshot1_types::Errno>::Nolck => <types::Errno>::Nolck,
                    <snapshot1_types::Errno>::Nolink => <types::Errno>::Nolink,
                    <snapshot1_types::Errno>::Nomem => <types::Errno>::Nomem,
                    <snapshot1_types::Errno>::Nomsg => <types::Errno>::Nomsg,
                    <snapshot1_types::Errno>::Noprotoopt => <types::Errno>::Noprotoopt,
                    <snapshot1_types::Errno>::Nospc => <types::Errno>::Nospc,
                    <snapshot1_types::Errno>::Nosys => <types::Errno>::Nosys,
                    <snapshot1_types::Errno>::Notconn => <types::Errno>::Notconn,
                    <snapshot1_types::Errno>::Notdir => <types::Errno>::Notdir,
                    <snapshot1_types::Errno>::Notempty => <types::Errno>::Notempty,
                    <snapshot1_types::Errno>::Notrecoverable => {
                        <types::Errno>::Notrecoverable
                    }
                    <snapshot1_types::Errno>::Notsock => <types::Errno>::Notsock,
                    <snapshot1_types::Errno>::Notsup => <types::Errno>::Notsup,
                    <snapshot1_types::Errno>::Notty => <types::Errno>::Notty,
                    <snapshot1_types::Errno>::Nxio => <types::Errno>::Nxio,
                    <snapshot1_types::Errno>::Overflow => <types::Errno>::Overflow,
                    <snapshot1_types::Errno>::Ownerdead => <types::Errno>::Ownerdead,
                    <snapshot1_types::Errno>::Perm => <types::Errno>::Perm,
                    <snapshot1_types::Errno>::Pipe => <types::Errno>::Pipe,
                    <snapshot1_types::Errno>::Proto => <types::Errno>::Proto,
                    <snapshot1_types::Errno>::Protonosupport => {
                        <types::Errno>::Protonosupport
                    }
                    <snapshot1_types::Errno>::Prototype => <types::Errno>::Prototype,
                    <snapshot1_types::Errno>::Range => <types::Errno>::Range,
                    <snapshot1_types::Errno>::Rofs => <types::Errno>::Rofs,
                    <snapshot1_types::Errno>::Spipe => <types::Errno>::Spipe,
                    <snapshot1_types::Errno>::Srch => <types::Errno>::Srch,
                    <snapshot1_types::Errno>::Stale => <types::Errno>::Stale,
                    <snapshot1_types::Errno>::Timedout => <types::Errno>::Timedout,
                    <snapshot1_types::Errno>::Txtbsy => <types::Errno>::Txtbsy,
                    <snapshot1_types::Errno>::Xdev => <types::Errno>::Xdev,
                    <snapshot1_types::Errno>::Notcapable => <types::Errno>::Notcapable,
                }
            }
        }
        impl From<types::Clockid> for snapshot1_types::Clockid {
            fn from(e: types::Clockid) -> snapshot1_types::Clockid {
                match e {
                    <types::Clockid>::Realtime => <snapshot1_types::Clockid>::Realtime,
                    <types::Clockid>::Monotonic => <snapshot1_types::Clockid>::Monotonic,
                    <types::Clockid>::ProcessCputimeId => {
                        <snapshot1_types::Clockid>::ProcessCputimeId
                    }
                    <types::Clockid>::ThreadCputimeId => {
                        <snapshot1_types::Clockid>::ThreadCputimeId
                    }
                }
            }
        }
        impl From<types::Advice> for snapshot1_types::Advice {
            fn from(e: types::Advice) -> snapshot1_types::Advice {
                match e {
                    <types::Advice>::Normal => <snapshot1_types::Advice>::Normal,
                    <types::Advice>::Sequential => <snapshot1_types::Advice>::Sequential,
                    <types::Advice>::Random => <snapshot1_types::Advice>::Random,
                    <types::Advice>::Willneed => <snapshot1_types::Advice>::Willneed,
                    <types::Advice>::Dontneed => <snapshot1_types::Advice>::Dontneed,
                    <types::Advice>::Noreuse => <snapshot1_types::Advice>::Noreuse,
                }
            }
        }
        impl From<snapshot1_types::Filetype> for types::Filetype {
            fn from(e: snapshot1_types::Filetype) -> types::Filetype {
                match e {
                    <snapshot1_types::Filetype>::Directory => {
                        <types::Filetype>::Directory
                    }
                    <snapshot1_types::Filetype>::BlockDevice => {
                        <types::Filetype>::BlockDevice
                    }
                    <snapshot1_types::Filetype>::CharacterDevice => {
                        <types::Filetype>::CharacterDevice
                    }
                    <snapshot1_types::Filetype>::RegularFile => {
                        <types::Filetype>::RegularFile
                    }
                    <snapshot1_types::Filetype>::SocketDgram => {
                        <types::Filetype>::SocketDgram
                    }
                    <snapshot1_types::Filetype>::SocketStream => {
                        <types::Filetype>::SocketStream
                    }
                    <snapshot1_types::Filetype>::SymbolicLink => {
                        <types::Filetype>::SymbolicLink
                    }
                    <snapshot1_types::Filetype>::Unknown => <types::Filetype>::Unknown,
                }
            }
        }
        impl From<types::Whence> for snapshot1_types::Whence {
            fn from(e: types::Whence) -> snapshot1_types::Whence {
                match e {
                    <types::Whence>::Cur => <snapshot1_types::Whence>::Cur,
                    <types::Whence>::End => <snapshot1_types::Whence>::End,
                    <types::Whence>::Set => <snapshot1_types::Whence>::Set,
                }
            }
        }
        /// Prestat isn't a c-style enum, its a union where the variant has a payload. Its the only one of
        /// those we need to convert, so write it by hand.
        impl From<snapshot1_types::Prestat> for types::Prestat {
            fn from(p: snapshot1_types::Prestat) -> types::Prestat {
                match p {
                    snapshot1_types::Prestat::Dir(d) => types::Prestat::Dir(d.into()),
                }
            }
        }
        impl From<snapshot1_types::PrestatDir> for types::PrestatDir {
            fn from(e: snapshot1_types::PrestatDir) -> types::PrestatDir {
                types::PrestatDir {
                    pr_name_len: e.pr_name_len.into(),
                }
            }
        }
        impl From<snapshot1_types::Fdstat> for types::Fdstat {
            fn from(e: snapshot1_types::Fdstat) -> types::Fdstat {
                types::Fdstat {
                    fs_filetype: e.fs_filetype.into(),
                    fs_rights_base: e.fs_rights_base.into(),
                    fs_rights_inheriting: e.fs_rights_inheriting.into(),
                    fs_flags: e.fs_flags.into(),
                }
            }
        }
        /// Snapshot1 Filestat is incompatible with Snapshot0 Filestat - the nlink
        /// field is u32 on this Filestat, and u64 on theirs. If you've got more than
        /// 2^32 links I don't know what to tell you
        impl From<snapshot1_types::Filestat> for types::Filestat {
            fn from(f: snapshot1_types::Filestat) -> types::Filestat {
                types::Filestat {
                    dev: f.dev.into(),
                    ino: f.ino.into(),
                    filetype: f.filetype.into(),
                    nlink: f.nlink.try_into().unwrap_or(u32::MAX),
                    size: f.size.into(),
                    atim: f.atim.into(),
                    mtim: f.mtim.into(),
                    ctim: f.ctim.into(),
                }
            }
        }
        impl From<snapshot1_types::Fdflags> for types::Fdflags {
            fn from(f: snapshot1_types::Fdflags) -> types::Fdflags {
                let mut out = <types::Fdflags>::empty();
                if f.contains(<snapshot1_types::Fdflags>::APPEND) {
                    out |= <types::Fdflags>::APPEND;
                }
                if f.contains(<snapshot1_types::Fdflags>::DSYNC) {
                    out |= <types::Fdflags>::DSYNC;
                }
                if f.contains(<snapshot1_types::Fdflags>::NONBLOCK) {
                    out |= <types::Fdflags>::NONBLOCK;
                }
                if f.contains(<snapshot1_types::Fdflags>::RSYNC) {
                    out |= <types::Fdflags>::RSYNC;
                }
                if f.contains(<snapshot1_types::Fdflags>::SYNC) {
                    out |= <types::Fdflags>::SYNC;
                }
                out
            }
        }
        impl From<types::Fdflags> for snapshot1_types::Fdflags {
            fn from(f: types::Fdflags) -> snapshot1_types::Fdflags {
                let mut out = <snapshot1_types::Fdflags>::empty();
                if f.contains(<types::Fdflags>::APPEND) {
                    out |= <snapshot1_types::Fdflags>::APPEND;
                }
                if f.contains(<types::Fdflags>::DSYNC) {
                    out |= <snapshot1_types::Fdflags>::DSYNC;
                }
                if f.contains(<types::Fdflags>::NONBLOCK) {
                    out |= <snapshot1_types::Fdflags>::NONBLOCK;
                }
                if f.contains(<types::Fdflags>::RSYNC) {
                    out |= <snapshot1_types::Fdflags>::RSYNC;
                }
                if f.contains(<types::Fdflags>::SYNC) {
                    out |= <snapshot1_types::Fdflags>::SYNC;
                }
                out
            }
        }
        impl From<types::Lookupflags> for snapshot1_types::Lookupflags {
            fn from(f: types::Lookupflags) -> snapshot1_types::Lookupflags {
                let mut out = <snapshot1_types::Lookupflags>::empty();
                if f.contains(<types::Lookupflags>::SYMLINK_FOLLOW) {
                    out |= <snapshot1_types::Lookupflags>::SYMLINK_FOLLOW;
                }
                out
            }
        }
        impl From<types::Fstflags> for snapshot1_types::Fstflags {
            fn from(f: types::Fstflags) -> snapshot1_types::Fstflags {
                let mut out = <snapshot1_types::Fstflags>::empty();
                if f.contains(<types::Fstflags>::ATIM) {
                    out |= <snapshot1_types::Fstflags>::ATIM;
                }
                if f.contains(<types::Fstflags>::ATIM_NOW) {
                    out |= <snapshot1_types::Fstflags>::ATIM_NOW;
                }
                if f.contains(<types::Fstflags>::MTIM) {
                    out |= <snapshot1_types::Fstflags>::MTIM;
                }
                if f.contains(<types::Fstflags>::MTIM_NOW) {
                    out |= <snapshot1_types::Fstflags>::MTIM_NOW;
                }
                out
            }
        }
        impl From<types::Oflags> for snapshot1_types::Oflags {
            fn from(f: types::Oflags) -> snapshot1_types::Oflags {
                let mut out = <snapshot1_types::Oflags>::empty();
                if f.contains(<types::Oflags>::CREAT) {
                    out |= <snapshot1_types::Oflags>::CREAT;
                }
                if f.contains(<types::Oflags>::DIRECTORY) {
                    out |= <snapshot1_types::Oflags>::DIRECTORY;
                }
                if f.contains(<types::Oflags>::EXCL) {
                    out |= <snapshot1_types::Oflags>::EXCL;
                }
                if f.contains(<types::Oflags>::TRUNC) {
                    out |= <snapshot1_types::Oflags>::TRUNC;
                }
                out
            }
        }
        impl From<types::Rights> for snapshot1_types::Rights {
            fn from(f: types::Rights) -> snapshot1_types::Rights {
                let mut out = <snapshot1_types::Rights>::empty();
                if f.contains(<types::Rights>::FD_DATASYNC) {
                    out |= <snapshot1_types::Rights>::FD_DATASYNC;
                }
                if f.contains(<types::Rights>::FD_READ) {
                    out |= <snapshot1_types::Rights>::FD_READ;
                }
                if f.contains(<types::Rights>::FD_SEEK) {
                    out |= <snapshot1_types::Rights>::FD_SEEK;
                }
                if f.contains(<types::Rights>::FD_FDSTAT_SET_FLAGS) {
                    out |= <snapshot1_types::Rights>::FD_FDSTAT_SET_FLAGS;
                }
                if f.contains(<types::Rights>::FD_SYNC) {
                    out |= <snapshot1_types::Rights>::FD_SYNC;
                }
                if f.contains(<types::Rights>::FD_TELL) {
                    out |= <snapshot1_types::Rights>::FD_TELL;
                }
                if f.contains(<types::Rights>::FD_WRITE) {
                    out |= <snapshot1_types::Rights>::FD_WRITE;
                }
                if f.contains(<types::Rights>::FD_ADVISE) {
                    out |= <snapshot1_types::Rights>::FD_ADVISE;
                }
                if f.contains(<types::Rights>::FD_ALLOCATE) {
                    out |= <snapshot1_types::Rights>::FD_ALLOCATE;
                }
                if f.contains(<types::Rights>::PATH_CREATE_DIRECTORY) {
                    out |= <snapshot1_types::Rights>::PATH_CREATE_DIRECTORY;
                }
                if f.contains(<types::Rights>::PATH_CREATE_FILE) {
                    out |= <snapshot1_types::Rights>::PATH_CREATE_FILE;
                }
                if f.contains(<types::Rights>::PATH_LINK_SOURCE) {
                    out |= <snapshot1_types::Rights>::PATH_LINK_SOURCE;
                }
                if f.contains(<types::Rights>::PATH_LINK_TARGET) {
                    out |= <snapshot1_types::Rights>::PATH_LINK_TARGET;
                }
                if f.contains(<types::Rights>::PATH_OPEN) {
                    out |= <snapshot1_types::Rights>::PATH_OPEN;
                }
                if f.contains(<types::Rights>::FD_READDIR) {
                    out |= <snapshot1_types::Rights>::FD_READDIR;
                }
                if f.contains(<types::Rights>::PATH_READLINK) {
                    out |= <snapshot1_types::Rights>::PATH_READLINK;
                }
                if f.contains(<types::Rights>::PATH_RENAME_SOURCE) {
                    out |= <snapshot1_types::Rights>::PATH_RENAME_SOURCE;
                }
                if f.contains(<types::Rights>::PATH_RENAME_TARGET) {
                    out |= <snapshot1_types::Rights>::PATH_RENAME_TARGET;
                }
                if f.contains(<types::Rights>::PATH_FILESTAT_GET) {
                    out |= <snapshot1_types::Rights>::PATH_FILESTAT_GET;
                }
                if f.contains(<types::Rights>::PATH_FILESTAT_SET_SIZE) {
                    out |= <snapshot1_types::Rights>::PATH_FILESTAT_SET_SIZE;
                }
                if f.contains(<types::Rights>::PATH_FILESTAT_SET_TIMES) {
                    out |= <snapshot1_types::Rights>::PATH_FILESTAT_SET_TIMES;
                }
                if f.contains(<types::Rights>::FD_FILESTAT_GET) {
                    out |= <snapshot1_types::Rights>::FD_FILESTAT_GET;
                }
                if f.contains(<types::Rights>::FD_FILESTAT_SET_SIZE) {
                    out |= <snapshot1_types::Rights>::FD_FILESTAT_SET_SIZE;
                }
                if f.contains(<types::Rights>::FD_FILESTAT_SET_TIMES) {
                    out |= <snapshot1_types::Rights>::FD_FILESTAT_SET_TIMES;
                }
                if f.contains(<types::Rights>::PATH_SYMLINK) {
                    out |= <snapshot1_types::Rights>::PATH_SYMLINK;
                }
                if f.contains(<types::Rights>::PATH_REMOVE_DIRECTORY) {
                    out |= <snapshot1_types::Rights>::PATH_REMOVE_DIRECTORY;
                }
                if f.contains(<types::Rights>::PATH_UNLINK_FILE) {
                    out |= <snapshot1_types::Rights>::PATH_UNLINK_FILE;
                }
                if f.contains(<types::Rights>::POLL_FD_READWRITE) {
                    out |= <snapshot1_types::Rights>::POLL_FD_READWRITE;
                }
                if f.contains(<types::Rights>::SOCK_SHUTDOWN) {
                    out |= <snapshot1_types::Rights>::SOCK_SHUTDOWN;
                }
                out
            }
        }
        impl From<snapshot1_types::Rights> for types::Rights {
            fn from(f: snapshot1_types::Rights) -> types::Rights {
                let mut out = <types::Rights>::empty();
                if f.contains(<snapshot1_types::Rights>::FD_DATASYNC) {
                    out |= <types::Rights>::FD_DATASYNC;
                }
                if f.contains(<snapshot1_types::Rights>::FD_READ) {
                    out |= <types::Rights>::FD_READ;
                }
                if f.contains(<snapshot1_types::Rights>::FD_SEEK) {
                    out |= <types::Rights>::FD_SEEK;
                }
                if f.contains(<snapshot1_types::Rights>::FD_FDSTAT_SET_FLAGS) {
                    out |= <types::Rights>::FD_FDSTAT_SET_FLAGS;
                }
                if f.contains(<snapshot1_types::Rights>::FD_SYNC) {
                    out |= <types::Rights>::FD_SYNC;
                }
                if f.contains(<snapshot1_types::Rights>::FD_TELL) {
                    out |= <types::Rights>::FD_TELL;
                }
                if f.contains(<snapshot1_types::Rights>::FD_WRITE) {
                    out |= <types::Rights>::FD_WRITE;
                }
                if f.contains(<snapshot1_types::Rights>::FD_ADVISE) {
                    out |= <types::Rights>::FD_ADVISE;
                }
                if f.contains(<snapshot1_types::Rights>::FD_ALLOCATE) {
                    out |= <types::Rights>::FD_ALLOCATE;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_CREATE_DIRECTORY) {
                    out |= <types::Rights>::PATH_CREATE_DIRECTORY;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_CREATE_FILE) {
                    out |= <types::Rights>::PATH_CREATE_FILE;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_LINK_SOURCE) {
                    out |= <types::Rights>::PATH_LINK_SOURCE;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_LINK_TARGET) {
                    out |= <types::Rights>::PATH_LINK_TARGET;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_OPEN) {
                    out |= <types::Rights>::PATH_OPEN;
                }
                if f.contains(<snapshot1_types::Rights>::FD_READDIR) {
                    out |= <types::Rights>::FD_READDIR;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_READLINK) {
                    out |= <types::Rights>::PATH_READLINK;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_RENAME_SOURCE) {
                    out |= <types::Rights>::PATH_RENAME_SOURCE;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_RENAME_TARGET) {
                    out |= <types::Rights>::PATH_RENAME_TARGET;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_FILESTAT_GET) {
                    out |= <types::Rights>::PATH_FILESTAT_GET;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_FILESTAT_SET_SIZE) {
                    out |= <types::Rights>::PATH_FILESTAT_SET_SIZE;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_FILESTAT_SET_TIMES) {
                    out |= <types::Rights>::PATH_FILESTAT_SET_TIMES;
                }
                if f.contains(<snapshot1_types::Rights>::FD_FILESTAT_GET) {
                    out |= <types::Rights>::FD_FILESTAT_GET;
                }
                if f.contains(<snapshot1_types::Rights>::FD_FILESTAT_SET_SIZE) {
                    out |= <types::Rights>::FD_FILESTAT_SET_SIZE;
                }
                if f.contains(<snapshot1_types::Rights>::FD_FILESTAT_SET_TIMES) {
                    out |= <types::Rights>::FD_FILESTAT_SET_TIMES;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_SYMLINK) {
                    out |= <types::Rights>::PATH_SYMLINK;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_REMOVE_DIRECTORY) {
                    out |= <types::Rights>::PATH_REMOVE_DIRECTORY;
                }
                if f.contains(<snapshot1_types::Rights>::PATH_UNLINK_FILE) {
                    out |= <types::Rights>::PATH_UNLINK_FILE;
                }
                if f.contains(<snapshot1_types::Rights>::POLL_FD_READWRITE) {
                    out |= <types::Rights>::POLL_FD_READWRITE;
                }
                if f.contains(<snapshot1_types::Rights>::SOCK_SHUTDOWN) {
                    out |= <types::Rights>::SOCK_SHUTDOWN;
                }
                out
            }
        }
        impl wasi_unstable::WasiUnstable for WasiCtx {
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn args_get<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                argv: &'life1 GuestPtr<'a, GuestPtr<'a, u8>>,
                argv_buf: &'life2 GuestPtr<'a, u8>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(), Error> = {
                        Snapshot1::args_get(__self, argv, argv_buf).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn args_sizes_get<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(types::Size, types::Size), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<(types::Size, types::Size), Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(types::Size, types::Size), Error> = {
                        let s = Snapshot1::args_sizes_get(__self).await?;
                        Ok(s)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn environ_get<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                environ: &'life1 GuestPtr<'a, GuestPtr<'a, u8>>,
                environ_buf: &'life2 GuestPtr<'a, u8>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(), Error> = {
                        Snapshot1::environ_get(__self, environ, environ_buf).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn environ_sizes_get<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(types::Size, types::Size), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<(types::Size, types::Size), Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(types::Size, types::Size), Error> = {
                        let s = Snapshot1::environ_sizes_get(__self).await?;
                        Ok(s)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn clock_res_get<'life0, 'async_trait>(
                &'life0 mut self,
                id: types::Clockid,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Timestamp, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Timestamp, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let id = id;
                    let __ret: Result<types::Timestamp, Error> = {
                        let t = Snapshot1::clock_res_get(__self, id.into()).await?;
                        Ok(t)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn clock_time_get<'life0, 'async_trait>(
                &'life0 mut self,
                id: types::Clockid,
                precision: types::Timestamp,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Timestamp, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Timestamp, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let id = id;
                    let precision = precision;
                    let __ret: Result<types::Timestamp, Error> = {
                        let t = Snapshot1::clock_time_get(__self, id.into(), precision)
                            .await?;
                        Ok(t)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_advise<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                offset: types::Filesize,
                len: types::Filesize,
                advice: types::Advice,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let len = len;
                    let advice = advice;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_advise(
                                __self,
                                fd.into(),
                                offset,
                                len,
                                advice.into(),
                            )
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_allocate<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                offset: types::Filesize,
                len: types::Filesize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let len = len;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_allocate(__self, fd.into(), offset, len).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_close<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_close(__self, fd.into()).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_datasync<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_datasync(__self, fd.into()).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_fdstat_get<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Fdstat, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Fdstat, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Fdstat, Error> = {
                        Ok(Snapshot1::fd_fdstat_get(__self, fd.into()).await?.into())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_fdstat_set_flags<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                flags: types::Fdflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let flags = flags;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_fdstat_set_flags(__self, fd.into(), flags.into())
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_fdstat_set_rights<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                fs_rights_base: types::Rights,
                fs_rights_inheriting: types::Rights,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let fs_rights_base = fs_rights_base;
                    let fs_rights_inheriting = fs_rights_inheriting;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_fdstat_set_rights(
                                __self,
                                fd.into(),
                                fs_rights_base.into(),
                                fs_rights_inheriting.into(),
                            )
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_filestat_get<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Filestat, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Filestat, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Filestat, Error> = {
                        Ok(Snapshot1::fd_filestat_get(__self, fd.into()).await?.into())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_filestat_set_size<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                size: types::Filesize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let size = size;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_filestat_set_size(__self, fd.into(), size).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_filestat_set_times<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                atim: types::Timestamp,
                mtim: types::Timestamp,
                fst_flags: types::Fstflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let atim = atim;
                    let mtim = mtim;
                    let fst_flags = fst_flags;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_filestat_set_times(
                                __self,
                                fd.into(),
                                atim,
                                mtim,
                                fst_flags.into(),
                            )
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_read<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                iovs: &'life1 types::IovecArray<'a>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::READ)?;
                        let iovs: Vec<wiggle::GuestPtr<[u8]>> = iovs
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Iovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len))
                            })
                            .collect::<Result<_, Error>>()?;
                        let is_shared_memory = iovs
                            .iter()
                            .next()
                            .and_then(|s| Some(s.is_shared_memory()))
                            .unwrap_or(false);
                        let bytes_read: u64 = if is_shared_memory {
                            let iov = iovs.into_iter().next();
                            if let Some(iov) = iov {
                                let mut buffer = ::alloc::vec::from_elem(
                                    0,
                                    (iov.len() as usize).min(MAX_SHARED_BUFFER_SIZE),
                                );
                                let bytes_read = f
                                    .read_vectored(&mut [IoSliceMut::new(&mut buffer)])
                                    .await?;
                                iov.get_range(0..bytes_read.try_into()?)
                                    .expect(
                                        "it should always be possible to slice the iov smaller",
                                    )
                                    .copy_from_slice(&buffer[0..bytes_read.try_into()?])?;
                                bytes_read
                            } else {
                                return Ok(0);
                            }
                        } else {
                            let mut guest_slices: Vec<wiggle::GuestSliceMut<u8>> = iovs
                                .into_iter()
                                .map(|iov| Ok(iov.as_slice_mut()?.unwrap()))
                                .collect::<Result<_, Error>>()?;
                            let mut ioslices: Vec<IoSliceMut> = guest_slices
                                .iter_mut()
                                .map(|s| IoSliceMut::new(&mut *s))
                                .collect();
                            f.read_vectored(&mut ioslices).await?
                        };
                        Ok(types::Size::try_from(bytes_read)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_pread<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                iovs: &'life1 types::IovecArray<'a>,
                offset: types::Filesize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::READ | FileCaps::SEEK)?;
                        let iovs: Vec<wiggle::GuestPtr<[u8]>> = iovs
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Iovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len))
                            })
                            .collect::<Result<_, Error>>()?;
                        let is_shared_memory = iovs
                            .iter()
                            .next()
                            .and_then(|s| Some(s.is_shared_memory()))
                            .unwrap_or(false);
                        let bytes_read: u64 = if is_shared_memory {
                            let iov = iovs.into_iter().next();
                            if let Some(iov) = iov {
                                let mut buffer = ::alloc::vec::from_elem(
                                    0,
                                    (iov.len() as usize).min(MAX_SHARED_BUFFER_SIZE),
                                );
                                let bytes_read = f
                                    .read_vectored_at(
                                        &mut [IoSliceMut::new(&mut buffer)],
                                        offset,
                                    )
                                    .await?;
                                iov.get_range(0..bytes_read.try_into()?)
                                    .expect(
                                        "it should always be possible to slice the iov smaller",
                                    )
                                    .copy_from_slice(&buffer[0..bytes_read.try_into()?])?;
                                bytes_read
                            } else {
                                return Ok(0);
                            }
                        } else {
                            let mut guest_slices: Vec<wiggle::GuestSliceMut<u8>> = iovs
                                .into_iter()
                                .map(|iov| Ok(iov.as_slice_mut()?.unwrap()))
                                .collect::<Result<_, Error>>()?;
                            let mut ioslices: Vec<IoSliceMut> = guest_slices
                                .iter_mut()
                                .map(|s| IoSliceMut::new(&mut *s))
                                .collect();
                            f.read_vectored_at(&mut ioslices, offset).await?
                        };
                        Ok(types::Size::try_from(bytes_read)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_write<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                ciovs: &'life1 types::CiovecArray<'a>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::WRITE)?;
                        let guest_slices: Vec<wiggle::GuestCow<u8>> = ciovs
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Ciovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len).as_cow()?)
                            })
                            .collect::<Result<_, Error>>()?;
                        let ioslices: Vec<IoSlice> = guest_slices
                            .iter()
                            .map(|s| IoSlice::new(s.deref()))
                            .collect();
                        let bytes_written = f.write_vectored(&ioslices).await?;
                        Ok(types::Size::try_from(bytes_written)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_pwrite<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                ciovs: &'life1 types::CiovecArray<'a>,
                offset: types::Filesize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::WRITE | FileCaps::SEEK)?;
                        let guest_slices: Vec<wiggle::GuestCow<u8>> = ciovs
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Ciovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len).as_cow()?)
                            })
                            .collect::<Result<_, Error>>()?;
                        let ioslices: Vec<IoSlice> = guest_slices
                            .iter()
                            .map(|s| IoSlice::new(s.deref()))
                            .collect();
                        let bytes_written = f
                            .write_vectored_at(&ioslices, offset)
                            .await?;
                        Ok(types::Size::try_from(bytes_written)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_prestat_get<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Prestat, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Prestat, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Prestat, Error> = {
                        Ok(Snapshot1::fd_prestat_get(__self, fd.into()).await?.into())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_prestat_dir_name<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                path: &'life1 GuestPtr<'a, u8>,
                path_max_len: types::Size,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let path_max_len = path_max_len;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_prestat_dir_name(
                                __self,
                                fd.into(),
                                path,
                                path_max_len,
                            )
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_renumber<'life0, 'async_trait>(
                &'life0 mut self,
                from: types::Fd,
                to: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let from = from;
                    let to = to;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_renumber(__self, from.into(), to.into()).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_seek<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                offset: types::Filedelta,
                whence: types::Whence,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Filesize, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Filesize, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let whence = whence;
                    let __ret: Result<types::Filesize, Error> = {
                        Ok(
                            Snapshot1::fd_seek(__self, fd.into(), offset, whence.into())
                                .await?,
                        )
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_sync<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::fd_sync(__self, fd.into()).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_tell<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Filesize, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Filesize, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Filesize, Error> = {
                        Ok(Snapshot1::fd_tell(__self, fd.into()).await?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_readdir<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                buf: &'life1 GuestPtr<'a, u8>,
                buf_len: types::Size,
                cookie: types::Dircookie,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let buf_len = buf_len;
                    let cookie = cookie;
                    let __ret: Result<types::Size, Error> = {
                        Ok(
                            Snapshot1::fd_readdir(
                                    __self,
                                    fd.into(),
                                    buf,
                                    buf_len,
                                    cookie,
                                )
                                .await?,
                        )
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_create_directory<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                path: &'life1 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::path_create_directory(__self, dirfd.into(), path)
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_filestat_get<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                flags: types::Lookupflags,
                path: &'life1 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Filestat, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Filestat, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let flags = flags;
                    let __ret: Result<types::Filestat, Error> = {
                        Ok(
                            Snapshot1::path_filestat_get(
                                    __self,
                                    dirfd.into(),
                                    flags.into(),
                                    path,
                                )
                                .await?
                                .into(),
                        )
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_filestat_set_times<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                flags: types::Lookupflags,
                path: &'life1 GuestPtr<'a, str>,
                atim: types::Timestamp,
                mtim: types::Timestamp,
                fst_flags: types::Fstflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let flags = flags;
                    let atim = atim;
                    let mtim = mtim;
                    let fst_flags = fst_flags;
                    let __ret: Result<(), Error> = {
                        Snapshot1::path_filestat_set_times(
                                __self,
                                dirfd.into(),
                                flags.into(),
                                path,
                                atim,
                                mtim,
                                fst_flags.into(),
                            )
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_link<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                src_fd: types::Fd,
                src_flags: types::Lookupflags,
                src_path: &'life1 GuestPtr<'a, str>,
                target_fd: types::Fd,
                target_path: &'life2 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let src_fd = src_fd;
                    let src_flags = src_flags;
                    let target_fd = target_fd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::path_link(
                                __self,
                                src_fd.into(),
                                src_flags.into(),
                                src_path,
                                target_fd.into(),
                                target_path,
                            )
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_open<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                dirflags: types::Lookupflags,
                path: &'life1 GuestPtr<'a, str>,
                oflags: types::Oflags,
                fs_rights_base: types::Rights,
                fs_rights_inheriting: types::Rights,
                fdflags: types::Fdflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Fd, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Fd, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let dirflags = dirflags;
                    let oflags = oflags;
                    let fs_rights_base = fs_rights_base;
                    let fs_rights_inheriting = fs_rights_inheriting;
                    let fdflags = fdflags;
                    let __ret: Result<types::Fd, Error> = {
                        Ok(
                            Snapshot1::path_open(
                                    __self,
                                    dirfd.into(),
                                    dirflags.into(),
                                    path,
                                    oflags.into(),
                                    fs_rights_base.into(),
                                    fs_rights_inheriting.into(),
                                    fdflags.into(),
                                )
                                .await?
                                .into(),
                        )
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_readlink<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                path: &'life1 GuestPtr<'a, str>,
                buf: &'life2 GuestPtr<'a, u8>,
                buf_len: types::Size,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let buf_len = buf_len;
                    let __ret: Result<types::Size, Error> = {
                        Ok(
                            Snapshot1::path_readlink(
                                    __self,
                                    dirfd.into(),
                                    path,
                                    buf,
                                    buf_len,
                                )
                                .await?,
                        )
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_remove_directory<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                path: &'life1 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::path_remove_directory(__self, dirfd.into(), path)
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_rename<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                src_fd: types::Fd,
                src_path: &'life1 GuestPtr<'a, str>,
                dest_fd: types::Fd,
                dest_path: &'life2 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let src_fd = src_fd;
                    let dest_fd = dest_fd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::path_rename(
                                __self,
                                src_fd.into(),
                                src_path,
                                dest_fd.into(),
                                dest_path,
                            )
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_symlink<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                src_path: &'life1 GuestPtr<'a, str>,
                dirfd: types::Fd,
                dest_path: &'life2 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::path_symlink(
                                __self,
                                src_path,
                                dirfd.into(),
                                dest_path,
                            )
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_unlink_file<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                path: &'life1 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let __ret: Result<(), Error> = {
                        Snapshot1::path_unlink_file(__self, dirfd.into(), path).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn poll_oneoff<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                subs: &'life1 GuestPtr<'a, types::Subscription>,
                events: &'life2 GuestPtr<'a, types::Event>,
                nsubscriptions: types::Size,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let nsubscriptions = nsubscriptions;
                    let __ret: Result<types::Size, Error> = {
                        if nsubscriptions == 0 {
                            return Err(
                                Error::invalid_argument()
                                    .context("nsubscriptions must be nonzero"),
                            );
                        }
                        if nsubscriptions == 1 {
                            let sub = subs.read()?;
                            if let types::SubscriptionU::Clock(clocksub) = sub.u {
                                if !clocksub
                                    .flags
                                    .contains(types::Subclockflags::SUBSCRIPTION_CLOCK_ABSTIME)
                                {
                                    __self
                                        .sched
                                        .sleep(Duration::from_nanos(clocksub.timeout))
                                        .await?;
                                    events
                                        .write(types::Event {
                                            userdata: sub.userdata,
                                            error: types::Errno::Success,
                                            type_: types::Eventtype::Clock,
                                            fd_readwrite: fd_readwrite_empty(),
                                        })?;
                                    return Ok(1);
                                }
                            }
                        }
                        let table = &__self.table;
                        let mut sub_fds: HashSet<types::Fd> = HashSet::new();
                        let mut reads: Vec<(u32, Userdata)> = Vec::new();
                        let mut writes: Vec<(u32, Userdata)> = Vec::new();
                        let mut poll = Poll::new();
                        let subs = subs.as_array(nsubscriptions);
                        for sub_elem in subs.iter() {
                            let sub_ptr = sub_elem?;
                            let sub = sub_ptr.read()?;
                            match sub.u {
                                types::SubscriptionU::Clock(clocksub) => {
                                    match clocksub.id {
                                        types::Clockid::Monotonic => {
                                            let clock = __self.clocks.monotonic()?;
                                            let precision = Duration::from_nanos(clocksub.precision);
                                            let duration = Duration::from_nanos(clocksub.timeout);
                                            let start = if clocksub
                                                .flags
                                                .contains(types::Subclockflags::SUBSCRIPTION_CLOCK_ABSTIME)
                                            {
                                                clock.creation_time
                                            } else {
                                                clock.abs_clock.now(precision)
                                            };
                                            let deadline = start
                                                .checked_add(duration)
                                                .ok_or_else(|| Error::overflow().context("deadline"))?;
                                            poll.subscribe_monotonic_clock(
                                                &*clock.abs_clock,
                                                deadline,
                                                precision,
                                                sub.userdata.into(),
                                            )
                                        }
                                        _ => {
                                            Err(
                                                Error::invalid_argument()
                                                    .context("timer subscriptions only support monotonic timer"),
                                            )?
                                        }
                                    }
                                }
                                types::SubscriptionU::FdRead(readsub) => {
                                    let fd = readsub.file_descriptor;
                                    if sub_fds.contains(&fd) {
                                        return Err(
                                            Error::invalid_argument()
                                                .context("Fd can be subscribed to at most once per poll"),
                                        );
                                    } else {
                                        sub_fds.insert(fd);
                                    }
                                    table
                                        .get_file(u32::from(fd))?
                                        .get_cap(FileCaps::POLL_READWRITE)?;
                                    reads.push((u32::from(fd), sub.userdata.into()));
                                }
                                types::SubscriptionU::FdWrite(writesub) => {
                                    let fd = writesub.file_descriptor;
                                    if sub_fds.contains(&fd) {
                                        return Err(
                                            Error::invalid_argument()
                                                .context("Fd can be subscribed to at most once per poll"),
                                        );
                                    } else {
                                        sub_fds.insert(fd);
                                    }
                                    table
                                        .get_file(u32::from(fd))?
                                        .get_cap(FileCaps::POLL_READWRITE)?;
                                    writes.push((u32::from(fd), sub.userdata.into()));
                                }
                            }
                        }
                        __self.sched.poll_oneoff(&mut poll).await?;
                        let results = poll.results();
                        let num_results = results.len();
                        if !(num_results <= nsubscriptions as usize) {
                            ::core::panicking::panic_fmt(
                                format_args!("results exceeds subscriptions"),
                            )
                        }
                        let events = events
                            .as_array(
                                num_results
                                    .try_into()
                                    .expect("not greater than nsubscriptions"),
                            );
                        for ((result, userdata), event_elem) in results
                            .into_iter()
                            .zip(events.iter())
                        {
                            let event_ptr = event_elem?;
                            let userdata: types::Userdata = userdata.into();
                            event_ptr
                                .write(
                                    match result {
                                        SubscriptionResult::Read(r) => {
                                            let type_ = types::Eventtype::FdRead;
                                            match r {
                                                Ok((nbytes, flags)) => {
                                                    types::Event {
                                                        userdata,
                                                        error: types::Errno::Success,
                                                        type_,
                                                        fd_readwrite: types::EventFdReadwrite {
                                                            nbytes,
                                                            flags: types::Eventrwflags::from(&flags),
                                                        },
                                                    }
                                                }
                                                Err(e) => {
                                                    types::Event {
                                                        userdata,
                                                        error: types::Errno::from(
                                                            e.downcast().map_err(Error::trap)?,
                                                        ),
                                                        type_,
                                                        fd_readwrite: fd_readwrite_empty(),
                                                    }
                                                }
                                            }
                                        }
                                        SubscriptionResult::Write(r) => {
                                            let type_ = types::Eventtype::FdWrite;
                                            match r {
                                                Ok((nbytes, flags)) => {
                                                    types::Event {
                                                        userdata,
                                                        error: types::Errno::Success,
                                                        type_,
                                                        fd_readwrite: types::EventFdReadwrite {
                                                            nbytes,
                                                            flags: types::Eventrwflags::from(&flags),
                                                        },
                                                    }
                                                }
                                                Err(e) => {
                                                    types::Event {
                                                        userdata,
                                                        error: types::Errno::from(
                                                            e.downcast().map_err(Error::trap)?,
                                                        ),
                                                        type_,
                                                        fd_readwrite: fd_readwrite_empty(),
                                                    }
                                                }
                                            }
                                        }
                                        SubscriptionResult::MonotonicClock(r) => {
                                            let type_ = types::Eventtype::Clock;
                                            types::Event {
                                                userdata,
                                                error: match r {
                                                    Ok(()) => types::Errno::Success,
                                                    Err(e) => {
                                                        types::Errno::from(e.downcast().map_err(Error::trap)?)
                                                    }
                                                },
                                                type_,
                                                fd_readwrite: fd_readwrite_empty(),
                                            }
                                        }
                                    },
                                )?;
                        }
                        Ok(num_results.try_into().expect("results fit into memory"))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn proc_exit<'life0, 'async_trait>(
                &'life0 mut self,
                status: types::Exitcode,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = anyhow::Error,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<anyhow::Error> {
                        return __ret;
                    }
                    let mut __self = self;
                    let status = status;
                    let __ret: anyhow::Error = {
                        Snapshot1::proc_exit(__self, status).await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn proc_raise<'life0, 'async_trait>(
                &'life0 mut self,
                _sig: types::Signal,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let _sig = _sig;
                    let __ret: Result<(), Error> = {
                        Err(Error::trap(anyhow::Error::msg("proc_raise unsupported")))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sched_yield<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(), Error> = {
                        Snapshot1::sched_yield(__self).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn random_get<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                buf: &'life1 GuestPtr<'a, u8>,
                buf_len: types::Size,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let buf_len = buf_len;
                    let __ret: Result<(), Error> = {
                        Snapshot1::random_get(__self, buf, buf_len).await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sock_recv<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                _fd: types::Fd,
                _ri_data: &'life1 types::IovecArray<'a>,
                _ri_flags: types::Riflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(types::Size, types::Roflags), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<(types::Size, types::Roflags), Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let _fd = _fd;
                    let _ri_flags = _ri_flags;
                    let __ret: Result<(types::Size, types::Roflags), Error> = {
                        Err(Error::trap(anyhow::Error::msg("sock_recv unsupported")))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sock_send<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                _fd: types::Fd,
                _si_data: &'life1 types::CiovecArray<'a>,
                _si_flags: types::Siflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let _fd = _fd;
                    let _si_flags = _si_flags;
                    let __ret: Result<types::Size, Error> = {
                        Err(Error::trap(anyhow::Error::msg("sock_send unsupported")))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sock_shutdown<'life0, 'async_trait>(
                &'life0 mut self,
                _fd: types::Fd,
                _how: types::Sdflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let _fd = _fd;
                    let _how = _how;
                    let __ret: Result<(), Error> = {
                        Err(Error::trap(anyhow::Error::msg("sock_shutdown unsupported")))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
        impl From<&RwEventFlags> for types::Eventrwflags {
            fn from(flags: &RwEventFlags) -> types::Eventrwflags {
                let mut out = types::Eventrwflags::empty();
                if flags.contains(RwEventFlags::HANGUP) {
                    out = out | types::Eventrwflags::FD_READWRITE_HANGUP;
                }
                out
            }
        }
        fn fd_readwrite_empty() -> types::EventFdReadwrite {
            types::EventFdReadwrite {
                nbytes: 0,
                flags: types::Eventrwflags::empty(),
            }
        }
    }
    pub mod preview_1 {
        use crate::{
            dir::{
                DirCaps, DirEntry, DirEntryExt, DirFdStat, ReaddirCursor, ReaddirEntity,
                TableDirExt,
            },
            file::{
                Advice, FdFlags, FdStat, FileCaps, FileEntry, FileEntryExt, FileType,
                Filestat, OFlags, RiFlags, RoFlags, SdFlags, SiFlags, TableFileExt,
                WasiFile,
            },
            sched::{
                subscription::{RwEventFlags, SubscriptionResult},
                Poll, Userdata,
            },
            I32Exit, SystemTimeSpec, WasiCtx,
        };
        use async_rdma::{LocalMrReadAccess, LocalMrWriteAccess, Rdma, RdmaBuilder};
        use cap_std::time::{Duration, SystemClock};
        use portpicker::pick_unused_port;
        use std::convert::{TryFrom, TryInto};
        use std::io::{IoSlice, IoSliceMut};
        use std::ops::Deref;
        use std::sync::Arc;
        use std::{
            alloc::Layout, io::{self, Write},
            net::{Ipv4Addr, SocketAddrV4},
        };
        use wiggle::GuestPtr;
        pub mod error {
            pub use super::types::{Errno, Error};
            pub trait ErrorExt {
                fn not_found() -> Self;
                fn too_big() -> Self;
                fn badf() -> Self;
                fn exist() -> Self;
                fn illegal_byte_sequence() -> Self;
                fn invalid_argument() -> Self;
                fn io() -> Self;
                fn name_too_long() -> Self;
                fn not_dir() -> Self;
                fn not_supported() -> Self;
                fn overflow() -> Self;
                fn range() -> Self;
                fn seek_pipe() -> Self;
                fn perm() -> Self;
            }
            impl ErrorExt for Error {
                fn not_found() -> Self {
                    Errno::Noent.into()
                }
                fn too_big() -> Self {
                    Errno::TooBig.into()
                }
                fn badf() -> Self {
                    Errno::Badf.into()
                }
                fn exist() -> Self {
                    Errno::Exist.into()
                }
                fn illegal_byte_sequence() -> Self {
                    Errno::Ilseq.into()
                }
                fn invalid_argument() -> Self {
                    Errno::Inval.into()
                }
                fn io() -> Self {
                    Errno::Io.into()
                }
                fn name_too_long() -> Self {
                    Errno::Nametoolong.into()
                }
                fn not_dir() -> Self {
                    Errno::Notdir.into()
                }
                fn not_supported() -> Self {
                    Errno::Notsup.into()
                }
                fn overflow() -> Self {
                    Errno::Overflow.into()
                }
                fn range() -> Self {
                    Errno::Range.into()
                }
                fn seek_pipe() -> Self {
                    Errno::Spipe.into()
                }
                fn perm() -> Self {
                    Errno::Perm.into()
                }
            }
            #[cfg(unix)]
            fn from_raw_os_error(err: Option<i32>) -> Option<Error> {
                use rustix::io::Errno as RustixErrno;
                if err.is_none() {
                    return None;
                }
                Some(
                    match RustixErrno::from_raw_os_error(err.unwrap()) {
                        RustixErrno::AGAIN => Errno::Again.into(),
                        RustixErrno::PIPE => Errno::Pipe.into(),
                        RustixErrno::PERM => Errno::Perm.into(),
                        RustixErrno::NOENT => Errno::Noent.into(),
                        RustixErrno::NOMEM => Errno::Nomem.into(),
                        RustixErrno::TOOBIG => Errno::TooBig.into(),
                        RustixErrno::IO => Errno::Io.into(),
                        RustixErrno::BADF => Errno::Badf.into(),
                        RustixErrno::BUSY => Errno::Busy.into(),
                        RustixErrno::ACCESS => Errno::Acces.into(),
                        RustixErrno::FAULT => Errno::Fault.into(),
                        RustixErrno::NOTDIR => Errno::Notdir.into(),
                        RustixErrno::ISDIR => Errno::Isdir.into(),
                        RustixErrno::INVAL => Errno::Inval.into(),
                        RustixErrno::EXIST => Errno::Exist.into(),
                        RustixErrno::FBIG => Errno::Fbig.into(),
                        RustixErrno::NOSPC => Errno::Nospc.into(),
                        RustixErrno::SPIPE => Errno::Spipe.into(),
                        RustixErrno::MFILE => Errno::Mfile.into(),
                        RustixErrno::MLINK => Errno::Mlink.into(),
                        RustixErrno::NAMETOOLONG => Errno::Nametoolong.into(),
                        RustixErrno::NFILE => Errno::Nfile.into(),
                        RustixErrno::NOTEMPTY => Errno::Notempty.into(),
                        RustixErrno::LOOP => Errno::Loop.into(),
                        RustixErrno::OVERFLOW => Errno::Overflow.into(),
                        RustixErrno::ILSEQ => Errno::Ilseq.into(),
                        RustixErrno::NOTSUP => Errno::Notsup.into(),
                        RustixErrno::ADDRINUSE => Errno::Addrinuse.into(),
                        RustixErrno::CANCELED => Errno::Canceled.into(),
                        RustixErrno::ADDRNOTAVAIL => Errno::Addrnotavail.into(),
                        RustixErrno::AFNOSUPPORT => Errno::Afnosupport.into(),
                        RustixErrno::ALREADY => Errno::Already.into(),
                        RustixErrno::CONNABORTED => Errno::Connaborted.into(),
                        RustixErrno::CONNREFUSED => Errno::Connrefused.into(),
                        RustixErrno::CONNRESET => Errno::Connreset.into(),
                        RustixErrno::DESTADDRREQ => Errno::Destaddrreq.into(),
                        RustixErrno::DQUOT => Errno::Dquot.into(),
                        RustixErrno::HOSTUNREACH => Errno::Hostunreach.into(),
                        RustixErrno::INPROGRESS => Errno::Inprogress.into(),
                        RustixErrno::INTR => Errno::Intr.into(),
                        RustixErrno::ISCONN => Errno::Isconn.into(),
                        RustixErrno::MSGSIZE => Errno::Msgsize.into(),
                        RustixErrno::NETDOWN => Errno::Netdown.into(),
                        RustixErrno::NETRESET => Errno::Netreset.into(),
                        RustixErrno::NETUNREACH => Errno::Netunreach.into(),
                        RustixErrno::NOBUFS => Errno::Nobufs.into(),
                        RustixErrno::NOPROTOOPT => Errno::Noprotoopt.into(),
                        RustixErrno::NOTCONN => Errno::Notconn.into(),
                        RustixErrno::NOTSOCK => Errno::Notsock.into(),
                        RustixErrno::PROTONOSUPPORT => Errno::Protonosupport.into(),
                        RustixErrno::PROTOTYPE => Errno::Prototype.into(),
                        RustixErrno::STALE => Errno::Stale.into(),
                        RustixErrno::TIMEDOUT => Errno::Timedout.into(),
                        #[allow(unreachable_patterns)]
                        RustixErrno::WOULDBLOCK => Errno::Again.into(),
                        #[allow(unreachable_patterns)]
                        RustixErrno::OPNOTSUPP => Errno::Notsup.into(),
                        _ => return None,
                    },
                )
            }
            impl From<std::io::Error> for Error {
                fn from(err: std::io::Error) -> Error {
                    match from_raw_os_error(err.raw_os_error()) {
                        Some(errno) => errno,
                        None => {
                            match err.kind() {
                                std::io::ErrorKind::NotFound => Errno::Noent.into(),
                                std::io::ErrorKind::PermissionDenied => Errno::Perm.into(),
                                std::io::ErrorKind::AlreadyExists => Errno::Exist.into(),
                                std::io::ErrorKind::InvalidInput => Errno::Inval.into(),
                                _ => {
                                    Error::trap(
                                        ::anyhow::__private::must_use({
                                                use ::anyhow::__private::kind::*;
                                                let error = match err {
                                                    error => (&error).anyhow_kind().new(error),
                                                };
                                                error
                                            })
                                            .context("Unknown OS error"),
                                    )
                                }
                            }
                        }
                    }
                }
            }
            impl From<cap_rand::Error> for Error {
                fn from(err: cap_rand::Error) -> Error {
                    from_raw_os_error(err.raw_os_error())
                        .unwrap_or_else(|| Error::from(Errno::Io))
                }
            }
            impl From<wiggle::GuestError> for Error {
                fn from(err: wiggle::GuestError) -> Error {
                    use wiggle::GuestError::*;
                    match err {
                        InvalidFlagValue { .. } => Errno::Inval.into(),
                        InvalidEnumValue { .. } => Errno::Inval.into(),
                        PtrOverflow { .. } => Errno::Fault.into(),
                        PtrOutOfBounds { .. } => Errno::Fault.into(),
                        PtrNotAligned { .. } => Errno::Inval.into(),
                        PtrBorrowed { .. } => Errno::Fault.into(),
                        InvalidUtf8 { .. } => Errno::Ilseq.into(),
                        TryFromIntError { .. } => Errno::Overflow.into(),
                        SliceLengthsDiffer { .. } => Errno::Fault.into(),
                        BorrowCheckerOutOfHandles { .. } => Errno::Fault.into(),
                        InFunc { err, .. } => Error::from(*err),
                    }
                }
            }
            impl From<std::num::TryFromIntError> for Error {
                fn from(_err: std::num::TryFromIntError) -> Error {
                    Errno::Overflow.into()
                }
            }
        }
        use error::{Error, ErrorExt};
        pub(crate) const MAX_SHARED_BUFFER_SIZE: usize = 1 << 16;
        pub mod types {
            use std::convert::TryFrom;
            pub type Size = u32;
            pub type Filesize = u64;
            pub type Timestamp = u64;
            pub enum Clockid {
                Realtime,
                Monotonic,
                ProcessCputimeId,
                ThreadCputimeId,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Clockid {
                #[inline]
                fn clone(&self) -> Clockid {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Clockid {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Clockid::Realtime => "Realtime",
                            Clockid::Monotonic => "Monotonic",
                            Clockid::ProcessCputimeId => "ProcessCputimeId",
                            Clockid::ThreadCputimeId => "ThreadCputimeId",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Clockid {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Clockid {
                #[inline]
                fn eq(&self, other: &Clockid) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Clockid {}
            impl TryFrom<u32> for Clockid {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u32) -> Result<Clockid, wiggle::GuestError> {
                    match value {
                        0 => Ok(Clockid::Realtime),
                        1 => Ok(Clockid::Monotonic),
                        2 => Ok(Clockid::ProcessCputimeId),
                        3 => Ok(Clockid::ThreadCputimeId),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Clockid")),
                    }
                }
            }
            impl TryFrom<i32> for Clockid {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Clockid, wiggle::GuestError> {
                    Clockid::try_from(u32::try_from(value)?)
                }
            }
            impl From<Clockid> for u32 {
                #[inline]
                fn from(v: Clockid) -> u32 {
                    match v {
                        Clockid::Realtime => 0,
                        Clockid::Monotonic => 1,
                        Clockid::ProcessCputimeId => 2,
                        Clockid::ThreadCputimeId => 3,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Clockid {
                #[inline]
                fn guest_size() -> u32 {
                    4u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u32>().read()?;
                    match tag {
                        0 => Ok(Clockid::Realtime),
                        1 => Ok(Clockid::Monotonic),
                        2 => Ok(Clockid::ProcessCputimeId),
                        3 => Ok(Clockid::ThreadCputimeId),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Clockid")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Clockid::Realtime => {
                            location.cast().write(0usize as u32)?;
                        }
                        Clockid::Monotonic => {
                            location.cast().write(1usize as u32)?;
                        }
                        Clockid::ProcessCputimeId => {
                            location.cast().write(2usize as u32)?;
                        }
                        Clockid::ThreadCputimeId => {
                            location.cast().write(3usize as u32)?;
                        }
                    }
                    Ok(())
                }
            }
            pub enum Errno {
                Success,
                TooBig,
                Acces,
                Addrinuse,
                Addrnotavail,
                Afnosupport,
                Again,
                Already,
                Badf,
                Badmsg,
                Busy,
                Canceled,
                Child,
                Connaborted,
                Connrefused,
                Connreset,
                Deadlk,
                Destaddrreq,
                Dom,
                Dquot,
                Exist,
                Fault,
                Fbig,
                Hostunreach,
                Idrm,
                Ilseq,
                Inprogress,
                Intr,
                Inval,
                Io,
                Isconn,
                Isdir,
                Loop,
                Mfile,
                Mlink,
                Msgsize,
                Multihop,
                Nametoolong,
                Netdown,
                Netreset,
                Netunreach,
                Nfile,
                Nobufs,
                Nodev,
                Noent,
                Noexec,
                Nolck,
                Nolink,
                Nomem,
                Nomsg,
                Noprotoopt,
                Nospc,
                Nosys,
                Notconn,
                Notdir,
                Notempty,
                Notrecoverable,
                Notsock,
                Notsup,
                Notty,
                Nxio,
                Overflow,
                Ownerdead,
                Perm,
                Pipe,
                Proto,
                Protonosupport,
                Prototype,
                Range,
                Rofs,
                Spipe,
                Srch,
                Stale,
                Timedout,
                Txtbsy,
                Xdev,
                Notcapable,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Errno {
                #[inline]
                fn clone(&self) -> Errno {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Errno {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Errno::Success => "Success",
                            Errno::TooBig => "TooBig",
                            Errno::Acces => "Acces",
                            Errno::Addrinuse => "Addrinuse",
                            Errno::Addrnotavail => "Addrnotavail",
                            Errno::Afnosupport => "Afnosupport",
                            Errno::Again => "Again",
                            Errno::Already => "Already",
                            Errno::Badf => "Badf",
                            Errno::Badmsg => "Badmsg",
                            Errno::Busy => "Busy",
                            Errno::Canceled => "Canceled",
                            Errno::Child => "Child",
                            Errno::Connaborted => "Connaborted",
                            Errno::Connrefused => "Connrefused",
                            Errno::Connreset => "Connreset",
                            Errno::Deadlk => "Deadlk",
                            Errno::Destaddrreq => "Destaddrreq",
                            Errno::Dom => "Dom",
                            Errno::Dquot => "Dquot",
                            Errno::Exist => "Exist",
                            Errno::Fault => "Fault",
                            Errno::Fbig => "Fbig",
                            Errno::Hostunreach => "Hostunreach",
                            Errno::Idrm => "Idrm",
                            Errno::Ilseq => "Ilseq",
                            Errno::Inprogress => "Inprogress",
                            Errno::Intr => "Intr",
                            Errno::Inval => "Inval",
                            Errno::Io => "Io",
                            Errno::Isconn => "Isconn",
                            Errno::Isdir => "Isdir",
                            Errno::Loop => "Loop",
                            Errno::Mfile => "Mfile",
                            Errno::Mlink => "Mlink",
                            Errno::Msgsize => "Msgsize",
                            Errno::Multihop => "Multihop",
                            Errno::Nametoolong => "Nametoolong",
                            Errno::Netdown => "Netdown",
                            Errno::Netreset => "Netreset",
                            Errno::Netunreach => "Netunreach",
                            Errno::Nfile => "Nfile",
                            Errno::Nobufs => "Nobufs",
                            Errno::Nodev => "Nodev",
                            Errno::Noent => "Noent",
                            Errno::Noexec => "Noexec",
                            Errno::Nolck => "Nolck",
                            Errno::Nolink => "Nolink",
                            Errno::Nomem => "Nomem",
                            Errno::Nomsg => "Nomsg",
                            Errno::Noprotoopt => "Noprotoopt",
                            Errno::Nospc => "Nospc",
                            Errno::Nosys => "Nosys",
                            Errno::Notconn => "Notconn",
                            Errno::Notdir => "Notdir",
                            Errno::Notempty => "Notempty",
                            Errno::Notrecoverable => "Notrecoverable",
                            Errno::Notsock => "Notsock",
                            Errno::Notsup => "Notsup",
                            Errno::Notty => "Notty",
                            Errno::Nxio => "Nxio",
                            Errno::Overflow => "Overflow",
                            Errno::Ownerdead => "Ownerdead",
                            Errno::Perm => "Perm",
                            Errno::Pipe => "Pipe",
                            Errno::Proto => "Proto",
                            Errno::Protonosupport => "Protonosupport",
                            Errno::Prototype => "Prototype",
                            Errno::Range => "Range",
                            Errno::Rofs => "Rofs",
                            Errno::Spipe => "Spipe",
                            Errno::Srch => "Srch",
                            Errno::Stale => "Stale",
                            Errno::Timedout => "Timedout",
                            Errno::Txtbsy => "Txtbsy",
                            Errno::Xdev => "Xdev",
                            Errno::Notcapable => "Notcapable",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Errno {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Errno {
                #[inline]
                fn eq(&self, other: &Errno) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Errno {}
            impl std::fmt::Display for Errno {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.write_fmt(format_args!("{0:?}", self))
                }
            }
            impl std::error::Error for Errno {}
            impl TryFrom<u16> for Errno {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Errno, wiggle::GuestError> {
                    match value {
                        0 => Ok(Errno::Success),
                        1 => Ok(Errno::TooBig),
                        2 => Ok(Errno::Acces),
                        3 => Ok(Errno::Addrinuse),
                        4 => Ok(Errno::Addrnotavail),
                        5 => Ok(Errno::Afnosupport),
                        6 => Ok(Errno::Again),
                        7 => Ok(Errno::Already),
                        8 => Ok(Errno::Badf),
                        9 => Ok(Errno::Badmsg),
                        10 => Ok(Errno::Busy),
                        11 => Ok(Errno::Canceled),
                        12 => Ok(Errno::Child),
                        13 => Ok(Errno::Connaborted),
                        14 => Ok(Errno::Connrefused),
                        15 => Ok(Errno::Connreset),
                        16 => Ok(Errno::Deadlk),
                        17 => Ok(Errno::Destaddrreq),
                        18 => Ok(Errno::Dom),
                        19 => Ok(Errno::Dquot),
                        20 => Ok(Errno::Exist),
                        21 => Ok(Errno::Fault),
                        22 => Ok(Errno::Fbig),
                        23 => Ok(Errno::Hostunreach),
                        24 => Ok(Errno::Idrm),
                        25 => Ok(Errno::Ilseq),
                        26 => Ok(Errno::Inprogress),
                        27 => Ok(Errno::Intr),
                        28 => Ok(Errno::Inval),
                        29 => Ok(Errno::Io),
                        30 => Ok(Errno::Isconn),
                        31 => Ok(Errno::Isdir),
                        32 => Ok(Errno::Loop),
                        33 => Ok(Errno::Mfile),
                        34 => Ok(Errno::Mlink),
                        35 => Ok(Errno::Msgsize),
                        36 => Ok(Errno::Multihop),
                        37 => Ok(Errno::Nametoolong),
                        38 => Ok(Errno::Netdown),
                        39 => Ok(Errno::Netreset),
                        40 => Ok(Errno::Netunreach),
                        41 => Ok(Errno::Nfile),
                        42 => Ok(Errno::Nobufs),
                        43 => Ok(Errno::Nodev),
                        44 => Ok(Errno::Noent),
                        45 => Ok(Errno::Noexec),
                        46 => Ok(Errno::Nolck),
                        47 => Ok(Errno::Nolink),
                        48 => Ok(Errno::Nomem),
                        49 => Ok(Errno::Nomsg),
                        50 => Ok(Errno::Noprotoopt),
                        51 => Ok(Errno::Nospc),
                        52 => Ok(Errno::Nosys),
                        53 => Ok(Errno::Notconn),
                        54 => Ok(Errno::Notdir),
                        55 => Ok(Errno::Notempty),
                        56 => Ok(Errno::Notrecoverable),
                        57 => Ok(Errno::Notsock),
                        58 => Ok(Errno::Notsup),
                        59 => Ok(Errno::Notty),
                        60 => Ok(Errno::Nxio),
                        61 => Ok(Errno::Overflow),
                        62 => Ok(Errno::Ownerdead),
                        63 => Ok(Errno::Perm),
                        64 => Ok(Errno::Pipe),
                        65 => Ok(Errno::Proto),
                        66 => Ok(Errno::Protonosupport),
                        67 => Ok(Errno::Prototype),
                        68 => Ok(Errno::Range),
                        69 => Ok(Errno::Rofs),
                        70 => Ok(Errno::Spipe),
                        71 => Ok(Errno::Srch),
                        72 => Ok(Errno::Stale),
                        73 => Ok(Errno::Timedout),
                        74 => Ok(Errno::Txtbsy),
                        75 => Ok(Errno::Xdev),
                        76 => Ok(Errno::Notcapable),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Errno")),
                    }
                }
            }
            impl TryFrom<i32> for Errno {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Errno, wiggle::GuestError> {
                    Errno::try_from(u16::try_from(value)?)
                }
            }
            impl From<Errno> for u16 {
                #[inline]
                fn from(v: Errno) -> u16 {
                    match v {
                        Errno::Success => 0,
                        Errno::TooBig => 1,
                        Errno::Acces => 2,
                        Errno::Addrinuse => 3,
                        Errno::Addrnotavail => 4,
                        Errno::Afnosupport => 5,
                        Errno::Again => 6,
                        Errno::Already => 7,
                        Errno::Badf => 8,
                        Errno::Badmsg => 9,
                        Errno::Busy => 10,
                        Errno::Canceled => 11,
                        Errno::Child => 12,
                        Errno::Connaborted => 13,
                        Errno::Connrefused => 14,
                        Errno::Connreset => 15,
                        Errno::Deadlk => 16,
                        Errno::Destaddrreq => 17,
                        Errno::Dom => 18,
                        Errno::Dquot => 19,
                        Errno::Exist => 20,
                        Errno::Fault => 21,
                        Errno::Fbig => 22,
                        Errno::Hostunreach => 23,
                        Errno::Idrm => 24,
                        Errno::Ilseq => 25,
                        Errno::Inprogress => 26,
                        Errno::Intr => 27,
                        Errno::Inval => 28,
                        Errno::Io => 29,
                        Errno::Isconn => 30,
                        Errno::Isdir => 31,
                        Errno::Loop => 32,
                        Errno::Mfile => 33,
                        Errno::Mlink => 34,
                        Errno::Msgsize => 35,
                        Errno::Multihop => 36,
                        Errno::Nametoolong => 37,
                        Errno::Netdown => 38,
                        Errno::Netreset => 39,
                        Errno::Netunreach => 40,
                        Errno::Nfile => 41,
                        Errno::Nobufs => 42,
                        Errno::Nodev => 43,
                        Errno::Noent => 44,
                        Errno::Noexec => 45,
                        Errno::Nolck => 46,
                        Errno::Nolink => 47,
                        Errno::Nomem => 48,
                        Errno::Nomsg => 49,
                        Errno::Noprotoopt => 50,
                        Errno::Nospc => 51,
                        Errno::Nosys => 52,
                        Errno::Notconn => 53,
                        Errno::Notdir => 54,
                        Errno::Notempty => 55,
                        Errno::Notrecoverable => 56,
                        Errno::Notsock => 57,
                        Errno::Notsup => 58,
                        Errno::Notty => 59,
                        Errno::Nxio => 60,
                        Errno::Overflow => 61,
                        Errno::Ownerdead => 62,
                        Errno::Perm => 63,
                        Errno::Pipe => 64,
                        Errno::Proto => 65,
                        Errno::Protonosupport => 66,
                        Errno::Prototype => 67,
                        Errno::Range => 68,
                        Errno::Rofs => 69,
                        Errno::Spipe => 70,
                        Errno::Srch => 71,
                        Errno::Stale => 72,
                        Errno::Timedout => 73,
                        Errno::Txtbsy => 74,
                        Errno::Xdev => 75,
                        Errno::Notcapable => 76,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Errno {
                #[inline]
                fn guest_size() -> u32 {
                    2u32
                }
                #[inline]
                fn guest_align() -> usize {
                    2usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u16>().read()?;
                    match tag {
                        0 => Ok(Errno::Success),
                        1 => Ok(Errno::TooBig),
                        2 => Ok(Errno::Acces),
                        3 => Ok(Errno::Addrinuse),
                        4 => Ok(Errno::Addrnotavail),
                        5 => Ok(Errno::Afnosupport),
                        6 => Ok(Errno::Again),
                        7 => Ok(Errno::Already),
                        8 => Ok(Errno::Badf),
                        9 => Ok(Errno::Badmsg),
                        10 => Ok(Errno::Busy),
                        11 => Ok(Errno::Canceled),
                        12 => Ok(Errno::Child),
                        13 => Ok(Errno::Connaborted),
                        14 => Ok(Errno::Connrefused),
                        15 => Ok(Errno::Connreset),
                        16 => Ok(Errno::Deadlk),
                        17 => Ok(Errno::Destaddrreq),
                        18 => Ok(Errno::Dom),
                        19 => Ok(Errno::Dquot),
                        20 => Ok(Errno::Exist),
                        21 => Ok(Errno::Fault),
                        22 => Ok(Errno::Fbig),
                        23 => Ok(Errno::Hostunreach),
                        24 => Ok(Errno::Idrm),
                        25 => Ok(Errno::Ilseq),
                        26 => Ok(Errno::Inprogress),
                        27 => Ok(Errno::Intr),
                        28 => Ok(Errno::Inval),
                        29 => Ok(Errno::Io),
                        30 => Ok(Errno::Isconn),
                        31 => Ok(Errno::Isdir),
                        32 => Ok(Errno::Loop),
                        33 => Ok(Errno::Mfile),
                        34 => Ok(Errno::Mlink),
                        35 => Ok(Errno::Msgsize),
                        36 => Ok(Errno::Multihop),
                        37 => Ok(Errno::Nametoolong),
                        38 => Ok(Errno::Netdown),
                        39 => Ok(Errno::Netreset),
                        40 => Ok(Errno::Netunreach),
                        41 => Ok(Errno::Nfile),
                        42 => Ok(Errno::Nobufs),
                        43 => Ok(Errno::Nodev),
                        44 => Ok(Errno::Noent),
                        45 => Ok(Errno::Noexec),
                        46 => Ok(Errno::Nolck),
                        47 => Ok(Errno::Nolink),
                        48 => Ok(Errno::Nomem),
                        49 => Ok(Errno::Nomsg),
                        50 => Ok(Errno::Noprotoopt),
                        51 => Ok(Errno::Nospc),
                        52 => Ok(Errno::Nosys),
                        53 => Ok(Errno::Notconn),
                        54 => Ok(Errno::Notdir),
                        55 => Ok(Errno::Notempty),
                        56 => Ok(Errno::Notrecoverable),
                        57 => Ok(Errno::Notsock),
                        58 => Ok(Errno::Notsup),
                        59 => Ok(Errno::Notty),
                        60 => Ok(Errno::Nxio),
                        61 => Ok(Errno::Overflow),
                        62 => Ok(Errno::Ownerdead),
                        63 => Ok(Errno::Perm),
                        64 => Ok(Errno::Pipe),
                        65 => Ok(Errno::Proto),
                        66 => Ok(Errno::Protonosupport),
                        67 => Ok(Errno::Prototype),
                        68 => Ok(Errno::Range),
                        69 => Ok(Errno::Rofs),
                        70 => Ok(Errno::Spipe),
                        71 => Ok(Errno::Srch),
                        72 => Ok(Errno::Stale),
                        73 => Ok(Errno::Timedout),
                        74 => Ok(Errno::Txtbsy),
                        75 => Ok(Errno::Xdev),
                        76 => Ok(Errno::Notcapable),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Errno")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Errno::Success => {
                            location.cast().write(0usize as u16)?;
                        }
                        Errno::TooBig => {
                            location.cast().write(1usize as u16)?;
                        }
                        Errno::Acces => {
                            location.cast().write(2usize as u16)?;
                        }
                        Errno::Addrinuse => {
                            location.cast().write(3usize as u16)?;
                        }
                        Errno::Addrnotavail => {
                            location.cast().write(4usize as u16)?;
                        }
                        Errno::Afnosupport => {
                            location.cast().write(5usize as u16)?;
                        }
                        Errno::Again => {
                            location.cast().write(6usize as u16)?;
                        }
                        Errno::Already => {
                            location.cast().write(7usize as u16)?;
                        }
                        Errno::Badf => {
                            location.cast().write(8usize as u16)?;
                        }
                        Errno::Badmsg => {
                            location.cast().write(9usize as u16)?;
                        }
                        Errno::Busy => {
                            location.cast().write(10usize as u16)?;
                        }
                        Errno::Canceled => {
                            location.cast().write(11usize as u16)?;
                        }
                        Errno::Child => {
                            location.cast().write(12usize as u16)?;
                        }
                        Errno::Connaborted => {
                            location.cast().write(13usize as u16)?;
                        }
                        Errno::Connrefused => {
                            location.cast().write(14usize as u16)?;
                        }
                        Errno::Connreset => {
                            location.cast().write(15usize as u16)?;
                        }
                        Errno::Deadlk => {
                            location.cast().write(16usize as u16)?;
                        }
                        Errno::Destaddrreq => {
                            location.cast().write(17usize as u16)?;
                        }
                        Errno::Dom => {
                            location.cast().write(18usize as u16)?;
                        }
                        Errno::Dquot => {
                            location.cast().write(19usize as u16)?;
                        }
                        Errno::Exist => {
                            location.cast().write(20usize as u16)?;
                        }
                        Errno::Fault => {
                            location.cast().write(21usize as u16)?;
                        }
                        Errno::Fbig => {
                            location.cast().write(22usize as u16)?;
                        }
                        Errno::Hostunreach => {
                            location.cast().write(23usize as u16)?;
                        }
                        Errno::Idrm => {
                            location.cast().write(24usize as u16)?;
                        }
                        Errno::Ilseq => {
                            location.cast().write(25usize as u16)?;
                        }
                        Errno::Inprogress => {
                            location.cast().write(26usize as u16)?;
                        }
                        Errno::Intr => {
                            location.cast().write(27usize as u16)?;
                        }
                        Errno::Inval => {
                            location.cast().write(28usize as u16)?;
                        }
                        Errno::Io => {
                            location.cast().write(29usize as u16)?;
                        }
                        Errno::Isconn => {
                            location.cast().write(30usize as u16)?;
                        }
                        Errno::Isdir => {
                            location.cast().write(31usize as u16)?;
                        }
                        Errno::Loop => {
                            location.cast().write(32usize as u16)?;
                        }
                        Errno::Mfile => {
                            location.cast().write(33usize as u16)?;
                        }
                        Errno::Mlink => {
                            location.cast().write(34usize as u16)?;
                        }
                        Errno::Msgsize => {
                            location.cast().write(35usize as u16)?;
                        }
                        Errno::Multihop => {
                            location.cast().write(36usize as u16)?;
                        }
                        Errno::Nametoolong => {
                            location.cast().write(37usize as u16)?;
                        }
                        Errno::Netdown => {
                            location.cast().write(38usize as u16)?;
                        }
                        Errno::Netreset => {
                            location.cast().write(39usize as u16)?;
                        }
                        Errno::Netunreach => {
                            location.cast().write(40usize as u16)?;
                        }
                        Errno::Nfile => {
                            location.cast().write(41usize as u16)?;
                        }
                        Errno::Nobufs => {
                            location.cast().write(42usize as u16)?;
                        }
                        Errno::Nodev => {
                            location.cast().write(43usize as u16)?;
                        }
                        Errno::Noent => {
                            location.cast().write(44usize as u16)?;
                        }
                        Errno::Noexec => {
                            location.cast().write(45usize as u16)?;
                        }
                        Errno::Nolck => {
                            location.cast().write(46usize as u16)?;
                        }
                        Errno::Nolink => {
                            location.cast().write(47usize as u16)?;
                        }
                        Errno::Nomem => {
                            location.cast().write(48usize as u16)?;
                        }
                        Errno::Nomsg => {
                            location.cast().write(49usize as u16)?;
                        }
                        Errno::Noprotoopt => {
                            location.cast().write(50usize as u16)?;
                        }
                        Errno::Nospc => {
                            location.cast().write(51usize as u16)?;
                        }
                        Errno::Nosys => {
                            location.cast().write(52usize as u16)?;
                        }
                        Errno::Notconn => {
                            location.cast().write(53usize as u16)?;
                        }
                        Errno::Notdir => {
                            location.cast().write(54usize as u16)?;
                        }
                        Errno::Notempty => {
                            location.cast().write(55usize as u16)?;
                        }
                        Errno::Notrecoverable => {
                            location.cast().write(56usize as u16)?;
                        }
                        Errno::Notsock => {
                            location.cast().write(57usize as u16)?;
                        }
                        Errno::Notsup => {
                            location.cast().write(58usize as u16)?;
                        }
                        Errno::Notty => {
                            location.cast().write(59usize as u16)?;
                        }
                        Errno::Nxio => {
                            location.cast().write(60usize as u16)?;
                        }
                        Errno::Overflow => {
                            location.cast().write(61usize as u16)?;
                        }
                        Errno::Ownerdead => {
                            location.cast().write(62usize as u16)?;
                        }
                        Errno::Perm => {
                            location.cast().write(63usize as u16)?;
                        }
                        Errno::Pipe => {
                            location.cast().write(64usize as u16)?;
                        }
                        Errno::Proto => {
                            location.cast().write(65usize as u16)?;
                        }
                        Errno::Protonosupport => {
                            location.cast().write(66usize as u16)?;
                        }
                        Errno::Prototype => {
                            location.cast().write(67usize as u16)?;
                        }
                        Errno::Range => {
                            location.cast().write(68usize as u16)?;
                        }
                        Errno::Rofs => {
                            location.cast().write(69usize as u16)?;
                        }
                        Errno::Spipe => {
                            location.cast().write(70usize as u16)?;
                        }
                        Errno::Srch => {
                            location.cast().write(71usize as u16)?;
                        }
                        Errno::Stale => {
                            location.cast().write(72usize as u16)?;
                        }
                        Errno::Timedout => {
                            location.cast().write(73usize as u16)?;
                        }
                        Errno::Txtbsy => {
                            location.cast().write(74usize as u16)?;
                        }
                        Errno::Xdev => {
                            location.cast().write(75usize as u16)?;
                        }
                        Errno::Notcapable => {
                            location.cast().write(76usize as u16)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Error {
                inner: anyhow::Error,
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Error {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "Error",
                        "inner",
                        &&self.inner,
                    )
                }
            }
            impl std::fmt::Display for Error {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    f.write_fmt(format_args!("{0}", self.inner))
                }
            }
            impl std::error::Error for Error {
                fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
                    self.inner.source()
                }
            }
            impl Error {
                pub fn trap(inner: anyhow::Error) -> Error {
                    Self { inner }
                }
                pub fn downcast(self) -> Result<Errno, anyhow::Error> {
                    self.inner.downcast()
                }
                pub fn downcast_ref(&self) -> Option<&Errno> {
                    self.inner.downcast_ref()
                }
                pub fn context(self, s: impl Into<String>) -> Self {
                    Self {
                        inner: self.inner.context(s.into()),
                    }
                }
            }
            impl From<Errno> for Error {
                fn from(abi: Errno) -> Error {
                    Error {
                        inner: anyhow::Error::from(abi),
                    }
                }
            }
            pub struct Rights {
                bits: u64,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Rights {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Rights {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Rights {
                #[inline]
                fn eq(&self, other: &Rights) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Rights {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Rights {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Rights {
                #[inline]
                fn clone(&self) -> Rights {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Rights {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Rights,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Rights {
                #[inline]
                fn cmp(&self, other: &Rights) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Rights {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn FD_DATASYNC(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_READ(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_SEEK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_FDSTAT_SET_FLAGS(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_SYNC(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_TELL(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_WRITE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_ADVISE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_ALLOCATE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_CREATE_DIRECTORY(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_CREATE_FILE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_LINK_SOURCE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_LINK_TARGET(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_OPEN(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_READDIR(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_READLINK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_RENAME_SOURCE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_RENAME_TARGET(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_FILESTAT_GET(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_FILESTAT_SET_SIZE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_FILESTAT_SET_TIMES(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_FILESTAT_GET(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_FILESTAT_SET_SIZE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn FD_FILESTAT_SET_TIMES(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_SYMLINK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_REMOVE_DIRECTORY(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn PATH_UNLINK_FILE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn POLL_FD_READWRITE(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn SOCK_SHUTDOWN(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn SOCK_ACCEPT(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Rights {
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_DATASYNC(&self) -> bool {
                            if Self::FD_DATASYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_DATASYNC.bits == Self::FD_DATASYNC.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_READ(&self) -> bool {
                            if Self::FD_READ.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_READ.bits == Self::FD_READ.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_SEEK(&self) -> bool {
                            if Self::FD_SEEK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_SEEK.bits == Self::FD_SEEK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_FDSTAT_SET_FLAGS(&self) -> bool {
                            if Self::FD_FDSTAT_SET_FLAGS.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_FDSTAT_SET_FLAGS.bits
                                    == Self::FD_FDSTAT_SET_FLAGS.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_SYNC(&self) -> bool {
                            if Self::FD_SYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_SYNC.bits == Self::FD_SYNC.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_TELL(&self) -> bool {
                            if Self::FD_TELL.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_TELL.bits == Self::FD_TELL.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_WRITE(&self) -> bool {
                            if Self::FD_WRITE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_WRITE.bits == Self::FD_WRITE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_ADVISE(&self) -> bool {
                            if Self::FD_ADVISE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_ADVISE.bits == Self::FD_ADVISE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_ALLOCATE(&self) -> bool {
                            if Self::FD_ALLOCATE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_ALLOCATE.bits == Self::FD_ALLOCATE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_CREATE_DIRECTORY(&self) -> bool {
                            if Self::PATH_CREATE_DIRECTORY.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_CREATE_DIRECTORY.bits
                                    == Self::PATH_CREATE_DIRECTORY.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_CREATE_FILE(&self) -> bool {
                            if Self::PATH_CREATE_FILE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_CREATE_FILE.bits
                                    == Self::PATH_CREATE_FILE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_LINK_SOURCE(&self) -> bool {
                            if Self::PATH_LINK_SOURCE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_LINK_SOURCE.bits
                                    == Self::PATH_LINK_SOURCE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_LINK_TARGET(&self) -> bool {
                            if Self::PATH_LINK_TARGET.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_LINK_TARGET.bits
                                    == Self::PATH_LINK_TARGET.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_OPEN(&self) -> bool {
                            if Self::PATH_OPEN.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_OPEN.bits == Self::PATH_OPEN.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_READDIR(&self) -> bool {
                            if Self::FD_READDIR.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_READDIR.bits == Self::FD_READDIR.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_READLINK(&self) -> bool {
                            if Self::PATH_READLINK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_READLINK.bits
                                    == Self::PATH_READLINK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_RENAME_SOURCE(&self) -> bool {
                            if Self::PATH_RENAME_SOURCE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_RENAME_SOURCE.bits
                                    == Self::PATH_RENAME_SOURCE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_RENAME_TARGET(&self) -> bool {
                            if Self::PATH_RENAME_TARGET.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_RENAME_TARGET.bits
                                    == Self::PATH_RENAME_TARGET.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_FILESTAT_GET(&self) -> bool {
                            if Self::PATH_FILESTAT_GET.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_FILESTAT_GET.bits
                                    == Self::PATH_FILESTAT_GET.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_FILESTAT_SET_SIZE(&self) -> bool {
                            if Self::PATH_FILESTAT_SET_SIZE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_FILESTAT_SET_SIZE.bits
                                    == Self::PATH_FILESTAT_SET_SIZE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_FILESTAT_SET_TIMES(&self) -> bool {
                            if Self::PATH_FILESTAT_SET_TIMES.bits == 0 && self.bits != 0
                            {
                                false
                            } else {
                                self.bits & Self::PATH_FILESTAT_SET_TIMES.bits
                                    == Self::PATH_FILESTAT_SET_TIMES.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_FILESTAT_GET(&self) -> bool {
                            if Self::FD_FILESTAT_GET.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_FILESTAT_GET.bits
                                    == Self::FD_FILESTAT_GET.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_FILESTAT_SET_SIZE(&self) -> bool {
                            if Self::FD_FILESTAT_SET_SIZE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_FILESTAT_SET_SIZE.bits
                                    == Self::FD_FILESTAT_SET_SIZE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_FILESTAT_SET_TIMES(&self) -> bool {
                            if Self::FD_FILESTAT_SET_TIMES.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_FILESTAT_SET_TIMES.bits
                                    == Self::FD_FILESTAT_SET_TIMES.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_SYMLINK(&self) -> bool {
                            if Self::PATH_SYMLINK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_SYMLINK.bits
                                    == Self::PATH_SYMLINK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_REMOVE_DIRECTORY(&self) -> bool {
                            if Self::PATH_REMOVE_DIRECTORY.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_REMOVE_DIRECTORY.bits
                                    == Self::PATH_REMOVE_DIRECTORY.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn PATH_UNLINK_FILE(&self) -> bool {
                            if Self::PATH_UNLINK_FILE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::PATH_UNLINK_FILE.bits
                                    == Self::PATH_UNLINK_FILE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn POLL_FD_READWRITE(&self) -> bool {
                            if Self::POLL_FD_READWRITE.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::POLL_FD_READWRITE.bits
                                    == Self::POLL_FD_READWRITE.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn SOCK_SHUTDOWN(&self) -> bool {
                            if Self::SOCK_SHUTDOWN.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::SOCK_SHUTDOWN.bits
                                    == Self::SOCK_SHUTDOWN.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn SOCK_ACCEPT(&self) -> bool {
                            if Self::SOCK_ACCEPT.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::SOCK_ACCEPT.bits == Self::SOCK_ACCEPT.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::FD_DATASYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_DATASYNC")?;
                    }
                    if <Self as __BitFlags>::FD_READ(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_READ")?;
                    }
                    if <Self as __BitFlags>::FD_SEEK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_SEEK")?;
                    }
                    if <Self as __BitFlags>::FD_FDSTAT_SET_FLAGS(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_FDSTAT_SET_FLAGS")?;
                    }
                    if <Self as __BitFlags>::FD_SYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_SYNC")?;
                    }
                    if <Self as __BitFlags>::FD_TELL(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_TELL")?;
                    }
                    if <Self as __BitFlags>::FD_WRITE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_WRITE")?;
                    }
                    if <Self as __BitFlags>::FD_ADVISE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_ADVISE")?;
                    }
                    if <Self as __BitFlags>::FD_ALLOCATE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_ALLOCATE")?;
                    }
                    if <Self as __BitFlags>::PATH_CREATE_DIRECTORY(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_CREATE_DIRECTORY")?;
                    }
                    if <Self as __BitFlags>::PATH_CREATE_FILE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_CREATE_FILE")?;
                    }
                    if <Self as __BitFlags>::PATH_LINK_SOURCE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_LINK_SOURCE")?;
                    }
                    if <Self as __BitFlags>::PATH_LINK_TARGET(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_LINK_TARGET")?;
                    }
                    if <Self as __BitFlags>::PATH_OPEN(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_OPEN")?;
                    }
                    if <Self as __BitFlags>::FD_READDIR(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_READDIR")?;
                    }
                    if <Self as __BitFlags>::PATH_READLINK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_READLINK")?;
                    }
                    if <Self as __BitFlags>::PATH_RENAME_SOURCE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_RENAME_SOURCE")?;
                    }
                    if <Self as __BitFlags>::PATH_RENAME_TARGET(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_RENAME_TARGET")?;
                    }
                    if <Self as __BitFlags>::PATH_FILESTAT_GET(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_FILESTAT_GET")?;
                    }
                    if <Self as __BitFlags>::PATH_FILESTAT_SET_SIZE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_FILESTAT_SET_SIZE")?;
                    }
                    if <Self as __BitFlags>::PATH_FILESTAT_SET_TIMES(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_FILESTAT_SET_TIMES")?;
                    }
                    if <Self as __BitFlags>::FD_FILESTAT_GET(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_FILESTAT_GET")?;
                    }
                    if <Self as __BitFlags>::FD_FILESTAT_SET_SIZE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_FILESTAT_SET_SIZE")?;
                    }
                    if <Self as __BitFlags>::FD_FILESTAT_SET_TIMES(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_FILESTAT_SET_TIMES")?;
                    }
                    if <Self as __BitFlags>::PATH_SYMLINK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_SYMLINK")?;
                    }
                    if <Self as __BitFlags>::PATH_REMOVE_DIRECTORY(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_REMOVE_DIRECTORY")?;
                    }
                    if <Self as __BitFlags>::PATH_UNLINK_FILE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("PATH_UNLINK_FILE")?;
                    }
                    if <Self as __BitFlags>::POLL_FD_READWRITE(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("POLL_FD_READWRITE")?;
                    }
                    if <Self as __BitFlags>::SOCK_SHUTDOWN(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SOCK_SHUTDOWN")?;
                    }
                    if <Self as __BitFlags>::SOCK_ACCEPT(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SOCK_ACCEPT")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Rights {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Rights {
                pub const FD_DATASYNC: Self = Self { bits: 1 };
                pub const FD_READ: Self = Self { bits: 2 };
                pub const FD_SEEK: Self = Self { bits: 4 };
                pub const FD_FDSTAT_SET_FLAGS: Self = Self { bits: 8 };
                pub const FD_SYNC: Self = Self { bits: 16 };
                pub const FD_TELL: Self = Self { bits: 32 };
                pub const FD_WRITE: Self = Self { bits: 64 };
                pub const FD_ADVISE: Self = Self { bits: 128 };
                pub const FD_ALLOCATE: Self = Self { bits: 256 };
                pub const PATH_CREATE_DIRECTORY: Self = Self { bits: 512 };
                pub const PATH_CREATE_FILE: Self = Self { bits: 1024 };
                pub const PATH_LINK_SOURCE: Self = Self { bits: 2048 };
                pub const PATH_LINK_TARGET: Self = Self { bits: 4096 };
                pub const PATH_OPEN: Self = Self { bits: 8192 };
                pub const FD_READDIR: Self = Self { bits: 16384 };
                pub const PATH_READLINK: Self = Self { bits: 32768 };
                pub const PATH_RENAME_SOURCE: Self = Self { bits: 65536 };
                pub const PATH_RENAME_TARGET: Self = Self { bits: 131072 };
                pub const PATH_FILESTAT_GET: Self = Self { bits: 262144 };
                pub const PATH_FILESTAT_SET_SIZE: Self = Self { bits: 524288 };
                pub const PATH_FILESTAT_SET_TIMES: Self = Self { bits: 1048576 };
                pub const FD_FILESTAT_GET: Self = Self { bits: 2097152 };
                pub const FD_FILESTAT_SET_SIZE: Self = Self { bits: 4194304 };
                pub const FD_FILESTAT_SET_TIMES: Self = Self { bits: 8388608 };
                pub const PATH_SYMLINK: Self = Self { bits: 16777216 };
                pub const PATH_REMOVE_DIRECTORY: Self = Self { bits: 33554432 };
                pub const PATH_UNLINK_FILE: Self = Self { bits: 67108864 };
                pub const POLL_FD_READWRITE: Self = Self { bits: 134217728 };
                pub const SOCK_SHUTDOWN: Self = Self { bits: 268435456 };
                pub const SOCK_ACCEPT: Self = Self { bits: 536870912 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const FD_DATASYNC: u64 = 0;
                        const FD_READ: u64 = 0;
                        const FD_SEEK: u64 = 0;
                        const FD_FDSTAT_SET_FLAGS: u64 = 0;
                        const FD_SYNC: u64 = 0;
                        const FD_TELL: u64 = 0;
                        const FD_WRITE: u64 = 0;
                        const FD_ADVISE: u64 = 0;
                        const FD_ALLOCATE: u64 = 0;
                        const PATH_CREATE_DIRECTORY: u64 = 0;
                        const PATH_CREATE_FILE: u64 = 0;
                        const PATH_LINK_SOURCE: u64 = 0;
                        const PATH_LINK_TARGET: u64 = 0;
                        const PATH_OPEN: u64 = 0;
                        const FD_READDIR: u64 = 0;
                        const PATH_READLINK: u64 = 0;
                        const PATH_RENAME_SOURCE: u64 = 0;
                        const PATH_RENAME_TARGET: u64 = 0;
                        const PATH_FILESTAT_GET: u64 = 0;
                        const PATH_FILESTAT_SET_SIZE: u64 = 0;
                        const PATH_FILESTAT_SET_TIMES: u64 = 0;
                        const FD_FILESTAT_GET: u64 = 0;
                        const FD_FILESTAT_SET_SIZE: u64 = 0;
                        const FD_FILESTAT_SET_TIMES: u64 = 0;
                        const PATH_SYMLINK: u64 = 0;
                        const PATH_REMOVE_DIRECTORY: u64 = 0;
                        const PATH_UNLINK_FILE: u64 = 0;
                        const POLL_FD_READWRITE: u64 = 0;
                        const SOCK_SHUTDOWN: u64 = 0;
                        const SOCK_ACCEPT: u64 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Rights {
                        #[allow(deprecated)]
                        const FD_DATASYNC: u64 = Self::FD_DATASYNC.bits;
                        #[allow(deprecated)]
                        const FD_READ: u64 = Self::FD_READ.bits;
                        #[allow(deprecated)]
                        const FD_SEEK: u64 = Self::FD_SEEK.bits;
                        #[allow(deprecated)]
                        const FD_FDSTAT_SET_FLAGS: u64 = Self::FD_FDSTAT_SET_FLAGS.bits;
                        #[allow(deprecated)]
                        const FD_SYNC: u64 = Self::FD_SYNC.bits;
                        #[allow(deprecated)]
                        const FD_TELL: u64 = Self::FD_TELL.bits;
                        #[allow(deprecated)]
                        const FD_WRITE: u64 = Self::FD_WRITE.bits;
                        #[allow(deprecated)]
                        const FD_ADVISE: u64 = Self::FD_ADVISE.bits;
                        #[allow(deprecated)]
                        const FD_ALLOCATE: u64 = Self::FD_ALLOCATE.bits;
                        #[allow(deprecated)]
                        const PATH_CREATE_DIRECTORY: u64 = Self::PATH_CREATE_DIRECTORY
                            .bits;
                        #[allow(deprecated)]
                        const PATH_CREATE_FILE: u64 = Self::PATH_CREATE_FILE.bits;
                        #[allow(deprecated)]
                        const PATH_LINK_SOURCE: u64 = Self::PATH_LINK_SOURCE.bits;
                        #[allow(deprecated)]
                        const PATH_LINK_TARGET: u64 = Self::PATH_LINK_TARGET.bits;
                        #[allow(deprecated)]
                        const PATH_OPEN: u64 = Self::PATH_OPEN.bits;
                        #[allow(deprecated)]
                        const FD_READDIR: u64 = Self::FD_READDIR.bits;
                        #[allow(deprecated)]
                        const PATH_READLINK: u64 = Self::PATH_READLINK.bits;
                        #[allow(deprecated)]
                        const PATH_RENAME_SOURCE: u64 = Self::PATH_RENAME_SOURCE.bits;
                        #[allow(deprecated)]
                        const PATH_RENAME_TARGET: u64 = Self::PATH_RENAME_TARGET.bits;
                        #[allow(deprecated)]
                        const PATH_FILESTAT_GET: u64 = Self::PATH_FILESTAT_GET.bits;
                        #[allow(deprecated)]
                        const PATH_FILESTAT_SET_SIZE: u64 = Self::PATH_FILESTAT_SET_SIZE
                            .bits;
                        #[allow(deprecated)]
                        const PATH_FILESTAT_SET_TIMES: u64 = Self::PATH_FILESTAT_SET_TIMES
                            .bits;
                        #[allow(deprecated)]
                        const FD_FILESTAT_GET: u64 = Self::FD_FILESTAT_GET.bits;
                        #[allow(deprecated)]
                        const FD_FILESTAT_SET_SIZE: u64 = Self::FD_FILESTAT_SET_SIZE
                            .bits;
                        #[allow(deprecated)]
                        const FD_FILESTAT_SET_TIMES: u64 = Self::FD_FILESTAT_SET_TIMES
                            .bits;
                        #[allow(deprecated)]
                        const PATH_SYMLINK: u64 = Self::PATH_SYMLINK.bits;
                        #[allow(deprecated)]
                        const PATH_REMOVE_DIRECTORY: u64 = Self::PATH_REMOVE_DIRECTORY
                            .bits;
                        #[allow(deprecated)]
                        const PATH_UNLINK_FILE: u64 = Self::PATH_UNLINK_FILE.bits;
                        #[allow(deprecated)]
                        const POLL_FD_READWRITE: u64 = Self::POLL_FD_READWRITE.bits;
                        #[allow(deprecated)]
                        const SOCK_SHUTDOWN: u64 = Self::SOCK_SHUTDOWN.bits;
                        #[allow(deprecated)]
                        const SOCK_ACCEPT: u64 = Self::SOCK_ACCEPT.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::FD_DATASYNC
                            | <Self as __BitFlags>::FD_READ
                            | <Self as __BitFlags>::FD_SEEK
                            | <Self as __BitFlags>::FD_FDSTAT_SET_FLAGS
                            | <Self as __BitFlags>::FD_SYNC
                            | <Self as __BitFlags>::FD_TELL
                            | <Self as __BitFlags>::FD_WRITE
                            | <Self as __BitFlags>::FD_ADVISE
                            | <Self as __BitFlags>::FD_ALLOCATE
                            | <Self as __BitFlags>::PATH_CREATE_DIRECTORY
                            | <Self as __BitFlags>::PATH_CREATE_FILE
                            | <Self as __BitFlags>::PATH_LINK_SOURCE
                            | <Self as __BitFlags>::PATH_LINK_TARGET
                            | <Self as __BitFlags>::PATH_OPEN
                            | <Self as __BitFlags>::FD_READDIR
                            | <Self as __BitFlags>::PATH_READLINK
                            | <Self as __BitFlags>::PATH_RENAME_SOURCE
                            | <Self as __BitFlags>::PATH_RENAME_TARGET
                            | <Self as __BitFlags>::PATH_FILESTAT_GET
                            | <Self as __BitFlags>::PATH_FILESTAT_SET_SIZE
                            | <Self as __BitFlags>::PATH_FILESTAT_SET_TIMES
                            | <Self as __BitFlags>::FD_FILESTAT_GET
                            | <Self as __BitFlags>::FD_FILESTAT_SET_SIZE
                            | <Self as __BitFlags>::FD_FILESTAT_SET_TIMES
                            | <Self as __BitFlags>::PATH_SYMLINK
                            | <Self as __BitFlags>::PATH_REMOVE_DIRECTORY
                            | <Self as __BitFlags>::PATH_UNLINK_FILE
                            | <Self as __BitFlags>::POLL_FD_READWRITE
                            | <Self as __BitFlags>::SOCK_SHUTDOWN
                            | <Self as __BitFlags>::SOCK_ACCEPT,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u64 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u64,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u64) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u64) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Rights {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Rights) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Rights {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Rights {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Rights {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Rights {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Rights {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Rights {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Rights {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Rights {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Rights> for Rights {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Rights> for Rights {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Rights {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Rights")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u64> for Rights {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u64) -> Result<Self, wiggle::GuestError> {
                    if u64::from(!Rights::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Rights"))
                    } else {
                        Ok(Rights { bits: value })
                    }
                }
            }
            impl TryFrom<i64> for Rights {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i64) -> Result<Self, wiggle::GuestError> {
                    Rights::try_from(u64::try_from(value)?)
                }
            }
            impl From<Rights> for u64 {
                #[inline]
                fn from(e: Rights) -> u64 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Rights {
                #[inline]
                fn guest_size() -> u32 {
                    u64::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u64::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Rights>,
                ) -> Result<Rights, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u64::read(&location.cast())?;
                    let value = Rights::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Rights>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u64 = u64::from(val);
                    u64::write(&location.cast(), val)
                }
            }
            #[repr(transparent)]
            pub struct Fd(u32);
            #[automatically_derived]
            impl ::core::marker::Copy for Fd {}
            #[automatically_derived]
            impl ::core::clone::Clone for Fd {
                #[inline]
                fn clone(&self) -> Fd {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Fd {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Fd", &&self.0)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Fd {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.0, state)
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Fd {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Fd {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Fd {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Fd {
                #[inline]
                fn eq(&self, other: &Fd) -> bool {
                    self.0 == other.0
                }
            }
            impl Fd {
                #[inline]
                pub unsafe fn inner(&self) -> u32 {
                    self.0
                }
            }
            impl From<Fd> for u32 {
                #[inline]
                fn from(e: Fd) -> u32 {
                    e.0
                }
            }
            impl From<Fd> for i32 {
                #[inline]
                fn from(e: Fd) -> i32 {
                    e.0 as i32
                }
            }
            impl From<u32> for Fd {
                #[inline]
                fn from(e: u32) -> Fd {
                    Fd(e)
                }
            }
            impl From<i32> for Fd {
                #[inline]
                fn from(e: i32) -> Fd {
                    Fd(e as u32)
                }
            }
            impl ::std::fmt::Display for Fd {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_fmt(format_args!("{0}({1})", "Fd", self.0))
                }
            }
            impl<'a> wiggle::GuestType<'a> for Fd {
                #[inline]
                fn guest_size() -> u32 {
                    4u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                #[inline]
                fn read(
                    location: &wiggle::GuestPtr<'a, Fd>,
                ) -> Result<Fd, wiggle::GuestError> {
                    Ok(Fd(u32::read(&location.cast())?))
                }
                #[inline]
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    u32::write(&location.cast(), val.0)
                }
            }
            pub struct Iovec<'a> {
                pub buf: wiggle::GuestPtr<'a, u8>,
                pub buf_len: Size,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for Iovec<'a> {
                #[inline]
                fn clone(&self) -> Iovec<'a> {
                    Iovec {
                        buf: ::core::clone::Clone::clone(&self.buf),
                        buf_len: ::core::clone::Clone::clone(&self.buf_len),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for Iovec<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Iovec",
                        "buf",
                        &self.buf,
                        "buf_len",
                        &&self.buf_len,
                    )
                }
            }
            impl<'a> wiggle::GuestType<'a> for Iovec<'a> {
                #[inline]
                fn guest_size() -> u32 {
                    8u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let buf = <wiggle::GuestPtr<
                        u8,
                    > as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let buf_len = <Size as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(4u32)?.cast(),
                    )?;
                    Ok(Iovec { buf, buf_len })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.buf,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(4u32)?.cast(),
                        val.buf_len,
                    )?;
                    Ok(())
                }
            }
            pub struct Ciovec<'a> {
                pub buf: wiggle::GuestPtr<'a, u8>,
                pub buf_len: Size,
            }
            #[automatically_derived]
            impl<'a> ::core::clone::Clone for Ciovec<'a> {
                #[inline]
                fn clone(&self) -> Ciovec<'a> {
                    Ciovec {
                        buf: ::core::clone::Clone::clone(&self.buf),
                        buf_len: ::core::clone::Clone::clone(&self.buf_len),
                    }
                }
            }
            #[automatically_derived]
            impl<'a> ::core::fmt::Debug for Ciovec<'a> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Ciovec",
                        "buf",
                        &self.buf,
                        "buf_len",
                        &&self.buf_len,
                    )
                }
            }
            impl<'a> wiggle::GuestType<'a> for Ciovec<'a> {
                #[inline]
                fn guest_size() -> u32 {
                    8u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let buf = <wiggle::GuestPtr<
                        u8,
                    > as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let buf_len = <Size as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(4u32)?.cast(),
                    )?;
                    Ok(Ciovec { buf, buf_len })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.buf,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(4u32)?.cast(),
                        val.buf_len,
                    )?;
                    Ok(())
                }
            }
            pub type IovecArray<'a> = wiggle::GuestPtr<'a, [Iovec<'a>]>;
            pub type CiovecArray<'a> = wiggle::GuestPtr<'a, [Ciovec<'a>]>;
            pub type Filedelta = i64;
            pub enum Whence {
                Set,
                Cur,
                End,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Whence {
                #[inline]
                fn clone(&self) -> Whence {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Whence {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Whence::Set => "Set",
                            Whence::Cur => "Cur",
                            Whence::End => "End",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Whence {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Whence {
                #[inline]
                fn eq(&self, other: &Whence) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Whence {}
            impl TryFrom<u8> for Whence {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Whence, wiggle::GuestError> {
                    match value {
                        0 => Ok(Whence::Set),
                        1 => Ok(Whence::Cur),
                        2 => Ok(Whence::End),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Whence")),
                    }
                }
            }
            impl TryFrom<i32> for Whence {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Whence, wiggle::GuestError> {
                    Whence::try_from(u8::try_from(value)?)
                }
            }
            impl From<Whence> for u8 {
                #[inline]
                fn from(v: Whence) -> u8 {
                    match v {
                        Whence::Set => 0,
                        Whence::Cur => 1,
                        Whence::End => 2,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Whence {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Whence::Set),
                        1 => Ok(Whence::Cur),
                        2 => Ok(Whence::End),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Whence")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Whence::Set => {
                            location.cast().write(0usize as u8)?;
                        }
                        Whence::Cur => {
                            location.cast().write(1usize as u8)?;
                        }
                        Whence::End => {
                            location.cast().write(2usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub type Dircookie = u64;
            pub type Dirnamlen = u32;
            pub type Inode = u64;
            pub enum Filetype {
                Unknown,
                BlockDevice,
                CharacterDevice,
                Directory,
                RegularFile,
                SocketDgram,
                SocketStream,
                SymbolicLink,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Filetype {
                #[inline]
                fn clone(&self) -> Filetype {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Filetype {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Filetype::Unknown => "Unknown",
                            Filetype::BlockDevice => "BlockDevice",
                            Filetype::CharacterDevice => "CharacterDevice",
                            Filetype::Directory => "Directory",
                            Filetype::RegularFile => "RegularFile",
                            Filetype::SocketDgram => "SocketDgram",
                            Filetype::SocketStream => "SocketStream",
                            Filetype::SymbolicLink => "SymbolicLink",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Filetype {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Filetype {
                #[inline]
                fn eq(&self, other: &Filetype) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Filetype {}
            impl TryFrom<u8> for Filetype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Filetype, wiggle::GuestError> {
                    match value {
                        0 => Ok(Filetype::Unknown),
                        1 => Ok(Filetype::BlockDevice),
                        2 => Ok(Filetype::CharacterDevice),
                        3 => Ok(Filetype::Directory),
                        4 => Ok(Filetype::RegularFile),
                        5 => Ok(Filetype::SocketDgram),
                        6 => Ok(Filetype::SocketStream),
                        7 => Ok(Filetype::SymbolicLink),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Filetype")),
                    }
                }
            }
            impl TryFrom<i32> for Filetype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Filetype, wiggle::GuestError> {
                    Filetype::try_from(u8::try_from(value)?)
                }
            }
            impl From<Filetype> for u8 {
                #[inline]
                fn from(v: Filetype) -> u8 {
                    match v {
                        Filetype::Unknown => 0,
                        Filetype::BlockDevice => 1,
                        Filetype::CharacterDevice => 2,
                        Filetype::Directory => 3,
                        Filetype::RegularFile => 4,
                        Filetype::SocketDgram => 5,
                        Filetype::SocketStream => 6,
                        Filetype::SymbolicLink => 7,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Filetype {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Filetype::Unknown),
                        1 => Ok(Filetype::BlockDevice),
                        2 => Ok(Filetype::CharacterDevice),
                        3 => Ok(Filetype::Directory),
                        4 => Ok(Filetype::RegularFile),
                        5 => Ok(Filetype::SocketDgram),
                        6 => Ok(Filetype::SocketStream),
                        7 => Ok(Filetype::SymbolicLink),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Filetype")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Filetype::Unknown => {
                            location.cast().write(0usize as u8)?;
                        }
                        Filetype::BlockDevice => {
                            location.cast().write(1usize as u8)?;
                        }
                        Filetype::CharacterDevice => {
                            location.cast().write(2usize as u8)?;
                        }
                        Filetype::Directory => {
                            location.cast().write(3usize as u8)?;
                        }
                        Filetype::RegularFile => {
                            location.cast().write(4usize as u8)?;
                        }
                        Filetype::SocketDgram => {
                            location.cast().write(5usize as u8)?;
                        }
                        Filetype::SocketStream => {
                            location.cast().write(6usize as u8)?;
                        }
                        Filetype::SymbolicLink => {
                            location.cast().write(7usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Dirent {
                pub d_next: Dircookie,
                pub d_ino: Inode,
                pub d_namlen: Dirnamlen,
                pub d_type: Filetype,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Dirent {
                #[inline]
                fn clone(&self) -> Dirent {
                    Dirent {
                        d_next: ::core::clone::Clone::clone(&self.d_next),
                        d_ino: ::core::clone::Clone::clone(&self.d_ino),
                        d_namlen: ::core::clone::Clone::clone(&self.d_namlen),
                        d_type: ::core::clone::Clone::clone(&self.d_type),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Dirent {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Dirent",
                        "d_next",
                        &self.d_next,
                        "d_ino",
                        &self.d_ino,
                        "d_namlen",
                        &self.d_namlen,
                        "d_type",
                        &&self.d_type,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Dirent {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Dirent {
                #[inline]
                fn eq(&self, other: &Dirent) -> bool {
                    self.d_next == other.d_next && self.d_ino == other.d_ino
                        && self.d_namlen == other.d_namlen && self.d_type == other.d_type
                }
            }
            impl<'a> wiggle::GuestType<'a> for Dirent {
                #[inline]
                fn guest_size() -> u32 {
                    24u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let d_next = <Dircookie as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let d_ino = <Inode as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let d_namlen = <Dirnamlen as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    let d_type = <Filetype as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(20u32)?.cast(),
                    )?;
                    Ok(Dirent {
                        d_next,
                        d_ino,
                        d_namlen,
                        d_type,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.d_next,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.d_ino,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.d_namlen,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(20u32)?.cast(),
                        val.d_type,
                    )?;
                    Ok(())
                }
            }
            pub enum Advice {
                Normal,
                Sequential,
                Random,
                Willneed,
                Dontneed,
                Noreuse,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Advice {
                #[inline]
                fn clone(&self) -> Advice {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Advice {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Advice::Normal => "Normal",
                            Advice::Sequential => "Sequential",
                            Advice::Random => "Random",
                            Advice::Willneed => "Willneed",
                            Advice::Dontneed => "Dontneed",
                            Advice::Noreuse => "Noreuse",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Advice {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Advice {
                #[inline]
                fn eq(&self, other: &Advice) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Advice {}
            impl TryFrom<u8> for Advice {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Advice, wiggle::GuestError> {
                    match value {
                        0 => Ok(Advice::Normal),
                        1 => Ok(Advice::Sequential),
                        2 => Ok(Advice::Random),
                        3 => Ok(Advice::Willneed),
                        4 => Ok(Advice::Dontneed),
                        5 => Ok(Advice::Noreuse),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Advice")),
                    }
                }
            }
            impl TryFrom<i32> for Advice {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Advice, wiggle::GuestError> {
                    Advice::try_from(u8::try_from(value)?)
                }
            }
            impl From<Advice> for u8 {
                #[inline]
                fn from(v: Advice) -> u8 {
                    match v {
                        Advice::Normal => 0,
                        Advice::Sequential => 1,
                        Advice::Random => 2,
                        Advice::Willneed => 3,
                        Advice::Dontneed => 4,
                        Advice::Noreuse => 5,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Advice {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Advice::Normal),
                        1 => Ok(Advice::Sequential),
                        2 => Ok(Advice::Random),
                        3 => Ok(Advice::Willneed),
                        4 => Ok(Advice::Dontneed),
                        5 => Ok(Advice::Noreuse),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Advice")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Advice::Normal => {
                            location.cast().write(0usize as u8)?;
                        }
                        Advice::Sequential => {
                            location.cast().write(1usize as u8)?;
                        }
                        Advice::Random => {
                            location.cast().write(2usize as u8)?;
                        }
                        Advice::Willneed => {
                            location.cast().write(3usize as u8)?;
                        }
                        Advice::Dontneed => {
                            location.cast().write(4usize as u8)?;
                        }
                        Advice::Noreuse => {
                            location.cast().write(5usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Fdflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Fdflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Fdflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Fdflags {
                #[inline]
                fn eq(&self, other: &Fdflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Fdflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Fdflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Fdflags {
                #[inline]
                fn clone(&self) -> Fdflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Fdflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Fdflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Fdflags {
                #[inline]
                fn cmp(&self, other: &Fdflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Fdflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn APPEND(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn DSYNC(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn NONBLOCK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn RSYNC(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn SYNC(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Fdflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn APPEND(&self) -> bool {
                            if Self::APPEND.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::APPEND.bits == Self::APPEND.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn DSYNC(&self) -> bool {
                            if Self::DSYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::DSYNC.bits == Self::DSYNC.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn NONBLOCK(&self) -> bool {
                            if Self::NONBLOCK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::NONBLOCK.bits == Self::NONBLOCK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn RSYNC(&self) -> bool {
                            if Self::RSYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RSYNC.bits == Self::RSYNC.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn SYNC(&self) -> bool {
                            if Self::SYNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::SYNC.bits == Self::SYNC.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::APPEND(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("APPEND")?;
                    }
                    if <Self as __BitFlags>::DSYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("DSYNC")?;
                    }
                    if <Self as __BitFlags>::NONBLOCK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("NONBLOCK")?;
                    }
                    if <Self as __BitFlags>::RSYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RSYNC")?;
                    }
                    if <Self as __BitFlags>::SYNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SYNC")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Fdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Fdflags {
                pub const APPEND: Self = Self { bits: 1 };
                pub const DSYNC: Self = Self { bits: 2 };
                pub const NONBLOCK: Self = Self { bits: 4 };
                pub const RSYNC: Self = Self { bits: 8 };
                pub const SYNC: Self = Self { bits: 16 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const APPEND: u16 = 0;
                        const DSYNC: u16 = 0;
                        const NONBLOCK: u16 = 0;
                        const RSYNC: u16 = 0;
                        const SYNC: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Fdflags {
                        #[allow(deprecated)]
                        const APPEND: u16 = Self::APPEND.bits;
                        #[allow(deprecated)]
                        const DSYNC: u16 = Self::DSYNC.bits;
                        #[allow(deprecated)]
                        const NONBLOCK: u16 = Self::NONBLOCK.bits;
                        #[allow(deprecated)]
                        const RSYNC: u16 = Self::RSYNC.bits;
                        #[allow(deprecated)]
                        const SYNC: u16 = Self::SYNC.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::APPEND | <Self as __BitFlags>::DSYNC
                            | <Self as __BitFlags>::NONBLOCK
                            | <Self as __BitFlags>::RSYNC | <Self as __BitFlags>::SYNC,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Fdflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Fdflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Fdflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Fdflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Fdflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Fdflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Fdflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Fdflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Fdflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Fdflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Fdflags> for Fdflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Fdflags> for Fdflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Fdflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Fdflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Fdflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Fdflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Fdflags"))
                    } else {
                        Ok(Fdflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Fdflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Fdflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Fdflags> for u16 {
                #[inline]
                fn from(e: Fdflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Fdflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Fdflags>,
                ) -> Result<Fdflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Fdflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Fdflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct Fdstat {
                pub fs_filetype: Filetype,
                pub fs_flags: Fdflags,
                pub fs_rights_base: Rights,
                pub fs_rights_inheriting: Rights,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Fdstat {
                #[inline]
                fn clone(&self) -> Fdstat {
                    Fdstat {
                        fs_filetype: ::core::clone::Clone::clone(&self.fs_filetype),
                        fs_flags: ::core::clone::Clone::clone(&self.fs_flags),
                        fs_rights_base: ::core::clone::Clone::clone(
                            &self.fs_rights_base,
                        ),
                        fs_rights_inheriting: ::core::clone::Clone::clone(
                            &self.fs_rights_inheriting,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Fdstat {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Fdstat",
                        "fs_filetype",
                        &self.fs_filetype,
                        "fs_flags",
                        &self.fs_flags,
                        "fs_rights_base",
                        &self.fs_rights_base,
                        "fs_rights_inheriting",
                        &&self.fs_rights_inheriting,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Fdstat {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Fdstat {
                #[inline]
                fn eq(&self, other: &Fdstat) -> bool {
                    self.fs_filetype == other.fs_filetype
                        && self.fs_flags == other.fs_flags
                        && self.fs_rights_base == other.fs_rights_base
                        && self.fs_rights_inheriting == other.fs_rights_inheriting
                }
            }
            impl<'a> wiggle::GuestType<'a> for Fdstat {
                #[inline]
                fn guest_size() -> u32 {
                    24u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let fs_filetype = <Filetype as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let fs_flags = <Fdflags as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(2u32)?.cast(),
                    )?;
                    let fs_rights_base = <Rights as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let fs_rights_inheriting = <Rights as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    Ok(Fdstat {
                        fs_filetype,
                        fs_flags,
                        fs_rights_base,
                        fs_rights_inheriting,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.fs_filetype,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(2u32)?.cast(),
                        val.fs_flags,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.fs_rights_base,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.fs_rights_inheriting,
                    )?;
                    Ok(())
                }
            }
            pub type Device = u64;
            pub struct Fstflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Fstflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Fstflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Fstflags {
                #[inline]
                fn eq(&self, other: &Fstflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Fstflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Fstflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Fstflags {
                #[inline]
                fn clone(&self) -> Fstflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Fstflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Fstflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Fstflags {
                #[inline]
                fn cmp(&self, other: &Fstflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Fstflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn ATIM(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn ATIM_NOW(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn MTIM(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn MTIM_NOW(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Fstflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn ATIM(&self) -> bool {
                            if Self::ATIM.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::ATIM.bits == Self::ATIM.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn ATIM_NOW(&self) -> bool {
                            if Self::ATIM_NOW.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::ATIM_NOW.bits == Self::ATIM_NOW.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn MTIM(&self) -> bool {
                            if Self::MTIM.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::MTIM.bits == Self::MTIM.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn MTIM_NOW(&self) -> bool {
                            if Self::MTIM_NOW.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::MTIM_NOW.bits == Self::MTIM_NOW.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::ATIM(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("ATIM")?;
                    }
                    if <Self as __BitFlags>::ATIM_NOW(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("ATIM_NOW")?;
                    }
                    if <Self as __BitFlags>::MTIM(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("MTIM")?;
                    }
                    if <Self as __BitFlags>::MTIM_NOW(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("MTIM_NOW")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Fstflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Fstflags {
                pub const ATIM: Self = Self { bits: 1 };
                pub const ATIM_NOW: Self = Self { bits: 2 };
                pub const MTIM: Self = Self { bits: 4 };
                pub const MTIM_NOW: Self = Self { bits: 8 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const ATIM: u16 = 0;
                        const ATIM_NOW: u16 = 0;
                        const MTIM: u16 = 0;
                        const MTIM_NOW: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Fstflags {
                        #[allow(deprecated)]
                        const ATIM: u16 = Self::ATIM.bits;
                        #[allow(deprecated)]
                        const ATIM_NOW: u16 = Self::ATIM_NOW.bits;
                        #[allow(deprecated)]
                        const MTIM: u16 = Self::MTIM.bits;
                        #[allow(deprecated)]
                        const MTIM_NOW: u16 = Self::MTIM_NOW.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::ATIM | <Self as __BitFlags>::ATIM_NOW
                            | <Self as __BitFlags>::MTIM | <Self as __BitFlags>::MTIM_NOW,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Fstflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Fstflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Fstflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Fstflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Fstflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Fstflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Fstflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Fstflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Fstflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Fstflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Fstflags> for Fstflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Fstflags> for Fstflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Fstflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Fstflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Fstflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Fstflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Fstflags"))
                    } else {
                        Ok(Fstflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Fstflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Fstflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Fstflags> for u16 {
                #[inline]
                fn from(e: Fstflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Fstflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Fstflags>,
                ) -> Result<Fstflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Fstflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Fstflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct Lookupflags {
                bits: u32,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Lookupflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Lookupflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Lookupflags {
                #[inline]
                fn eq(&self, other: &Lookupflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Lookupflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Lookupflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Lookupflags {
                #[inline]
                fn clone(&self) -> Lookupflags {
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Lookupflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Lookupflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Lookupflags {
                #[inline]
                fn cmp(&self, other: &Lookupflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Lookupflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn SYMLINK_FOLLOW(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Lookupflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn SYMLINK_FOLLOW(&self) -> bool {
                            if Self::SYMLINK_FOLLOW.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::SYMLINK_FOLLOW.bits
                                    == Self::SYMLINK_FOLLOW.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::SYMLINK_FOLLOW(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SYMLINK_FOLLOW")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Lookupflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Lookupflags {
                pub const SYMLINK_FOLLOW: Self = Self { bits: 1 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const SYMLINK_FOLLOW: u32 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Lookupflags {
                        #[allow(deprecated)]
                        const SYMLINK_FOLLOW: u32 = Self::SYMLINK_FOLLOW.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::SYMLINK_FOLLOW,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u32 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u32,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u32) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u32) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Lookupflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Lookupflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Lookupflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Lookupflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Lookupflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Lookupflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Lookupflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Lookupflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Lookupflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Lookupflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Lookupflags> for Lookupflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Lookupflags> for Lookupflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Lookupflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Lookupflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u32> for Lookupflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u32) -> Result<Self, wiggle::GuestError> {
                    if u32::from(!Lookupflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Lookupflags"))
                    } else {
                        Ok(Lookupflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Lookupflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Lookupflags::try_from(u32::try_from(value)?)
                }
            }
            impl From<Lookupflags> for u32 {
                #[inline]
                fn from(e: Lookupflags) -> u32 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Lookupflags {
                #[inline]
                fn guest_size() -> u32 {
                    u32::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u32::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Lookupflags>,
                ) -> Result<Lookupflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u32::read(&location.cast())?;
                    let value = Lookupflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Lookupflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u32 = u32::from(val);
                    u32::write(&location.cast(), val)
                }
            }
            pub struct Oflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Oflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Oflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Oflags {
                #[inline]
                fn eq(&self, other: &Oflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Oflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Oflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Oflags {
                #[inline]
                fn clone(&self) -> Oflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Oflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Oflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Oflags {
                #[inline]
                fn cmp(&self, other: &Oflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Oflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn CREAT(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn DIRECTORY(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn EXCL(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn TRUNC(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Oflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn CREAT(&self) -> bool {
                            if Self::CREAT.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::CREAT.bits == Self::CREAT.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn DIRECTORY(&self) -> bool {
                            if Self::DIRECTORY.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::DIRECTORY.bits == Self::DIRECTORY.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn EXCL(&self) -> bool {
                            if Self::EXCL.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::EXCL.bits == Self::EXCL.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn TRUNC(&self) -> bool {
                            if Self::TRUNC.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::TRUNC.bits == Self::TRUNC.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::CREAT(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("CREAT")?;
                    }
                    if <Self as __BitFlags>::DIRECTORY(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("DIRECTORY")?;
                    }
                    if <Self as __BitFlags>::EXCL(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("EXCL")?;
                    }
                    if <Self as __BitFlags>::TRUNC(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("TRUNC")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Oflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Oflags {
                pub const CREAT: Self = Self { bits: 1 };
                pub const DIRECTORY: Self = Self { bits: 2 };
                pub const EXCL: Self = Self { bits: 4 };
                pub const TRUNC: Self = Self { bits: 8 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const CREAT: u16 = 0;
                        const DIRECTORY: u16 = 0;
                        const EXCL: u16 = 0;
                        const TRUNC: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Oflags {
                        #[allow(deprecated)]
                        const CREAT: u16 = Self::CREAT.bits;
                        #[allow(deprecated)]
                        const DIRECTORY: u16 = Self::DIRECTORY.bits;
                        #[allow(deprecated)]
                        const EXCL: u16 = Self::EXCL.bits;
                        #[allow(deprecated)]
                        const TRUNC: u16 = Self::TRUNC.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::CREAT
                            | <Self as __BitFlags>::DIRECTORY
                            | <Self as __BitFlags>::EXCL | <Self as __BitFlags>::TRUNC,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Oflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Oflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Oflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Oflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Oflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Oflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Oflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Oflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Oflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Oflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Oflags> for Oflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Oflags> for Oflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Oflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Oflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Oflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Oflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Oflags"))
                    } else {
                        Ok(Oflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Oflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Oflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Oflags> for u16 {
                #[inline]
                fn from(e: Oflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Oflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Oflags>,
                ) -> Result<Oflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Oflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Oflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub type Linkcount = u64;
            pub struct Filestat {
                pub dev: Device,
                pub ino: Inode,
                pub filetype: Filetype,
                pub nlink: Linkcount,
                pub size: Filesize,
                pub atim: Timestamp,
                pub mtim: Timestamp,
                pub ctim: Timestamp,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Filestat {
                #[inline]
                fn clone(&self) -> Filestat {
                    Filestat {
                        dev: ::core::clone::Clone::clone(&self.dev),
                        ino: ::core::clone::Clone::clone(&self.ino),
                        filetype: ::core::clone::Clone::clone(&self.filetype),
                        nlink: ::core::clone::Clone::clone(&self.nlink),
                        size: ::core::clone::Clone::clone(&self.size),
                        atim: ::core::clone::Clone::clone(&self.atim),
                        mtim: ::core::clone::Clone::clone(&self.mtim),
                        ctim: ::core::clone::Clone::clone(&self.ctim),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Filestat {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    let names: &'static _ = &[
                        "dev",
                        "ino",
                        "filetype",
                        "nlink",
                        "size",
                        "atim",
                        "mtim",
                        "ctim",
                    ];
                    let values: &[&dyn ::core::fmt::Debug] = &[
                        &self.dev,
                        &self.ino,
                        &self.filetype,
                        &self.nlink,
                        &self.size,
                        &self.atim,
                        &self.mtim,
                        &&self.ctim,
                    ];
                    ::core::fmt::Formatter::debug_struct_fields_finish(
                        f,
                        "Filestat",
                        names,
                        values,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Filestat {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Filestat {
                #[inline]
                fn eq(&self, other: &Filestat) -> bool {
                    self.dev == other.dev && self.ino == other.ino
                        && self.filetype == other.filetype && self.nlink == other.nlink
                        && self.size == other.size && self.atim == other.atim
                        && self.mtim == other.mtim && self.ctim == other.ctim
                }
            }
            impl<'a> wiggle::GuestType<'a> for Filestat {
                #[inline]
                fn guest_size() -> u32 {
                    64u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let dev = <Device as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let ino = <Inode as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let filetype = <Filetype as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    let nlink = <Linkcount as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(24u32)?.cast(),
                    )?;
                    let size = <Filesize as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(32u32)?.cast(),
                    )?;
                    let atim = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(40u32)?.cast(),
                    )?;
                    let mtim = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(48u32)?.cast(),
                    )?;
                    let ctim = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(56u32)?.cast(),
                    )?;
                    Ok(Filestat {
                        dev,
                        ino,
                        filetype,
                        nlink,
                        size,
                        atim,
                        mtim,
                        ctim,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.dev,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.ino,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.filetype,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(24u32)?.cast(),
                        val.nlink,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(32u32)?.cast(),
                        val.size,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(40u32)?.cast(),
                        val.atim,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(48u32)?.cast(),
                        val.mtim,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(56u32)?.cast(),
                        val.ctim,
                    )?;
                    Ok(())
                }
            }
            pub type Userdata = u64;
            pub enum Eventtype {
                Clock,
                FdRead,
                FdWrite,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Eventtype {
                #[inline]
                fn clone(&self) -> Eventtype {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Eventtype {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Eventtype::Clock => "Clock",
                            Eventtype::FdRead => "FdRead",
                            Eventtype::FdWrite => "FdWrite",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Eventtype {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Eventtype {
                #[inline]
                fn eq(&self, other: &Eventtype) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Eventtype {}
            impl TryFrom<u8> for Eventtype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Eventtype, wiggle::GuestError> {
                    match value {
                        0 => Ok(Eventtype::Clock),
                        1 => Ok(Eventtype::FdRead),
                        2 => Ok(Eventtype::FdWrite),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Eventtype")),
                    }
                }
            }
            impl TryFrom<i32> for Eventtype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Eventtype, wiggle::GuestError> {
                    Eventtype::try_from(u8::try_from(value)?)
                }
            }
            impl From<Eventtype> for u8 {
                #[inline]
                fn from(v: Eventtype) -> u8 {
                    match v {
                        Eventtype::Clock => 0,
                        Eventtype::FdRead => 1,
                        Eventtype::FdWrite => 2,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Eventtype {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Eventtype::Clock),
                        1 => Ok(Eventtype::FdRead),
                        2 => Ok(Eventtype::FdWrite),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Eventtype")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Eventtype::Clock => {
                            location.cast().write(0usize as u8)?;
                        }
                        Eventtype::FdRead => {
                            location.cast().write(1usize as u8)?;
                        }
                        Eventtype::FdWrite => {
                            location.cast().write(2usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Eventrwflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Eventrwflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Eventrwflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Eventrwflags {
                #[inline]
                fn eq(&self, other: &Eventrwflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Eventrwflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Eventrwflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Eventrwflags {
                #[inline]
                fn clone(&self) -> Eventrwflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Eventrwflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Eventrwflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Eventrwflags {
                #[inline]
                fn cmp(&self, other: &Eventrwflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Eventrwflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn FD_READWRITE_HANGUP(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Eventrwflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn FD_READWRITE_HANGUP(&self) -> bool {
                            if Self::FD_READWRITE_HANGUP.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::FD_READWRITE_HANGUP.bits
                                    == Self::FD_READWRITE_HANGUP.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::FD_READWRITE_HANGUP(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("FD_READWRITE_HANGUP")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Eventrwflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Eventrwflags {
                pub const FD_READWRITE_HANGUP: Self = Self { bits: 1 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const FD_READWRITE_HANGUP: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Eventrwflags {
                        #[allow(deprecated)]
                        const FD_READWRITE_HANGUP: u16 = Self::FD_READWRITE_HANGUP.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::FD_READWRITE_HANGUP,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Eventrwflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Eventrwflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Eventrwflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Eventrwflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Eventrwflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Eventrwflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Eventrwflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Eventrwflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Eventrwflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Eventrwflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Eventrwflags> for Eventrwflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Eventrwflags> for Eventrwflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Eventrwflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Eventrwflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Eventrwflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Eventrwflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Eventrwflags"))
                    } else {
                        Ok(Eventrwflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Eventrwflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Eventrwflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Eventrwflags> for u16 {
                #[inline]
                fn from(e: Eventrwflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Eventrwflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Eventrwflags>,
                ) -> Result<Eventrwflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Eventrwflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Eventrwflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct EventFdReadwrite {
                pub nbytes: Filesize,
                pub flags: Eventrwflags,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for EventFdReadwrite {
                #[inline]
                fn clone(&self) -> EventFdReadwrite {
                    EventFdReadwrite {
                        nbytes: ::core::clone::Clone::clone(&self.nbytes),
                        flags: ::core::clone::Clone::clone(&self.flags),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for EventFdReadwrite {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "EventFdReadwrite",
                        "nbytes",
                        &self.nbytes,
                        "flags",
                        &&self.flags,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for EventFdReadwrite {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for EventFdReadwrite {
                #[inline]
                fn eq(&self, other: &EventFdReadwrite) -> bool {
                    self.nbytes == other.nbytes && self.flags == other.flags
                }
            }
            impl<'a> wiggle::GuestType<'a> for EventFdReadwrite {
                #[inline]
                fn guest_size() -> u32 {
                    16u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let nbytes = <Filesize as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let flags = <Eventrwflags as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    Ok(EventFdReadwrite { nbytes, flags })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.nbytes,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.flags,
                    )?;
                    Ok(())
                }
            }
            pub struct Event {
                pub userdata: Userdata,
                pub error: Errno,
                pub type_: Eventtype,
                pub fd_readwrite: EventFdReadwrite,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Event {
                #[inline]
                fn clone(&self) -> Event {
                    Event {
                        userdata: ::core::clone::Clone::clone(&self.userdata),
                        error: ::core::clone::Clone::clone(&self.error),
                        type_: ::core::clone::Clone::clone(&self.type_),
                        fd_readwrite: ::core::clone::Clone::clone(&self.fd_readwrite),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Event {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "Event",
                        "userdata",
                        &self.userdata,
                        "error",
                        &self.error,
                        "type_",
                        &self.type_,
                        "fd_readwrite",
                        &&self.fd_readwrite,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Event {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Event {
                #[inline]
                fn eq(&self, other: &Event) -> bool {
                    self.userdata == other.userdata && self.error == other.error
                        && self.type_ == other.type_
                        && self.fd_readwrite == other.fd_readwrite
                }
            }
            impl<'a> wiggle::GuestType<'a> for Event {
                #[inline]
                fn guest_size() -> u32 {
                    32u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let userdata = <Userdata as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let error = <Errno as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let type_ = <Eventtype as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(10u32)?.cast(),
                    )?;
                    let fd_readwrite = <EventFdReadwrite as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    Ok(Event {
                        userdata,
                        error,
                        type_,
                        fd_readwrite,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.userdata,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.error,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(10u32)?.cast(),
                        val.type_,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.fd_readwrite,
                    )?;
                    Ok(())
                }
            }
            pub struct Subclockflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Subclockflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Subclockflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Subclockflags {
                #[inline]
                fn eq(&self, other: &Subclockflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Subclockflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Subclockflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Subclockflags {
                #[inline]
                fn clone(&self) -> Subclockflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Subclockflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Subclockflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Subclockflags {
                #[inline]
                fn cmp(&self, other: &Subclockflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Subclockflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn SUBSCRIPTION_CLOCK_ABSTIME(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Subclockflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn SUBSCRIPTION_CLOCK_ABSTIME(&self) -> bool {
                            if Self::SUBSCRIPTION_CLOCK_ABSTIME.bits == 0
                                && self.bits != 0
                            {
                                false
                            } else {
                                self.bits & Self::SUBSCRIPTION_CLOCK_ABSTIME.bits
                                    == Self::SUBSCRIPTION_CLOCK_ABSTIME.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::SUBSCRIPTION_CLOCK_ABSTIME(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("SUBSCRIPTION_CLOCK_ABSTIME")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Subclockflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Subclockflags {
                pub const SUBSCRIPTION_CLOCK_ABSTIME: Self = Self { bits: 1 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const SUBSCRIPTION_CLOCK_ABSTIME: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Subclockflags {
                        #[allow(deprecated)]
                        const SUBSCRIPTION_CLOCK_ABSTIME: u16 = Self::SUBSCRIPTION_CLOCK_ABSTIME
                            .bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::SUBSCRIPTION_CLOCK_ABSTIME,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Subclockflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Subclockflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Subclockflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Subclockflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Subclockflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Subclockflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Subclockflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Subclockflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Subclockflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Subclockflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Subclockflags> for Subclockflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Subclockflags> for Subclockflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Subclockflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Subclockflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Subclockflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Subclockflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Subclockflags"))
                    } else {
                        Ok(Subclockflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Subclockflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Subclockflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Subclockflags> for u16 {
                #[inline]
                fn from(e: Subclockflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Subclockflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Subclockflags>,
                ) -> Result<Subclockflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Subclockflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Subclockflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct SubscriptionClock {
                pub id: Clockid,
                pub timeout: Timestamp,
                pub precision: Timestamp,
                pub flags: Subclockflags,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SubscriptionClock {
                #[inline]
                fn clone(&self) -> SubscriptionClock {
                    SubscriptionClock {
                        id: ::core::clone::Clone::clone(&self.id),
                        timeout: ::core::clone::Clone::clone(&self.timeout),
                        precision: ::core::clone::Clone::clone(&self.precision),
                        flags: ::core::clone::Clone::clone(&self.flags),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubscriptionClock {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field4_finish(
                        f,
                        "SubscriptionClock",
                        "id",
                        &self.id,
                        "timeout",
                        &self.timeout,
                        "precision",
                        &self.precision,
                        "flags",
                        &&self.flags,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SubscriptionClock {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SubscriptionClock {
                #[inline]
                fn eq(&self, other: &SubscriptionClock) -> bool {
                    self.id == other.id && self.timeout == other.timeout
                        && self.precision == other.precision && self.flags == other.flags
                }
            }
            impl<'a> wiggle::GuestType<'a> for SubscriptionClock {
                #[inline]
                fn guest_size() -> u32 {
                    32u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let id = <Clockid as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let timeout = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    let precision = <Timestamp as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(16u32)?.cast(),
                    )?;
                    let flags = <Subclockflags as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(24u32)?.cast(),
                    )?;
                    Ok(SubscriptionClock {
                        id,
                        timeout,
                        precision,
                        flags,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.id,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.timeout,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(16u32)?.cast(),
                        val.precision,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(24u32)?.cast(),
                        val.flags,
                    )?;
                    Ok(())
                }
            }
            pub struct SubscriptionFdReadwrite {
                pub file_descriptor: Fd,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SubscriptionFdReadwrite {
                #[inline]
                fn clone(&self) -> SubscriptionFdReadwrite {
                    SubscriptionFdReadwrite {
                        file_descriptor: ::core::clone::Clone::clone(
                            &self.file_descriptor,
                        ),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubscriptionFdReadwrite {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "SubscriptionFdReadwrite",
                        "file_descriptor",
                        &&self.file_descriptor,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SubscriptionFdReadwrite {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SubscriptionFdReadwrite {
                #[inline]
                fn eq(&self, other: &SubscriptionFdReadwrite) -> bool {
                    self.file_descriptor == other.file_descriptor
                }
            }
            impl<'a> wiggle::GuestType<'a> for SubscriptionFdReadwrite {
                #[inline]
                fn guest_size() -> u32 {
                    4u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let file_descriptor = <Fd as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    Ok(SubscriptionFdReadwrite {
                        file_descriptor,
                    })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.file_descriptor,
                    )?;
                    Ok(())
                }
            }
            pub enum SubscriptionU {
                Clock(SubscriptionClock),
                FdRead(SubscriptionFdReadwrite),
                FdWrite(SubscriptionFdReadwrite),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for SubscriptionU {
                #[inline]
                fn clone(&self) -> SubscriptionU {
                    match self {
                        SubscriptionU::Clock(__self_0) => {
                            SubscriptionU::Clock(::core::clone::Clone::clone(__self_0))
                        }
                        SubscriptionU::FdRead(__self_0) => {
                            SubscriptionU::FdRead(::core::clone::Clone::clone(__self_0))
                        }
                        SubscriptionU::FdWrite(__self_0) => {
                            SubscriptionU::FdWrite(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for SubscriptionU {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        SubscriptionU::Clock(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Clock",
                                &__self_0,
                            )
                        }
                        SubscriptionU::FdRead(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FdRead",
                                &__self_0,
                            )
                        }
                        SubscriptionU::FdWrite(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "FdWrite",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for SubscriptionU {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for SubscriptionU {
                #[inline]
                fn eq(&self, other: &SubscriptionU) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                        && match (self, other) {
                            (
                                SubscriptionU::Clock(__self_0),
                                SubscriptionU::Clock(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                SubscriptionU::FdRead(__self_0),
                                SubscriptionU::FdRead(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            (
                                SubscriptionU::FdWrite(__self_0),
                                SubscriptionU::FdWrite(__arg1_0),
                            ) => *__self_0 == *__arg1_0,
                            _ => unsafe { ::core::intrinsics::unreachable() }
                        }
                }
            }
            impl<'a> wiggle::GuestType<'a> for SubscriptionU {
                #[inline]
                fn guest_size() -> u32 {
                    40u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => {
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            let variant_val = <SubscriptionClock as wiggle::GuestType>::read(
                                &variant_ptr.cast(),
                            )?;
                            Ok(SubscriptionU::Clock(variant_val))
                        }
                        1 => {
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            let variant_val = <SubscriptionFdReadwrite as wiggle::GuestType>::read(
                                &variant_ptr.cast(),
                            )?;
                            Ok(SubscriptionU::FdRead(variant_val))
                        }
                        2 => {
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            let variant_val = <SubscriptionFdReadwrite as wiggle::GuestType>::read(
                                &variant_ptr.cast(),
                            )?;
                            Ok(SubscriptionU::FdWrite(variant_val))
                        }
                        _ => Err(wiggle::GuestError::InvalidEnumValue("SubscriptionU")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        SubscriptionU::Clock(contents) => {
                            location.cast().write(0usize as u8)?;
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            <SubscriptionClock as wiggle::GuestType>::write(
                                &variant_ptr.cast(),
                                contents,
                            )?;
                        }
                        SubscriptionU::FdRead(contents) => {
                            location.cast().write(1usize as u8)?;
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            <SubscriptionFdReadwrite as wiggle::GuestType>::write(
                                &variant_ptr.cast(),
                                contents,
                            )?;
                        }
                        SubscriptionU::FdWrite(contents) => {
                            location.cast().write(2usize as u8)?;
                            let variant_ptr = location.cast::<u8>().add(8u32)?;
                            <SubscriptionFdReadwrite as wiggle::GuestType>::write(
                                &variant_ptr.cast(),
                                contents,
                            )?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Subscription {
                pub userdata: Userdata,
                pub u: SubscriptionU,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Subscription {
                #[inline]
                fn clone(&self) -> Subscription {
                    Subscription {
                        userdata: ::core::clone::Clone::clone(&self.userdata),
                        u: ::core::clone::Clone::clone(&self.u),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Subscription {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field2_finish(
                        f,
                        "Subscription",
                        "userdata",
                        &self.userdata,
                        "u",
                        &&self.u,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Subscription {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Subscription {
                #[inline]
                fn eq(&self, other: &Subscription) -> bool {
                    self.userdata == other.userdata && self.u == other.u
                }
            }
            impl<'a> wiggle::GuestType<'a> for Subscription {
                #[inline]
                fn guest_size() -> u32 {
                    48u32
                }
                #[inline]
                fn guest_align() -> usize {
                    8usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let userdata = <Userdata as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    let u = <SubscriptionU as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(8u32)?.cast(),
                    )?;
                    Ok(Subscription { userdata, u })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.userdata,
                    )?;
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(8u32)?.cast(),
                        val.u,
                    )?;
                    Ok(())
                }
            }
            pub type Exitcode = u32;
            pub enum Signal {
                None,
                Hup,
                Int,
                Quit,
                Ill,
                Trap,
                Abrt,
                Bus,
                Fpe,
                Kill,
                Usr1,
                Segv,
                Usr2,
                Pipe,
                Alrm,
                Term,
                Chld,
                Cont,
                Stop,
                Tstp,
                Ttin,
                Ttou,
                Urg,
                Xcpu,
                Xfsz,
                Vtalrm,
                Prof,
                Winch,
                Poll,
                Pwr,
                Sys,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Signal {
                #[inline]
                fn clone(&self) -> Signal {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Signal {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(
                        f,
                        match self {
                            Signal::None => "None",
                            Signal::Hup => "Hup",
                            Signal::Int => "Int",
                            Signal::Quit => "Quit",
                            Signal::Ill => "Ill",
                            Signal::Trap => "Trap",
                            Signal::Abrt => "Abrt",
                            Signal::Bus => "Bus",
                            Signal::Fpe => "Fpe",
                            Signal::Kill => "Kill",
                            Signal::Usr1 => "Usr1",
                            Signal::Segv => "Segv",
                            Signal::Usr2 => "Usr2",
                            Signal::Pipe => "Pipe",
                            Signal::Alrm => "Alrm",
                            Signal::Term => "Term",
                            Signal::Chld => "Chld",
                            Signal::Cont => "Cont",
                            Signal::Stop => "Stop",
                            Signal::Tstp => "Tstp",
                            Signal::Ttin => "Ttin",
                            Signal::Ttou => "Ttou",
                            Signal::Urg => "Urg",
                            Signal::Xcpu => "Xcpu",
                            Signal::Xfsz => "Xfsz",
                            Signal::Vtalrm => "Vtalrm",
                            Signal::Prof => "Prof",
                            Signal::Winch => "Winch",
                            Signal::Poll => "Poll",
                            Signal::Pwr => "Pwr",
                            Signal::Sys => "Sys",
                        },
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Signal {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Signal {
                #[inline]
                fn eq(&self, other: &Signal) -> bool {
                    let __self_tag = ::core::intrinsics::discriminant_value(self);
                    let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                    __self_tag == __arg1_tag
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Signal {}
            impl TryFrom<u8> for Signal {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Signal, wiggle::GuestError> {
                    match value {
                        0 => Ok(Signal::None),
                        1 => Ok(Signal::Hup),
                        2 => Ok(Signal::Int),
                        3 => Ok(Signal::Quit),
                        4 => Ok(Signal::Ill),
                        5 => Ok(Signal::Trap),
                        6 => Ok(Signal::Abrt),
                        7 => Ok(Signal::Bus),
                        8 => Ok(Signal::Fpe),
                        9 => Ok(Signal::Kill),
                        10 => Ok(Signal::Usr1),
                        11 => Ok(Signal::Segv),
                        12 => Ok(Signal::Usr2),
                        13 => Ok(Signal::Pipe),
                        14 => Ok(Signal::Alrm),
                        15 => Ok(Signal::Term),
                        16 => Ok(Signal::Chld),
                        17 => Ok(Signal::Cont),
                        18 => Ok(Signal::Stop),
                        19 => Ok(Signal::Tstp),
                        20 => Ok(Signal::Ttin),
                        21 => Ok(Signal::Ttou),
                        22 => Ok(Signal::Urg),
                        23 => Ok(Signal::Xcpu),
                        24 => Ok(Signal::Xfsz),
                        25 => Ok(Signal::Vtalrm),
                        26 => Ok(Signal::Prof),
                        27 => Ok(Signal::Winch),
                        28 => Ok(Signal::Poll),
                        29 => Ok(Signal::Pwr),
                        30 => Ok(Signal::Sys),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Signal")),
                    }
                }
            }
            impl TryFrom<i32> for Signal {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Signal, wiggle::GuestError> {
                    Signal::try_from(u8::try_from(value)?)
                }
            }
            impl From<Signal> for u8 {
                #[inline]
                fn from(v: Signal) -> u8 {
                    match v {
                        Signal::None => 0,
                        Signal::Hup => 1,
                        Signal::Int => 2,
                        Signal::Quit => 3,
                        Signal::Ill => 4,
                        Signal::Trap => 5,
                        Signal::Abrt => 6,
                        Signal::Bus => 7,
                        Signal::Fpe => 8,
                        Signal::Kill => 9,
                        Signal::Usr1 => 10,
                        Signal::Segv => 11,
                        Signal::Usr2 => 12,
                        Signal::Pipe => 13,
                        Signal::Alrm => 14,
                        Signal::Term => 15,
                        Signal::Chld => 16,
                        Signal::Cont => 17,
                        Signal::Stop => 18,
                        Signal::Tstp => 19,
                        Signal::Ttin => 20,
                        Signal::Ttou => 21,
                        Signal::Urg => 22,
                        Signal::Xcpu => 23,
                        Signal::Xfsz => 24,
                        Signal::Vtalrm => 25,
                        Signal::Prof => 26,
                        Signal::Winch => 27,
                        Signal::Poll => 28,
                        Signal::Pwr => 29,
                        Signal::Sys => 30,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Signal {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Signal::None),
                        1 => Ok(Signal::Hup),
                        2 => Ok(Signal::Int),
                        3 => Ok(Signal::Quit),
                        4 => Ok(Signal::Ill),
                        5 => Ok(Signal::Trap),
                        6 => Ok(Signal::Abrt),
                        7 => Ok(Signal::Bus),
                        8 => Ok(Signal::Fpe),
                        9 => Ok(Signal::Kill),
                        10 => Ok(Signal::Usr1),
                        11 => Ok(Signal::Segv),
                        12 => Ok(Signal::Usr2),
                        13 => Ok(Signal::Pipe),
                        14 => Ok(Signal::Alrm),
                        15 => Ok(Signal::Term),
                        16 => Ok(Signal::Chld),
                        17 => Ok(Signal::Cont),
                        18 => Ok(Signal::Stop),
                        19 => Ok(Signal::Tstp),
                        20 => Ok(Signal::Ttin),
                        21 => Ok(Signal::Ttou),
                        22 => Ok(Signal::Urg),
                        23 => Ok(Signal::Xcpu),
                        24 => Ok(Signal::Xfsz),
                        25 => Ok(Signal::Vtalrm),
                        26 => Ok(Signal::Prof),
                        27 => Ok(Signal::Winch),
                        28 => Ok(Signal::Poll),
                        29 => Ok(Signal::Pwr),
                        30 => Ok(Signal::Sys),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Signal")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Signal::None => {
                            location.cast().write(0usize as u8)?;
                        }
                        Signal::Hup => {
                            location.cast().write(1usize as u8)?;
                        }
                        Signal::Int => {
                            location.cast().write(2usize as u8)?;
                        }
                        Signal::Quit => {
                            location.cast().write(3usize as u8)?;
                        }
                        Signal::Ill => {
                            location.cast().write(4usize as u8)?;
                        }
                        Signal::Trap => {
                            location.cast().write(5usize as u8)?;
                        }
                        Signal::Abrt => {
                            location.cast().write(6usize as u8)?;
                        }
                        Signal::Bus => {
                            location.cast().write(7usize as u8)?;
                        }
                        Signal::Fpe => {
                            location.cast().write(8usize as u8)?;
                        }
                        Signal::Kill => {
                            location.cast().write(9usize as u8)?;
                        }
                        Signal::Usr1 => {
                            location.cast().write(10usize as u8)?;
                        }
                        Signal::Segv => {
                            location.cast().write(11usize as u8)?;
                        }
                        Signal::Usr2 => {
                            location.cast().write(12usize as u8)?;
                        }
                        Signal::Pipe => {
                            location.cast().write(13usize as u8)?;
                        }
                        Signal::Alrm => {
                            location.cast().write(14usize as u8)?;
                        }
                        Signal::Term => {
                            location.cast().write(15usize as u8)?;
                        }
                        Signal::Chld => {
                            location.cast().write(16usize as u8)?;
                        }
                        Signal::Cont => {
                            location.cast().write(17usize as u8)?;
                        }
                        Signal::Stop => {
                            location.cast().write(18usize as u8)?;
                        }
                        Signal::Tstp => {
                            location.cast().write(19usize as u8)?;
                        }
                        Signal::Ttin => {
                            location.cast().write(20usize as u8)?;
                        }
                        Signal::Ttou => {
                            location.cast().write(21usize as u8)?;
                        }
                        Signal::Urg => {
                            location.cast().write(22usize as u8)?;
                        }
                        Signal::Xcpu => {
                            location.cast().write(23usize as u8)?;
                        }
                        Signal::Xfsz => {
                            location.cast().write(24usize as u8)?;
                        }
                        Signal::Vtalrm => {
                            location.cast().write(25usize as u8)?;
                        }
                        Signal::Prof => {
                            location.cast().write(26usize as u8)?;
                        }
                        Signal::Winch => {
                            location.cast().write(27usize as u8)?;
                        }
                        Signal::Poll => {
                            location.cast().write(28usize as u8)?;
                        }
                        Signal::Pwr => {
                            location.cast().write(29usize as u8)?;
                        }
                        Signal::Sys => {
                            location.cast().write(30usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct Riflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Riflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Riflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Riflags {
                #[inline]
                fn eq(&self, other: &Riflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Riflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Riflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Riflags {
                #[inline]
                fn clone(&self) -> Riflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Riflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Riflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Riflags {
                #[inline]
                fn cmp(&self, other: &Riflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Riflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn RECV_PEEK(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn RECV_WAITALL(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Riflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn RECV_PEEK(&self) -> bool {
                            if Self::RECV_PEEK.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RECV_PEEK.bits == Self::RECV_PEEK.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn RECV_WAITALL(&self) -> bool {
                            if Self::RECV_WAITALL.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RECV_WAITALL.bits
                                    == Self::RECV_WAITALL.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::RECV_PEEK(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RECV_PEEK")?;
                    }
                    if <Self as __BitFlags>::RECV_WAITALL(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RECV_WAITALL")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Riflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Riflags {
                pub const RECV_PEEK: Self = Self { bits: 1 };
                pub const RECV_WAITALL: Self = Self { bits: 2 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const RECV_PEEK: u16 = 0;
                        const RECV_WAITALL: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Riflags {
                        #[allow(deprecated)]
                        const RECV_PEEK: u16 = Self::RECV_PEEK.bits;
                        #[allow(deprecated)]
                        const RECV_WAITALL: u16 = Self::RECV_WAITALL.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::RECV_PEEK
                            | <Self as __BitFlags>::RECV_WAITALL,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Riflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Riflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Riflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Riflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Riflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Riflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Riflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Riflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Riflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Riflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Riflags> for Riflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Riflags> for Riflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Riflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Riflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Riflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Riflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Riflags"))
                    } else {
                        Ok(Riflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Riflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Riflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Riflags> for u16 {
                #[inline]
                fn from(e: Riflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Riflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Riflags>,
                ) -> Result<Riflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Riflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Riflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub struct Roflags {
                bits: u16,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Roflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Roflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Roflags {
                #[inline]
                fn eq(&self, other: &Roflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Roflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Roflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u16>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Roflags {
                #[inline]
                fn clone(&self) -> Roflags {
                    let _: ::core::clone::AssertParamIsClone<u16>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Roflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Roflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Roflags {
                #[inline]
                fn cmp(&self, other: &Roflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Roflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn RECV_DATA_TRUNCATED(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Roflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn RECV_DATA_TRUNCATED(&self) -> bool {
                            if Self::RECV_DATA_TRUNCATED.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RECV_DATA_TRUNCATED.bits
                                    == Self::RECV_DATA_TRUNCATED.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::RECV_DATA_TRUNCATED(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RECV_DATA_TRUNCATED")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Roflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Roflags {
                pub const RECV_DATA_TRUNCATED: Self = Self { bits: 1 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const RECV_DATA_TRUNCATED: u16 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Roflags {
                        #[allow(deprecated)]
                        const RECV_DATA_TRUNCATED: u16 = Self::RECV_DATA_TRUNCATED.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::RECV_DATA_TRUNCATED,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u16 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u16,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u16) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u16) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Roflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Roflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Roflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Roflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Roflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Roflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Roflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Roflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Roflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Roflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Roflags> for Roflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Roflags> for Roflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Roflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Roflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u16> for Roflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u16) -> Result<Self, wiggle::GuestError> {
                    if u16::from(!Roflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Roflags"))
                    } else {
                        Ok(Roflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Roflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Roflags::try_from(u16::try_from(value)?)
                }
            }
            impl From<Roflags> for u16 {
                #[inline]
                fn from(e: Roflags) -> u16 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Roflags {
                #[inline]
                fn guest_size() -> u32 {
                    u16::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u16::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Roflags>,
                ) -> Result<Roflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u16::read(&location.cast())?;
                    let value = Roflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Roflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u16 = u16::from(val);
                    u16::write(&location.cast(), val)
                }
            }
            pub type Siflags = u16;
            pub struct Sdflags {
                bits: u8,
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Sdflags {}
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Sdflags {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Sdflags {
                #[inline]
                fn eq(&self, other: &Sdflags) -> bool {
                    self.bits == other.bits
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralEq for Sdflags {}
            #[automatically_derived]
            impl ::core::cmp::Eq for Sdflags {
                #[inline]
                #[doc(hidden)]
                #[no_coverage]
                fn assert_receiver_is_total_eq(&self) -> () {
                    let _: ::core::cmp::AssertParamIsEq<u8>;
                }
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Sdflags {
                #[inline]
                fn clone(&self) -> Sdflags {
                    let _: ::core::clone::AssertParamIsClone<u8>;
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::cmp::PartialOrd for Sdflags {
                #[inline]
                fn partial_cmp(
                    &self,
                    other: &Sdflags,
                ) -> ::core::option::Option<::core::cmp::Ordering> {
                    ::core::cmp::PartialOrd::partial_cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::cmp::Ord for Sdflags {
                #[inline]
                fn cmp(&self, other: &Sdflags) -> ::core::cmp::Ordering {
                    ::core::cmp::Ord::cmp(&self.bits, &other.bits)
                }
            }
            #[automatically_derived]
            impl ::core::hash::Hash for Sdflags {
                fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                    ::core::hash::Hash::hash(&self.bits, state)
                }
            }
            impl ::bitflags::_core::fmt::Debug for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        #[inline]
                        fn RD(&self) -> bool {
                            false
                        }
                        #[inline]
                        fn WR(&self) -> bool {
                            false
                        }
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Sdflags {
                        #[allow(deprecated)]
                        #[inline]
                        fn RD(&self) -> bool {
                            if Self::RD.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::RD.bits == Self::RD.bits
                            }
                        }
                        #[allow(deprecated)]
                        #[inline]
                        fn WR(&self) -> bool {
                            if Self::WR.bits == 0 && self.bits != 0 {
                                false
                            } else {
                                self.bits & Self::WR.bits == Self::WR.bits
                            }
                        }
                    }
                    let mut first = true;
                    if <Self as __BitFlags>::RD(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("RD")?;
                    }
                    if <Self as __BitFlags>::WR(self) {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("WR")?;
                    }
                    let extra_bits = self.bits & !Self::all().bits();
                    if extra_bits != 0 {
                        if !first {
                            f.write_str(" | ")?;
                        }
                        first = false;
                        f.write_str("0x")?;
                        ::bitflags::_core::fmt::LowerHex::fmt(&extra_bits, f)?;
                    }
                    if first {
                        f.write_str("(empty)")?;
                    }
                    Ok(())
                }
            }
            impl ::bitflags::_core::fmt::Binary for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Binary::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::Octal for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::Octal::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::LowerHex for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::LowerHex::fmt(&self.bits, f)
                }
            }
            impl ::bitflags::_core::fmt::UpperHex for Sdflags {
                fn fmt(
                    &self,
                    f: &mut ::bitflags::_core::fmt::Formatter,
                ) -> ::bitflags::_core::fmt::Result {
                    ::bitflags::_core::fmt::UpperHex::fmt(&self.bits, f)
                }
            }
            #[allow(dead_code)]
            impl Sdflags {
                pub const RD: Self = Self { bits: 1 };
                pub const WR: Self = Self { bits: 2 };
                /// Returns an empty set of flags.
                #[inline]
                pub const fn empty() -> Self {
                    Self { bits: 0 }
                }
                /// Returns the set containing all flags.
                #[inline]
                pub const fn all() -> Self {
                    #[allow(non_snake_case)]
                    trait __BitFlags {
                        const RD: u8 = 0;
                        const WR: u8 = 0;
                    }
                    #[allow(non_snake_case)]
                    impl __BitFlags for Sdflags {
                        #[allow(deprecated)]
                        const RD: u8 = Self::RD.bits;
                        #[allow(deprecated)]
                        const WR: u8 = Self::WR.bits;
                    }
                    Self {
                        bits: <Self as __BitFlags>::RD | <Self as __BitFlags>::WR,
                    }
                }
                /// Returns the raw value of the flags currently stored.
                #[inline]
                pub const fn bits(&self) -> u8 {
                    self.bits
                }
                /// Convert from underlying bit representation, unless that
                /// representation contains bits that do not correspond to a flag.
                #[inline]
                pub const fn from_bits(
                    bits: u8,
                ) -> ::bitflags::_core::option::Option<Self> {
                    if (bits & !Self::all().bits()) == 0 {
                        ::bitflags::_core::option::Option::Some(Self { bits })
                    } else {
                        ::bitflags::_core::option::Option::None
                    }
                }
                /// Convert from underlying bit representation, dropping any bits
                /// that do not correspond to flags.
                #[inline]
                pub const fn from_bits_truncate(bits: u8) -> Self {
                    Self {
                        bits: bits & Self::all().bits,
                    }
                }
                /// Convert from underlying bit representation, preserving all
                /// bits (even those not corresponding to a defined flag).
                ///
                /// # Safety
                ///
                /// The caller of the `bitflags!` macro can chose to allow or
                /// disallow extra bits for their bitflags type.
                ///
                /// The caller of `from_bits_unchecked()` has to ensure that
                /// all bits correspond to a defined flag or that extra bits
                /// are valid for this bitflags type.
                #[inline]
                pub const unsafe fn from_bits_unchecked(bits: u8) -> Self {
                    Self { bits }
                }
                /// Returns `true` if no flags are currently stored.
                #[inline]
                pub const fn is_empty(&self) -> bool {
                    self.bits() == Self::empty().bits()
                }
                /// Returns `true` if all flags are currently set.
                #[inline]
                pub const fn is_all(&self) -> bool {
                    Self::all().bits | self.bits == self.bits
                }
                /// Returns `true` if there are flags common to both `self` and `other`.
                #[inline]
                pub const fn intersects(&self, other: Self) -> bool {
                    !(Self {
                        bits: self.bits & other.bits,
                    })
                        .is_empty()
                }
                /// Returns `true` if all of the flags in `other` are contained within `self`.
                #[inline]
                pub const fn contains(&self, other: Self) -> bool {
                    (self.bits & other.bits) == other.bits
                }
                /// Inserts the specified flags in-place.
                #[inline]
                pub fn insert(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
                /// Removes the specified flags in-place.
                #[inline]
                pub fn remove(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
                /// Toggles the specified flags in-place.
                #[inline]
                pub fn toggle(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
                /// Inserts or removes the specified flags depending on the passed value.
                #[inline]
                pub fn set(&mut self, other: Self, value: bool) {
                    if value {
                        self.insert(other);
                    } else {
                        self.remove(other);
                    }
                }
                /// Returns the intersection between the flags in `self` and
                /// `other`.
                ///
                /// Specifically, the returned set contains only the flags which are
                /// present in *both* `self` *and* `other`.
                ///
                /// This is equivalent to using the `&` operator (e.g.
                /// [`ops::BitAnd`]), as in `flags & other`.
                ///
                /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
                #[inline]
                #[must_use]
                pub const fn intersection(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
                /// Returns the union of between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags which are
                /// present in *either* `self` *or* `other`, including any which are
                /// present in both (see [`Self::symmetric_difference`] if that
                /// is undesirable).
                ///
                /// This is equivalent to using the `|` operator (e.g.
                /// [`ops::BitOr`]), as in `flags | other`.
                ///
                /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
                #[inline]
                #[must_use]
                pub const fn union(self, other: Self) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
                /// Returns the difference between the flags in `self` and `other`.
                ///
                /// Specifically, the returned set contains all flags present in
                /// `self`, except for the ones present in `other`.
                ///
                /// It is also conceptually equivalent to the "bit-clear" operation:
                /// `flags & !other` (and this syntax is also supported).
                ///
                /// This is equivalent to using the `-` operator (e.g.
                /// [`ops::Sub`]), as in `flags - other`.
                ///
                /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
                #[inline]
                #[must_use]
                pub const fn difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
                /// Returns the [symmetric difference][sym-diff] between the flags
                /// in `self` and `other`.
                ///
                /// Specifically, the returned set contains the flags present which
                /// are present in `self` or `other`, but that are not present in
                /// both. Equivalently, it contains the flags present in *exactly
                /// one* of the sets `self` and `other`.
                ///
                /// This is equivalent to using the `^` operator (e.g.
                /// [`ops::BitXor`]), as in `flags ^ other`.
                ///
                /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference
                /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html
                #[inline]
                #[must_use]
                pub const fn symmetric_difference(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
                /// Returns the complement of this set of flags.
                ///
                /// Specifically, the returned set contains all the flags which are
                /// not set in `self`, but which are allowed for this type.
                ///
                /// Alternatively, it can be thought of as the set difference
                /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)
                ///
                /// This is equivalent to using the `!` operator (e.g.
                /// [`ops::Not`]), as in `!flags`.
                ///
                /// [`Self::all()`]: Self::all
                /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html
                #[inline]
                #[must_use]
                pub const fn complement(self) -> Self {
                    Self::from_bits_truncate(!self.bits)
                }
            }
            impl ::bitflags::_core::ops::BitOr for Sdflags {
                type Output = Self;
                /// Returns the union of the two sets of flags.
                #[inline]
                fn bitor(self, other: Sdflags) -> Self {
                    Self {
                        bits: self.bits | other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitOrAssign for Sdflags {
                /// Adds the set of flags.
                #[inline]
                fn bitor_assign(&mut self, other: Self) {
                    self.bits |= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitXor for Sdflags {
                type Output = Self;
                /// Returns the left flags, but with all the right flags toggled.
                #[inline]
                fn bitxor(self, other: Self) -> Self {
                    Self {
                        bits: self.bits ^ other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitXorAssign for Sdflags {
                /// Toggles the set of flags.
                #[inline]
                fn bitxor_assign(&mut self, other: Self) {
                    self.bits ^= other.bits;
                }
            }
            impl ::bitflags::_core::ops::BitAnd for Sdflags {
                type Output = Self;
                /// Returns the intersection between the two sets of flags.
                #[inline]
                fn bitand(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::BitAndAssign for Sdflags {
                /// Disables all flags disabled in the set.
                #[inline]
                fn bitand_assign(&mut self, other: Self) {
                    self.bits &= other.bits;
                }
            }
            impl ::bitflags::_core::ops::Sub for Sdflags {
                type Output = Self;
                /// Returns the set difference of the two sets of flags.
                #[inline]
                fn sub(self, other: Self) -> Self {
                    Self {
                        bits: self.bits & !other.bits,
                    }
                }
            }
            impl ::bitflags::_core::ops::SubAssign for Sdflags {
                /// Disables all flags enabled in the set.
                #[inline]
                fn sub_assign(&mut self, other: Self) {
                    self.bits &= !other.bits;
                }
            }
            impl ::bitflags::_core::ops::Not for Sdflags {
                type Output = Self;
                /// Returns the complement of this set of flags.
                #[inline]
                fn not(self) -> Self {
                    Self { bits: !self.bits } & Self::all()
                }
            }
            impl ::bitflags::_core::iter::Extend<Sdflags> for Sdflags {
                fn extend<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    &mut self,
                    iterator: T,
                ) {
                    for item in iterator {
                        self.insert(item)
                    }
                }
            }
            impl ::bitflags::_core::iter::FromIterator<Sdflags> for Sdflags {
                fn from_iter<T: ::bitflags::_core::iter::IntoIterator<Item = Self>>(
                    iterator: T,
                ) -> Self {
                    let mut result = Self::empty();
                    result.extend(iterator);
                    result
                }
            }
            impl ::std::fmt::Display for Sdflags {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    f.write_str("Sdflags")?;
                    f.write_str("(")?;
                    ::std::fmt::Debug::fmt(self, f)?;
                    f.write_str(" (0x")?;
                    ::std::fmt::LowerHex::fmt(&self.bits, f)?;
                    f.write_str("))")?;
                    Ok(())
                }
            }
            impl TryFrom<u8> for Sdflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Self, wiggle::GuestError> {
                    if u8::from(!Sdflags::all()) & value != 0 {
                        Err(wiggle::GuestError::InvalidFlagValue("Sdflags"))
                    } else {
                        Ok(Sdflags { bits: value })
                    }
                }
            }
            impl TryFrom<i32> for Sdflags {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Self, wiggle::GuestError> {
                    Sdflags::try_from(u8::try_from(value)?)
                }
            }
            impl From<Sdflags> for u8 {
                #[inline]
                fn from(e: Sdflags) -> u8 {
                    e.bits
                }
            }
            impl<'a> wiggle::GuestType<'a> for Sdflags {
                #[inline]
                fn guest_size() -> u32 {
                    u8::guest_size()
                }
                #[inline]
                fn guest_align() -> usize {
                    u8::guest_align()
                }
                fn read(
                    location: &wiggle::GuestPtr<Sdflags>,
                ) -> Result<Sdflags, wiggle::GuestError> {
                    use std::convert::TryFrom;
                    let reprval = u8::read(&location.cast())?;
                    let value = Sdflags::try_from(reprval)?;
                    Ok(value)
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Sdflags>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    let val: u8 = u8::from(val);
                    u8::write(&location.cast(), val)
                }
            }
            pub enum Preopentype {
                Dir,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Preopentype {
                #[inline]
                fn clone(&self) -> Preopentype {
                    *self
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Preopentype {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::write_str(f, "Dir")
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Preopentype {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Preopentype {
                #[inline]
                fn eq(&self, other: &Preopentype) -> bool {
                    true
                }
            }
            #[automatically_derived]
            impl ::core::marker::Copy for Preopentype {}
            impl TryFrom<u8> for Preopentype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: u8) -> Result<Preopentype, wiggle::GuestError> {
                    match value {
                        0 => Ok(Preopentype::Dir),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Preopentype")),
                    }
                }
            }
            impl TryFrom<i32> for Preopentype {
                type Error = wiggle::GuestError;
                #[inline]
                fn try_from(value: i32) -> Result<Preopentype, wiggle::GuestError> {
                    Preopentype::try_from(u8::try_from(value)?)
                }
            }
            impl From<Preopentype> for u8 {
                #[inline]
                fn from(v: Preopentype) -> u8 {
                    match v {
                        Preopentype::Dir => 0,
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Preopentype {
                #[inline]
                fn guest_size() -> u32 {
                    1u32
                }
                #[inline]
                fn guest_align() -> usize {
                    1usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => Ok(Preopentype::Dir),
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Preopentype")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Preopentype::Dir => {
                            location.cast().write(0usize as u8)?;
                        }
                    }
                    Ok(())
                }
            }
            pub struct PrestatDir {
                pub pr_name_len: Size,
            }
            #[automatically_derived]
            impl ::core::clone::Clone for PrestatDir {
                #[inline]
                fn clone(&self) -> PrestatDir {
                    PrestatDir {
                        pr_name_len: ::core::clone::Clone::clone(&self.pr_name_len),
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for PrestatDir {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    ::core::fmt::Formatter::debug_struct_field1_finish(
                        f,
                        "PrestatDir",
                        "pr_name_len",
                        &&self.pr_name_len,
                    )
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for PrestatDir {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for PrestatDir {
                #[inline]
                fn eq(&self, other: &PrestatDir) -> bool {
                    self.pr_name_len == other.pr_name_len
                }
            }
            impl<'a> wiggle::GuestType<'a> for PrestatDir {
                #[inline]
                fn guest_size() -> u32 {
                    4u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let pr_name_len = <Size as wiggle::GuestType>::read(
                        &location.cast::<u8>().add(0u32)?.cast(),
                    )?;
                    Ok(PrestatDir { pr_name_len })
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    wiggle::GuestType::write(
                        &location.cast::<u8>().add(0u32)?.cast(),
                        val.pr_name_len,
                    )?;
                    Ok(())
                }
            }
            pub enum Prestat {
                Dir(PrestatDir),
            }
            #[automatically_derived]
            impl ::core::clone::Clone for Prestat {
                #[inline]
                fn clone(&self) -> Prestat {
                    match self {
                        Prestat::Dir(__self_0) => {
                            Prestat::Dir(::core::clone::Clone::clone(__self_0))
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::fmt::Debug for Prestat {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match self {
                        Prestat::Dir(__self_0) => {
                            ::core::fmt::Formatter::debug_tuple_field1_finish(
                                f,
                                "Dir",
                                &__self_0,
                            )
                        }
                    }
                }
            }
            #[automatically_derived]
            impl ::core::marker::StructuralPartialEq for Prestat {}
            #[automatically_derived]
            impl ::core::cmp::PartialEq for Prestat {
                #[inline]
                fn eq(&self, other: &Prestat) -> bool {
                    match (self, other) {
                        (Prestat::Dir(__self_0), Prestat::Dir(__arg1_0)) => {
                            *__self_0 == *__arg1_0
                        }
                    }
                }
            }
            impl<'a> wiggle::GuestType<'a> for Prestat {
                #[inline]
                fn guest_size() -> u32 {
                    8u32
                }
                #[inline]
                fn guest_align() -> usize {
                    4usize
                }
                fn read(
                    location: &wiggle::GuestPtr<'a, Self>,
                ) -> Result<Self, wiggle::GuestError> {
                    let tag = location.cast::<u8>().read()?;
                    match tag {
                        0 => {
                            let variant_ptr = location.cast::<u8>().add(4u32)?;
                            let variant_val = <PrestatDir as wiggle::GuestType>::read(
                                &variant_ptr.cast(),
                            )?;
                            Ok(Prestat::Dir(variant_val))
                        }
                        _ => Err(wiggle::GuestError::InvalidEnumValue("Prestat")),
                    }
                }
                fn write(
                    location: &wiggle::GuestPtr<'_, Self>,
                    val: Self,
                ) -> Result<(), wiggle::GuestError> {
                    match val {
                        Prestat::Dir(contents) => {
                            location.cast().write(0usize as u8)?;
                            let variant_ptr = location.cast::<u8>().add(4u32)?;
                            <PrestatDir as wiggle::GuestType>::write(
                                &variant_ptr.cast(),
                                contents,
                            )?;
                        }
                    }
                    Ok(())
                }
            }
            pub trait UserErrorConversion {}
        }
        pub mod wasi_snapshot_preview1 {
            use super::types::*;
            pub use super::types::UserErrorConversion;
            #[allow(unreachable_code)]
            pub fn args_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"args_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"args_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let argv = wiggle::GuestPtr::<
                        wiggle::GuestPtr<'_, u8>,
                    >::new(memory, arg0 as u32);
                    let argv_buf = wiggle::GuestPtr::<u8>::new(memory, arg1 as u32);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["argv", "argv_buf"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&argv) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&argv_buf) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&argv) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&argv_buf) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::args_get(ctx, &argv, &argv_buf)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn args_sizes_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"args_sizes_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"args_sizes_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let ret = WasiSnapshotPreview1::args_sizes_get(ctx).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                let (t0, t1) = e;
                                wiggle::GuestPtr::<Size>::new(memory, arg1 as u32)
                                    .write(t1)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "args_sizes_get",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                wiggle::GuestPtr::<Size>::new(memory, arg0 as u32)
                                    .write(t0)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "args_sizes_get",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn environ_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"environ_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"environ_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let environ = wiggle::GuestPtr::<
                        wiggle::GuestPtr<'_, u8>,
                    >::new(memory, arg0 as u32);
                    let environ_buf = wiggle::GuestPtr::<u8>::new(memory, arg1 as u32);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["environ", "environ_buf"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&environ) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&environ_buf) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&environ) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&environ_buf) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::environ_get(
                            ctx,
                            &environ,
                            &environ_buf,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn environ_sizes_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"environ_sizes_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"environ_sizes_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let ret = WasiSnapshotPreview1::environ_sizes_get(ctx).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                let (t0, t1) = e;
                                wiggle::GuestPtr::<Size>::new(memory, arg1 as u32)
                                    .write(t1)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "environ_sizes_get",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                wiggle::GuestPtr::<Size>::new(memory, arg0 as u32)
                                    .write(t0)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "environ_sizes_get",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn clock_res_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"clock_res_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"clock_res_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let id = Clockid::try_from(arg0)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "clock_res_get",
                                location: "convert Clockid",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["id"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&id) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&id) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::clock_res_get(ctx, id).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Timestamp>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "clock_res_get",
                                            location: "write timestamp",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn clock_time_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"clock_time_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"clock_time_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let id = Clockid::try_from(arg0)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "clock_time_get",
                                location: "convert Clockid",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let precision = arg1 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["id", "precision"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&id) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&precision) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&id) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&precision) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::clock_time_get(ctx, id, precision)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Timestamp>::new(memory, arg2 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "clock_time_get",
                                            location: "write timestamp",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_advise<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i64,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_advise" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_advise" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let offset = arg1 as u64;
                    let len = arg2 as u64;
                    let advice = Advice::try_from(arg3)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "fd_advise",
                                location: "convert Advice",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "offset", "len", "advice"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&len) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&advice) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&len) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&advice) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_advise(
                            ctx,
                            fd,
                            offset,
                            len,
                            advice,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_allocate<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i64,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_allocate" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_allocate" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let offset = arg1 as u64;
                    let len = arg2 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "offset", "len"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&len) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&len) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_allocate(ctx, fd, offset, len)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_close<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_close" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_close" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_close(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_datasync<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_datasync" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_datasync" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_datasync(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_fdstat_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_fdstat_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_fdstat_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_fdstat_get(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Fdstat>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_fdstat_get",
                                            location: "write fdstat",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_fdstat_set_flags<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_fdstat_set_flags" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_fdstat_set_flags" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let flags = Fdflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "fd_fdstat_set_flags",
                                location: "convert Fdflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_fdstat_set_flags(ctx, fd, flags)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_fdstat_set_rights<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i64,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_fdstat_set_rights" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_fdstat_set_rights" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let fs_rights_base = Rights::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "fd_fdstat_set_rights",
                                location: "convert Rights",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let fs_rights_inheriting = Rights::try_from(arg2)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "fd_fdstat_set_rights",
                                location: "convert Rights",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "fs_rights_base", "fs_rights_inheriting"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::debug(&fs_rights_base) as &Value,
                                                ),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::debug(&fs_rights_inheriting)
                                                        as &Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::debug(&fs_rights_base) as &Value,
                                                                            ),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::debug(&fs_rights_inheriting)
                                                                                    as &Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_fdstat_set_rights(
                            ctx,
                            fd,
                            fs_rights_base,
                            fs_rights_inheriting,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_filestat_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_filestat_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_filestat_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_filestat_get(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Filestat>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_filestat_get",
                                            location: "write filestat",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_filestat_set_size<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_filestat_set_size" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_filestat_set_size" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let size = arg1 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "size"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&size) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&size) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_filestat_set_size(ctx, fd, size)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_filestat_set_times<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i64,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_filestat_set_times" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_filestat_set_times" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let atim = arg1 as u64;
                    let mtim = arg2 as u64;
                    let fst_flags = Fstflags::try_from(arg3)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "fd_filestat_set_times",
                                location: "convert Fstflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "atim", "mtim", "fst_flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&atim) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&mtim) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&fst_flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&atim) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&mtim) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&fst_flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_filestat_set_times(
                            ctx,
                            fd,
                            atim,
                            mtim,
                            fst_flags,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_pread<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i64,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_pread" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_pread" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let iovs = wiggle::GuestPtr::<
                        [Iovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let offset = arg3 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "iovs", "offset"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_pread(ctx, fd, &iovs, offset)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_pread",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_prestat_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_prestat_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_prestat_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_prestat_get(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Prestat>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_prestat_get",
                                            location: "write prestat",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_prestat_dir_name<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_prestat_dir_name" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_prestat_dir_name" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<u8>::new(memory, arg1 as u32);
                    let path_len = arg2 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path", "path_len"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&path_len) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&path_len) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_prestat_dir_name(
                            ctx,
                            fd,
                            &path,
                            path_len,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_pwrite<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i64,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_pwrite" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_pwrite" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let iovs = wiggle::GuestPtr::<
                        [Ciovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let offset = arg3 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "iovs", "offset"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_pwrite(ctx, fd, &iovs, offset)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_pwrite",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_read<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_read" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_read" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let iovs = wiggle::GuestPtr::<
                        [Iovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "iovs"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_read(ctx, fd, &iovs).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg3 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_read",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_readdir<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i64,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_readdir" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_readdir" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let buf = wiggle::GuestPtr::<u8>::new(memory, arg1 as u32);
                    let buf_len = arg2 as u32;
                    let cookie = arg3 as u64;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "buf", "buf_len", "cookie"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&cookie) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&cookie) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_readdir(
                            ctx,
                            fd,
                            &buf,
                            buf_len,
                            cookie,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_readdir",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_renumber<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_renumber" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_renumber" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let to = Fd::from(arg1);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "to"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&to) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&to) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_renumber(ctx, fd, to).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_seek<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i64,
                arg2: i32,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_seek" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_seek" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let offset = arg1;
                    let whence = Whence::try_from(arg2)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "fd_seek",
                                location: "convert Whence",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "offset", "whence"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&offset) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&whence) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&offset) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&whence) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_seek(ctx, fd, offset, whence)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Filesize>::new(memory, arg3 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_seek",
                                            location: "write filesize",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_sync<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_sync" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_sync" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_sync(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_tell<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_tell" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_tell" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_tell(ctx, fd).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Filesize>::new(memory, arg1 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_tell",
                                            location: "write filesize",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn fd_write<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"fd_write" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"fd_write" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let iovs = wiggle::GuestPtr::<
                        [Ciovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "iovs"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&iovs) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::fd_write(ctx, fd, &iovs).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg3 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "fd_write",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_create_directory<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_create_directory" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_create_directory" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_create_directory(ctx, fd, &path)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_filestat_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_filestat_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_filestat_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let flags = Lookupflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_filestat_get",
                                location: "convert Lookupflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg2 as u32, arg3 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "flags", "path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_filestat_get(
                            ctx,
                            fd,
                            flags,
                            &path,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Filestat>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "path_filestat_get",
                                            location: "write filestat",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_filestat_set_times<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i64,
                arg5: i64,
                arg6: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_filestat_set_times" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_filestat_set_times" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let flags = Lookupflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_filestat_set_times",
                                location: "convert Lookupflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg2 as u32, arg3 as u32));
                    let atim = arg4 as u64;
                    let mtim = arg5 as u64;
                    let fst_flags = Fstflags::try_from(arg6)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_filestat_set_times",
                                location: "convert Fstflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "flags", "path", "atim", "mtim", "fst_flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&atim) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&mtim) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&fst_flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&atim) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&mtim) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&fst_flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_filestat_set_times(
                            ctx,
                            fd,
                            flags,
                            &path,
                            atim,
                            mtim,
                            fst_flags,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_link<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i32,
                arg6: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_link" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_link" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let old_fd = Fd::from(arg0);
                    let old_flags = Lookupflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_link",
                                location: "convert Lookupflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let old_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg2 as u32, arg3 as u32));
                    let new_fd = Fd::from(arg4);
                    let new_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg5 as u32, arg6 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["old_fd", "old_flags", "old_path", "new_fd", "new_path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&old_fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&old_flags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&new_fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&old_fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&old_flags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&new_fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_link(
                            ctx,
                            old_fd,
                            old_flags,
                            &old_path,
                            new_fd,
                            &new_path,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_open<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i64,
                arg6: i64,
                arg7: i32,
                arg8: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_open" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_open" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let dirflags = Lookupflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_open",
                                location: "convert Lookupflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg2 as u32, arg3 as u32));
                    let oflags = Oflags::try_from(arg4)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_open",
                                location: "convert Oflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let fs_rights_base = Rights::try_from(arg5)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_open",
                                location: "convert Rights",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let fs_rights_inheriting = Rights::try_from(arg6)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_open",
                                location: "convert Rights",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    let fdflags = Fdflags::try_from(arg7)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "path_open",
                                location: "convert Fdflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &[
                                            "fd",
                                            "dirflags",
                                            "path",
                                            "oflags",
                                            "fs_rights_base",
                                            "fs_rights_inheriting",
                                            "fdflags",
                                        ],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&dirflags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&oflags) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::debug(&fs_rights_base) as &Value,
                                                ),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::debug(&fs_rights_inheriting)
                                                        as &Value,
                                                ),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&fdflags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&dirflags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&oflags) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::debug(&fs_rights_base) as &Value,
                                                                            ),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::debug(&fs_rights_inheriting)
                                                                                    as &Value,
                                                                            ),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&fdflags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_open(
                            ctx,
                            fd,
                            dirflags,
                            &path,
                            oflags,
                            fs_rights_base,
                            fs_rights_inheriting,
                            fdflags,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Fd>::new(memory, arg8 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "path_open",
                                            location: "write fd",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_readlink<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_readlink" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_readlink" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let buf = wiggle::GuestPtr::<u8>::new(memory, arg3 as u32);
                    let buf_len = arg4 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path", "buf", "buf_len"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_readlink(
                            ctx,
                            fd,
                            &path,
                            &buf,
                            buf_len,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg5 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "path_readlink",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_remove_directory<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_remove_directory" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_remove_directory" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_remove_directory(ctx, fd, &path)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_rename<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_rename" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_rename" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let old_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let new_fd = Fd::from(arg3);
                    let new_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg4 as u32, arg5 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "old_path", "new_fd", "new_path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&new_fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&new_fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_rename(
                            ctx,
                            fd,
                            &old_path,
                            new_fd,
                            &new_path,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_symlink<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_symlink" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_symlink" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let old_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg0 as u32, arg1 as u32));
                    let fd = Fd::from(arg2);
                    let new_path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg3 as u32, arg4 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["old_path", "fd", "new_path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&old_path) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&new_path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_symlink(
                            ctx,
                            &old_path,
                            fd,
                            &new_path,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn path_unlink_file<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"path_unlink_file" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"path_unlink_file" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let path = wiggle::GuestPtr::<
                        str,
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "path"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&path) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&path) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::path_unlink_file(ctx, fd, &path)
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn poll_oneoff<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"poll_oneoff" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"poll_oneoff" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let in_ = wiggle::GuestPtr::<Subscription>::new(memory, arg0 as u32);
                    let out = wiggle::GuestPtr::<Event>::new(memory, arg1 as u32);
                    let nsubscriptions = arg2 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["in_", "out", "nsubscriptions"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&in_) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&out) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(
                                                    &wiggle::tracing::field::display(&nsubscriptions) as &Value,
                                                ),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&in_) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&out) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(
                                                                                &wiggle::tracing::field::display(&nsubscriptions) as &Value,
                                                                            ),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::poll_oneoff(
                            ctx,
                            &in_,
                            &out,
                            nsubscriptions,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg3 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "poll_oneoff",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn proc_exit<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<()>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"proc_exit" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"proc_exit" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let rval = arg0 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["rval"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&rval) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&rval) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::proc_exit(ctx, rval).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Err(ret);
                    return Ok(());
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn proc_raise<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"proc_raise" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"proc_raise" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let sig = Signal::try_from(arg0)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "proc_raise",
                                location: "convert Signal",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["sig"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&sig) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&sig) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::proc_raise(ctx, sig).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sched_yield<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sched_yield" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sched_yield" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let ret = WasiSnapshotPreview1::sched_yield(ctx).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn random_get<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"random_get" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"random_get" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let buf = wiggle::GuestPtr::<u8>::new(memory, arg0 as u32);
                    let buf_len = arg1 as u32;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["buf", "buf_len"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&buf) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&buf_len) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::random_get(ctx, &buf, buf_len).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sock_accept<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sock_accept" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sock_accept" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let flags = Fdflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "sock_accept",
                                location: "convert Fdflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::sock_accept(ctx, fd, flags).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Fd>::new(memory, arg2 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "sock_accept",
                                            location: "write fd",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sock_recv<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
                arg5: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sock_recv" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sock_recv" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let ri_data = wiggle::GuestPtr::<
                        [Iovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let ri_flags = Riflags::try_from(arg3)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "sock_recv",
                                location: "convert Riflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "ri_data", "ri_flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ri_data) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ri_flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ri_data) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ri_flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::sock_recv(
                            ctx,
                            fd,
                            &ri_data,
                            ri_flags,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                let (t0, t1) = e;
                                wiggle::GuestPtr::<Roflags>::new(memory, arg5 as u32)
                                    .write(t1)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "sock_recv",
                                            location: "write roflags",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(t0)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "sock_recv",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sock_send<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
                arg2: i32,
                arg3: i32,
                arg4: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sock_send" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sock_send" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let si_data = wiggle::GuestPtr::<
                        [Ciovec<'_>],
                    >::new(memory, (arg1 as u32, arg2 as u32));
                    let si_flags = u16::try_from(arg3)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "sock_send",
                                location: "convert u16",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "si_data", "si_flags"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&si_data) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&si_flags) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&si_data) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&si_flags) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::sock_send(
                            ctx,
                            fd,
                            &si_data,
                            si_flags,
                        )
                        .await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                wiggle::GuestPtr::<Size>::new(memory, arg4 as u32)
                                    .write(e)
                                    .map_err(|e| {
                                        wiggle::GuestError::InFunc {
                                            modulename: "wasi_snapshot_preview1",
                                            funcname: "sock_send",
                                            location: "write size",
                                            err: Box::new(wiggle::GuestError::from(e)),
                                        }
                                    })?;
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn sock_shutdown<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
                arg0: i32,
                arg1: i32,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"sock_shutdown" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"sock_shutdown" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let fd = Fd::from(arg0);
                    let how = Sdflags::try_from(arg1)
                        .map_err(|e| {
                            wiggle::GuestError::InFunc {
                                modulename: "wasi_snapshot_preview1",
                                funcname: "sock_shutdown",
                                location: "convert Sdflags",
                                err: Box::new(wiggle::GuestError::from(e)),
                            }
                        })?;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["fd", "how"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::display(&fd) as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&how) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::display(&fd) as &Value),
                                                                        ),
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&how) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    let ret = WasiSnapshotPreview1::sock_shutdown(ctx, fd, how).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            #[allow(unreachable_code)]
            pub fn rdma_list<'a>(
                ctx: &'a mut (impl WasiSnapshotPreview1),
                memory: &'a dyn wiggle::GuestMemory,
            ) -> impl std::future::Future<Output = wiggle::anyhow::Result<i32>> + 'a {
                use std::convert::TryFrom as _;
                use wiggle::tracing::Instrument as _;
                let _span = {
                    use ::tracing::__macro_support::Callsite as _;
                    static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                        use ::tracing::__macro_support::MacroCallsite;
                        static META: ::tracing::Metadata<'static> = {
                            ::tracing_core::metadata::Metadata::new(
                                "wiggle abi",
                                "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                wiggle::tracing::Level::TRACE,
                                Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                Some(34u32),
                                Some(
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                ),
                                ::tracing_core::field::FieldSet::new(
                                    &["module", "function"],
                                    ::tracing_core::callsite::Identifier(&CALLSITE),
                                ),
                                ::tracing::metadata::Kind::SPAN,
                            )
                        };
                        MacroCallsite::new(&META)
                    };
                    let mut interest = ::tracing::subscriber::Interest::never();
                    if wiggle::tracing::Level::TRACE
                        <= ::tracing::level_filters::STATIC_MAX_LEVEL
                        && wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::LevelFilter::current()
                        && {
                            interest = CALLSITE.interest();
                            !interest.is_never()
                        } && CALLSITE.is_enabled(interest)
                    {
                        let meta = CALLSITE.metadata();
                        ::tracing::Span::new(
                            meta,
                            &{
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = meta.fields().iter();
                                meta.fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"wasi_snapshot_preview1" as &Value),
                                            ),
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&"rdma_list" as &Value),
                                            ),
                                        ],
                                    )
                            },
                        )
                    } else {
                        let span = CALLSITE.disabled_span();
                        if (match wiggle::tracing::Level::TRACE {
                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                            _ => ::tracing::log::Level::Trace,
                        }) <= ::tracing::log::STATIC_MAX_LEVEL
                        {
                            if !::tracing::dispatcher::has_been_set() {
                                {
                                    span.record_all(
                                        &{
                                            #[allow(unused_imports)]
                                            use ::tracing::field::{debug, display, Value};
                                            let mut iter = CALLSITE.metadata().fields().iter();
                                            CALLSITE
                                                .metadata()
                                                .fields()
                                                .value_set(
                                                    &[
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"wasi_snapshot_preview1" as &Value),
                                                        ),
                                                        (
                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                            Some(&"rdma_list" as &Value),
                                                        ),
                                                    ],
                                                )
                                        },
                                    );
                                }
                            } else {
                                {}
                            }
                        } else {
                            {}
                        };
                        span
                    }
                };
                async move {
                    let ret = WasiSnapshotPreview1::rdma_list(ctx).await;
                    {
                        use ::tracing::__macro_support::Callsite as _;
                        static CALLSITE: ::tracing::__macro_support::MacroCallsite = {
                            use ::tracing::__macro_support::MacroCallsite;
                            static META: ::tracing::Metadata<'static> = {
                                ::tracing_core::metadata::Metadata::new(
                                    "event crates/wasi-common/src/snapshots/preview_1.rs:34",
                                    "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    wiggle::tracing::Level::TRACE,
                                    Some("crates/wasi-common/src/snapshots/preview_1.rs"),
                                    Some(34u32),
                                    Some(
                                        "wasi_common::snapshots::preview_1::wasi_snapshot_preview1",
                                    ),
                                    ::tracing_core::field::FieldSet::new(
                                        &["result"],
                                        ::tracing_core::callsite::Identifier(&CALLSITE),
                                    ),
                                    ::tracing::metadata::Kind::EVENT,
                                )
                            };
                            MacroCallsite::new(&META)
                        };
                        let enabled = wiggle::tracing::Level::TRACE
                            <= ::tracing::level_filters::STATIC_MAX_LEVEL
                            && wiggle::tracing::Level::TRACE
                                <= ::tracing::level_filters::LevelFilter::current()
                            && {
                                let interest = CALLSITE.interest();
                                !interest.is_never() && CALLSITE.is_enabled(interest)
                            };
                        if enabled {
                            (|value_set: ::tracing::field::ValueSet| {
                                let meta = CALLSITE.metadata();
                                ::tracing::Event::dispatch(meta, &value_set);
                                if (match wiggle::tracing::Level::TRACE {
                                    ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                    ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                    ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                    ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                    _ => ::tracing::log::Level::Trace,
                                }) <= ::tracing::log::STATIC_MAX_LEVEL
                                {
                                    if !::tracing::dispatcher::has_been_set() {
                                        {
                                            use ::tracing::log;
                                            let level = match wiggle::tracing::Level::TRACE {
                                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                                _ => ::tracing::log::Level::Trace,
                                            };
                                            if level <= log::max_level() {
                                                let log_meta = log::Metadata::builder()
                                                    .level(level)
                                                    .target(CALLSITE.metadata().target())
                                                    .build();
                                                let logger = log::logger();
                                                if logger.enabled(&log_meta) {
                                                    CALLSITE.log(logger, log_meta, &value_set)
                                                }
                                            }
                                        }
                                    } else {
                                        {}
                                    }
                                } else {
                                    {}
                                };
                            })({
                                #[allow(unused_imports)]
                                use ::tracing::field::{debug, display, Value};
                                let mut iter = CALLSITE.metadata().fields().iter();
                                CALLSITE
                                    .metadata()
                                    .fields()
                                    .value_set(
                                        &[
                                            (
                                                &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                            ),
                                        ],
                                    )
                            });
                        } else {
                            if (match wiggle::tracing::Level::TRACE {
                                ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                _ => ::tracing::log::Level::Trace,
                            }) <= ::tracing::log::STATIC_MAX_LEVEL
                            {
                                if !::tracing::dispatcher::has_been_set() {
                                    {
                                        use ::tracing::log;
                                        let level = match wiggle::tracing::Level::TRACE {
                                            ::tracing::Level::ERROR => ::tracing::log::Level::Error,
                                            ::tracing::Level::WARN => ::tracing::log::Level::Warn,
                                            ::tracing::Level::INFO => ::tracing::log::Level::Info,
                                            ::tracing::Level::DEBUG => ::tracing::log::Level::Debug,
                                            _ => ::tracing::log::Level::Trace,
                                        };
                                        if level <= log::max_level() {
                                            let log_meta = log::Metadata::builder()
                                                .level(level)
                                                .target(CALLSITE.metadata().target())
                                                .build();
                                            let logger = log::logger();
                                            if logger.enabled(&log_meta) {
                                                CALLSITE
                                                    .log(
                                                        logger,
                                                        log_meta,
                                                        &{
                                                            #[allow(unused_imports)]
                                                            use ::tracing::field::{debug, display, Value};
                                                            let mut iter = CALLSITE.metadata().fields().iter();
                                                            CALLSITE
                                                                .metadata()
                                                                .fields()
                                                                .value_set(
                                                                    &[
                                                                        (
                                                                            &iter.next().expect("FieldSet corrupted (this is a bug)"),
                                                                            Some(&wiggle::tracing::field::debug(&ret) as &Value),
                                                                        ),
                                                                    ],
                                                                )
                                                        },
                                                    )
                                            }
                                        }
                                    }
                                } else {
                                    {}
                                }
                            } else {
                                {}
                            };
                        }
                    };
                    return Ok(
                        match ret {
                            Ok(e) => {
                                <Errno as wiggle::GuestErrorType>::success() as i32
                            }
                            Err(e) => e.downcast()? as i32,
                        },
                    );
                }
                    .instrument(_span)
            }
            pub trait WasiSnapshotPreview1 {
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn args_get<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    argv: &'life1 wiggle::GuestPtr<'a, wiggle::GuestPtr<'a, u8>>,
                    argv_buf: &'life2 wiggle::GuestPtr<'a, u8>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn args_sizes_get<'life0, 'async_trait>(
                    &'life0 mut self,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(Size, Size), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn environ_get<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    environ: &'life1 wiggle::GuestPtr<'a, wiggle::GuestPtr<'a, u8>>,
                    environ_buf: &'life2 wiggle::GuestPtr<'a, u8>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn environ_sizes_get<'life0, 'async_trait>(
                    &'life0 mut self,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(Size, Size), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn clock_res_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    id: Clockid,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Timestamp, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn clock_time_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    id: Clockid,
                    precision: Timestamp,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Timestamp, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_advise<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    offset: Filesize,
                    len: Filesize,
                    advice: Advice,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_allocate<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    offset: Filesize,
                    len: Filesize,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_close<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_datasync<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_fdstat_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Fdstat, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_fdstat_set_flags<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    flags: Fdflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_fdstat_set_rights<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    fs_rights_base: Rights,
                    fs_rights_inheriting: Rights,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_filestat_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Filestat, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_filestat_set_size<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    size: Filesize,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_filestat_set_times<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    atim: Timestamp,
                    mtim: Timestamp,
                    fst_flags: Fstflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_pread<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    iovs: &'life1 IovecArray<'a>,
                    offset: Filesize,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_prestat_get<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Prestat, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_prestat_dir_name<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, u8>,
                    path_len: Size,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_pwrite<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    iovs: &'life1 CiovecArray<'a>,
                    offset: Filesize,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_read<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    iovs: &'life1 IovecArray<'a>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_readdir<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    buf: &'life1 wiggle::GuestPtr<'a, u8>,
                    buf_len: Size,
                    cookie: Dircookie,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_renumber<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    to: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_seek<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    offset: Filedelta,
                    whence: Whence,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Filesize, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_sync<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_tell<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Filesize, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn fd_write<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    iovs: &'life1 CiovecArray<'a>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_create_directory<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_filestat_get<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    flags: Lookupflags,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Filestat, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_filestat_set_times<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    flags: Lookupflags,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                    atim: Timestamp,
                    mtim: Timestamp,
                    fst_flags: Fstflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_link<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    old_fd: Fd,
                    old_flags: Lookupflags,
                    old_path: &'life1 wiggle::GuestPtr<'a, str>,
                    new_fd: Fd,
                    new_path: &'life2 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_open<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    dirflags: Lookupflags,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                    oflags: Oflags,
                    fs_rights_base: Rights,
                    fs_rights_inheriting: Rights,
                    fdflags: Fdflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Fd, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_readlink<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                    buf: &'life2 wiggle::GuestPtr<'a, u8>,
                    buf_len: Size,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_remove_directory<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_rename<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    old_path: &'life1 wiggle::GuestPtr<'a, str>,
                    new_fd: Fd,
                    new_path: &'life2 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_symlink<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    old_path: &'life1 wiggle::GuestPtr<'a, str>,
                    fd: Fd,
                    new_path: &'life2 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn path_unlink_file<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    path: &'life1 wiggle::GuestPtr<'a, str>,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn poll_oneoff<'a, 'life0, 'life1, 'life2, 'async_trait>(
                    &'life0 mut self,
                    in_: &'life1 wiggle::GuestPtr<'a, Subscription>,
                    out: &'life2 wiggle::GuestPtr<'a, Event>,
                    nsubscriptions: Size,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    'life2: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn proc_exit<'life0, 'async_trait>(
                    &'life0 mut self,
                    rval: Exitcode,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = wiggle::anyhow::Error,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn proc_raise<'life0, 'async_trait>(
                    &'life0 mut self,
                    sig: Signal,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sched_yield<'life0, 'async_trait>(
                    &'life0 mut self,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn random_get<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    buf: &'life1 wiggle::GuestPtr<'a, u8>,
                    buf_len: Size,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sock_accept<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    flags: Fdflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Fd, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sock_recv<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    ri_data: &'life1 IovecArray<'a>,
                    ri_flags: Riflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(Size, Roflags), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sock_send<'a, 'life0, 'life1, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    si_data: &'life1 CiovecArray<'a>,
                    si_flags: Siflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<Size, Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'a: 'async_trait,
                    'life0: 'async_trait,
                    'life1: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn sock_shutdown<'life0, 'async_trait>(
                    &'life0 mut self,
                    fd: Fd,
                    how: Sdflags,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
                #[must_use]
                #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
                fn rdma_list<'life0, 'async_trait>(
                    &'life0 mut self,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<
                            Output = Result<(), Error>,
                        > + ::core::marker::Send + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait;
            }
        }
        impl wiggle::GuestErrorType for types::Errno {
            fn success() -> Self {
                Self::Success
            }
        }
        impl wasi_snapshot_preview1::WasiSnapshotPreview1 for WasiCtx {
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn args_get<'b, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                argv: &'life1 GuestPtr<'b, GuestPtr<'b, u8>>,
                argv_buf: &'life2 GuestPtr<'b, u8>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'b: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(), Error> = {
                        __self.args.write_to_guest(argv_buf, argv)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn args_sizes_get<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(types::Size, types::Size), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<(types::Size, types::Size), Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(types::Size, types::Size), Error> = {
                        Ok((
                            __self.args.number_elements(),
                            __self.args.cumulative_size(),
                        ))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn environ_get<'b, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                environ: &'life1 GuestPtr<'b, GuestPtr<'b, u8>>,
                environ_buf: &'life2 GuestPtr<'b, u8>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'b: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(), Error> = {
                        __self.env.write_to_guest(environ_buf, environ)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn environ_sizes_get<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(types::Size, types::Size), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<(types::Size, types::Size), Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(types::Size, types::Size), Error> = {
                        Ok((__self.env.number_elements(), __self.env.cumulative_size()))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn clock_res_get<'life0, 'async_trait>(
                &'life0 mut self,
                id: types::Clockid,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Timestamp, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Timestamp, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let id = id;
                    let __ret: Result<types::Timestamp, Error> = {
                        let resolution = match id {
                            types::Clockid::Realtime => {
                                Ok(__self.clocks.system()?.resolution())
                            }
                            types::Clockid::Monotonic => {
                                Ok(__self.clocks.monotonic()?.abs_clock.resolution())
                            }
                            types::Clockid::ProcessCputimeId
                            | types::Clockid::ThreadCputimeId => {
                                Err(
                                    Error::badf()
                                        .context("process and thread clocks are not supported"),
                                )
                            }
                        }?;
                        Ok(resolution.as_nanos().try_into()?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn clock_time_get<'life0, 'async_trait>(
                &'life0 mut self,
                id: types::Clockid,
                precision: types::Timestamp,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Timestamp, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Timestamp, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let id = id;
                    let precision = precision;
                    let __ret: Result<types::Timestamp, Error> = {
                        let precision = Duration::from_nanos(precision);
                        match id {
                            types::Clockid::Realtime => {
                                let now = __self.clocks.system()?.now(precision).into_std();
                                let d = now
                                    .duration_since(std::time::SystemTime::UNIX_EPOCH)
                                    .map_err(|_| {
                                        Error::trap(
                                            anyhow::Error::msg("current time before unix epoch"),
                                        )
                                    })?;
                                Ok(d.as_nanos().try_into()?)
                            }
                            types::Clockid::Monotonic => {
                                let clock = __self.clocks.monotonic()?;
                                let now = clock.abs_clock.now(precision);
                                let d = now.duration_since(clock.creation_time);
                                Ok(d.as_nanos().try_into()?)
                            }
                            types::Clockid::ProcessCputimeId
                            | types::Clockid::ThreadCputimeId => {
                                Err(
                                    Error::badf()
                                        .context("process and thread clocks are not supported"),
                                )
                            }
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_advise<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                offset: types::Filesize,
                len: types::Filesize,
                advice: types::Advice,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let len = len;
                    let advice = advice;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_file(u32::from(fd))?
                            .get_cap(FileCaps::ADVISE)?
                            .advise(offset, len, advice.into())
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_allocate<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                offset: types::Filesize,
                len: types::Filesize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let len = len;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_file(u32::from(fd))?
                            .get_cap(FileCaps::ALLOCATE)?
                            .allocate(offset, len)
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_close<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<(), Error> = {
                        let table = __self.table();
                        let fd = u32::from(fd);
                        if !table.contains_key(fd) {
                            return Err(Error::badf().context("key not in table"));
                        }
                        if table.is::<FileEntry>(fd) {
                            let _ = table.delete::<FileEntry>(fd);
                        } else if table.is::<DirEntry>(fd) {
                            let _ = table.delete::<DirEntry>(fd);
                        } else {
                            return Err(
                                Error::badf()
                                    .context("key does not refer to file or directory"),
                            );
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_datasync<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_file(u32::from(fd))?
                            .get_cap(FileCaps::DATASYNC)?
                            .datasync()
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_fdstat_get<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Fdstat, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Fdstat, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Fdstat, Error> = {
                        let table = __self.table();
                        let fd = u32::from(fd);
                        if table.is::<FileEntry>(fd) {
                            let file_entry: Arc<FileEntry> = table.get(fd)?;
                            let fdstat = file_entry.get_fdstat().await?;
                            Ok(types::Fdstat::from(&fdstat))
                        } else if table.is::<DirEntry>(fd) {
                            let dir_entry: Arc<DirEntry> = table.get(fd)?;
                            let dir_fdstat = dir_entry.get_dir_fdstat();
                            Ok(types::Fdstat::from(&dir_fdstat))
                        } else {
                            Err(Error::badf())
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_fdstat_set_flags<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                flags: types::Fdflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let flags = flags;
                    let __ret: Result<(), Error> = {
                        if let Some(table) = __self.table_mut() {
                            table
                                .get_file_mut(u32::from(fd))?
                                .get_cap_mut(FileCaps::FDSTAT_SET_FLAGS)?
                                .set_fdflags(FdFlags::from(flags))
                                .await
                        } else {
                            {
                                let lvl = ::log::Level::Warn;
                                if lvl <= ::log::STATIC_MAX_LEVEL
                                    && lvl <= ::log::max_level()
                                {
                                    ::log::__private_api_log(
                                        format_args!(
                                            "`fd_fdstat_set_flags` does not work with wasi-threads enabled; see https://github.com/bytecodealliance/wasmtime/issues/5643"
                                        ),
                                        lvl,
                                        &(
                                            "wasi_common::snapshots::preview_1",
                                            "wasi_common::snapshots::preview_1",
                                            "crates/wasi-common/src/snapshots/preview_1.rs",
                                            201u32,
                                        ),
                                        ::log::__private_api::Option::None,
                                    );
                                }
                            };
                            Err(Error::not_supported())
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_fdstat_set_rights<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                fs_rights_base: types::Rights,
                fs_rights_inheriting: types::Rights,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let fs_rights_base = fs_rights_base;
                    let fs_rights_inheriting = fs_rights_inheriting;
                    let __ret: Result<(), Error> = {
                        let table = __self.table();
                        let fd = u32::from(fd);
                        if table.is::<FileEntry>(fd) {
                            let file_entry: Arc<FileEntry> = table.get(fd)?;
                            let file_caps = FileCaps::from(&fs_rights_base);
                            file_entry.drop_caps_to(file_caps)
                        } else if table.is::<DirEntry>(fd) {
                            let dir_entry: Arc<DirEntry> = table.get(fd)?;
                            let dir_caps = DirCaps::from(&fs_rights_base);
                            let file_caps = FileCaps::from(&fs_rights_inheriting);
                            dir_entry.drop_caps_to(dir_caps, file_caps)
                        } else {
                            Err(Error::badf())
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_filestat_get<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Filestat, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Filestat, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Filestat, Error> = {
                        let table = __self.table();
                        let fd = u32::from(fd);
                        if table.is::<FileEntry>(fd) {
                            let filestat = table
                                .get_file(fd)?
                                .get_cap(FileCaps::FILESTAT_GET)?
                                .get_filestat()
                                .await?;
                            Ok(filestat.into())
                        } else if table.is::<DirEntry>(fd) {
                            let filestat = table
                                .get_dir(fd)?
                                .get_cap(DirCaps::FILESTAT_GET)?
                                .get_filestat()
                                .await?;
                            Ok(filestat.into())
                        } else {
                            Err(Error::badf())
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_filestat_set_size<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                size: types::Filesize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let size = size;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_file(u32::from(fd))?
                            .get_cap(FileCaps::FILESTAT_SET_SIZE)?
                            .set_filestat_size(size)
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_filestat_set_times<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                atim: types::Timestamp,
                mtim: types::Timestamp,
                fst_flags: types::Fstflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let atim = atim;
                    let mtim = mtim;
                    let fst_flags = fst_flags;
                    let __ret: Result<(), Error> = {
                        let fd = u32::from(fd);
                        let table = __self.table();
                        let set_atim = fst_flags.contains(types::Fstflags::ATIM);
                        let set_atim_now = fst_flags.contains(types::Fstflags::ATIM_NOW);
                        let set_mtim = fst_flags.contains(types::Fstflags::MTIM);
                        let set_mtim_now = fst_flags.contains(types::Fstflags::MTIM_NOW);
                        let atim = systimespec(set_atim, atim, set_atim_now)
                            .map_err(|e| e.context("atim"))?;
                        let mtim = systimespec(set_mtim, mtim, set_mtim_now)
                            .map_err(|e| e.context("mtim"))?;
                        if table.is::<FileEntry>(fd) {
                            table
                                .get_file(fd)
                                .expect("checked that entry is file")
                                .get_cap(FileCaps::FILESTAT_SET_TIMES)?
                                .set_times(atim, mtim)
                                .await
                        } else if table.is::<DirEntry>(fd) {
                            table
                                .get_dir(fd)
                                .expect("checked that entry is dir")
                                .get_cap(DirCaps::FILESTAT_SET_TIMES)?
                                .set_times(".", atim, mtim, false)
                                .await
                        } else {
                            Err(Error::badf())
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_read<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                iovs: &'life1 types::IovecArray<'a>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::READ)?;
                        let iovs: Vec<wiggle::GuestPtr<[u8]>> = iovs
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Iovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len))
                            })
                            .collect::<Result<_, Error>>()?;
                        let is_shared_memory = iovs
                            .iter()
                            .next()
                            .and_then(|s| Some(s.is_shared_memory()))
                            .unwrap_or(false);
                        let bytes_read: u64 = if is_shared_memory {
                            let iov = iovs.into_iter().next();
                            if let Some(iov) = iov {
                                let mut buffer = ::alloc::vec::from_elem(
                                    0,
                                    (iov.len() as usize).min(MAX_SHARED_BUFFER_SIZE),
                                );
                                let bytes_read = f
                                    .read_vectored(&mut [IoSliceMut::new(&mut buffer)])
                                    .await?;
                                iov.get_range(0..bytes_read.try_into()?)
                                    .expect(
                                        "it should always be possible to slice the iov smaller",
                                    )
                                    .copy_from_slice(&buffer[0..bytes_read.try_into()?])?;
                                bytes_read
                            } else {
                                return Ok(0);
                            }
                        } else {
                            let mut guest_slices: Vec<wiggle::GuestSliceMut<u8>> = iovs
                                .into_iter()
                                .map(|iov| Ok(iov.as_slice_mut()?.unwrap()))
                                .collect::<Result<_, Error>>()?;
                            let mut ioslices: Vec<IoSliceMut> = guest_slices
                                .iter_mut()
                                .map(|s| IoSliceMut::new(&mut *s))
                                .collect();
                            f.read_vectored(&mut ioslices).await?
                        };
                        Ok(types::Size::try_from(bytes_read)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_pread<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                iovs: &'life1 types::IovecArray<'a>,
                offset: types::Filesize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::READ | FileCaps::SEEK)?;
                        let iovs: Vec<wiggle::GuestPtr<[u8]>> = iovs
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Iovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len))
                            })
                            .collect::<Result<_, Error>>()?;
                        let is_shared_memory = iovs
                            .iter()
                            .next()
                            .and_then(|s| Some(s.is_shared_memory()))
                            .unwrap_or(false);
                        let bytes_read: u64 = if is_shared_memory {
                            let iov = iovs.into_iter().next();
                            if let Some(iov) = iov {
                                let mut buffer = ::alloc::vec::from_elem(
                                    0,
                                    (iov.len() as usize).min(MAX_SHARED_BUFFER_SIZE),
                                );
                                let bytes_read = f
                                    .read_vectored_at(
                                        &mut [IoSliceMut::new(&mut buffer)],
                                        offset,
                                    )
                                    .await?;
                                iov.get_range(0..bytes_read.try_into()?)
                                    .expect(
                                        "it should always be possible to slice the iov smaller",
                                    )
                                    .copy_from_slice(&buffer[0..bytes_read.try_into()?])?;
                                bytes_read
                            } else {
                                return Ok(0);
                            }
                        } else {
                            let mut guest_slices: Vec<wiggle::GuestSliceMut<u8>> = iovs
                                .into_iter()
                                .map(|iov| Ok(iov.as_slice_mut()?.unwrap()))
                                .collect::<Result<_, Error>>()?;
                            let mut ioslices: Vec<IoSliceMut> = guest_slices
                                .iter_mut()
                                .map(|s| IoSliceMut::new(&mut *s))
                                .collect();
                            f.read_vectored_at(&mut ioslices, offset).await?
                        };
                        Ok(types::Size::try_from(bytes_read)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_write<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                ciovs: &'life1 types::CiovecArray<'a>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::WRITE)?;
                        let guest_slices: Vec<wiggle::GuestCow<u8>> = ciovs
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Ciovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len).as_cow()?)
                            })
                            .collect::<Result<_, Error>>()?;
                        let ioslices: Vec<IoSlice> = guest_slices
                            .iter()
                            .map(|s| IoSlice::new(s.deref()))
                            .collect();
                        let bytes_written = f.write_vectored(&ioslices).await?;
                        Ok(types::Size::try_from(bytes_written)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_pwrite<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                ciovs: &'life1 types::CiovecArray<'a>,
                offset: types::Filesize,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::WRITE | FileCaps::SEEK)?;
                        let guest_slices: Vec<wiggle::GuestCow<u8>> = ciovs
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Ciovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len).as_cow()?)
                            })
                            .collect::<Result<_, Error>>()?;
                        let ioslices: Vec<IoSlice> = guest_slices
                            .iter()
                            .map(|s| IoSlice::new(s.deref()))
                            .collect();
                        let bytes_written = f
                            .write_vectored_at(&ioslices, offset)
                            .await?;
                        Ok(types::Size::try_from(bytes_written)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_prestat_get<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Prestat, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Prestat, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Prestat, Error> = {
                        let table = __self.table();
                        let dir_entry: Arc<DirEntry> = table
                            .get(u32::from(fd))
                            .map_err(|_| Error::badf())?;
                        if let Some(ref preopen) = dir_entry.preopen_path() {
                            let path_str = preopen
                                .to_str()
                                .ok_or_else(|| Error::not_supported())?;
                            let pr_name_len = u32::try_from(path_str.as_bytes().len())?;
                            Ok(types::Prestat::Dir(types::PrestatDir { pr_name_len }))
                        } else {
                            Err(Error::not_supported().context("file is not a preopen"))
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_prestat_dir_name<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                path: &'life1 GuestPtr<'a, u8>,
                path_max_len: types::Size,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let path_max_len = path_max_len;
                    let __ret: Result<(), Error> = {
                        let table = __self.table();
                        let dir_entry: Arc<DirEntry> = table
                            .get(u32::from(fd))
                            .map_err(|_| Error::not_dir())?;
                        if let Some(ref preopen) = dir_entry.preopen_path() {
                            let path_bytes = preopen
                                .to_str()
                                .ok_or_else(|| Error::not_supported())?
                                .as_bytes();
                            let path_len = path_bytes.len();
                            if path_len < path_max_len as usize {
                                return Err(Error::name_too_long());
                            }
                            path.as_array(path_len as u32).copy_from_slice(path_bytes)?;
                            Ok(())
                        } else {
                            Err(Error::not_supported())
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_renumber<'life0, 'async_trait>(
                &'life0 mut self,
                from: types::Fd,
                to: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let from = from;
                    let to = to;
                    let __ret: Result<(), Error> = {
                        let table = __self.table();
                        let from = u32::from(from);
                        let to = u32::from(to);
                        if !table.contains_key(from) {
                            return Err(Error::badf());
                        }
                        table.renumber(from, to)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_seek<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                offset: types::Filedelta,
                whence: types::Whence,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Filesize, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Filesize, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let offset = offset;
                    let whence = whence;
                    let __ret: Result<types::Filesize, Error> = {
                        use std::io::SeekFrom;
                        let required_caps = if offset == 0
                            && whence == types::Whence::Cur
                        {
                            FileCaps::TELL
                        } else {
                            FileCaps::TELL | FileCaps::SEEK
                        };
                        let whence = match whence {
                            types::Whence::Cur => SeekFrom::Current(offset),
                            types::Whence::End => SeekFrom::End(offset),
                            types::Whence::Set => SeekFrom::Start(offset as u64),
                        };
                        let newoffset = __self
                            .table()
                            .get_file(u32::from(fd))?
                            .get_cap(required_caps)?
                            .seek(whence)
                            .await?;
                        Ok(newoffset)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_sync<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_file(u32::from(fd))?
                            .get_cap(FileCaps::SYNC)?
                            .sync()
                            .await?;
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_tell<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Filesize, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Filesize, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let __ret: Result<types::Filesize, Error> = {
                        let offset = __self
                            .table()
                            .get_file(u32::from(fd))?
                            .get_cap(FileCaps::TELL)?
                            .seek(std::io::SeekFrom::Current(0))
                            .await?;
                        Ok(offset)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn fd_readdir<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                buf: &'life1 GuestPtr<'a, u8>,
                buf_len: types::Size,
                cookie: types::Dircookie,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let buf_len = buf_len;
                    let cookie = cookie;
                    let __ret: Result<types::Size, Error> = {
                        let mut bufused = 0;
                        let mut buf = buf.clone();
                        for entity in __self
                            .table()
                            .get_dir(u32::from(fd))?
                            .get_cap(DirCaps::READDIR)?
                            .readdir(ReaddirCursor::from(cookie))
                            .await?
                        {
                            let entity = entity?;
                            let dirent_raw = dirent_bytes(
                                types::Dirent::try_from(&entity)?,
                            );
                            let dirent_len: types::Size = dirent_raw.len().try_into()?;
                            let name_raw = entity.name.as_bytes();
                            let name_len: types::Size = name_raw.len().try_into()?;
                            let dirent_copy_len = std::cmp::min(
                                dirent_len,
                                buf_len - bufused,
                            );
                            buf.as_array(dirent_copy_len)
                                .copy_from_slice(&dirent_raw[..dirent_copy_len as usize])?;
                            if dirent_copy_len < dirent_len {
                                return Ok(buf_len);
                            }
                            buf = buf.add(dirent_copy_len)?;
                            bufused += dirent_copy_len;
                            let name_copy_len = std::cmp::min(
                                name_len,
                                buf_len - bufused,
                            );
                            buf.as_array(name_copy_len)
                                .copy_from_slice(&name_raw[..name_copy_len as usize])?;
                            if name_copy_len < name_len {
                                return Ok(buf_len);
                            }
                            buf = buf.add(name_copy_len)?;
                            bufused += name_copy_len;
                        }
                        Ok(bufused)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_create_directory<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                path: &'life1 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_dir(u32::from(dirfd))?
                            .get_cap(DirCaps::CREATE_DIRECTORY)?
                            .create_dir(path.as_cow()?.deref())
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_filestat_get<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                flags: types::Lookupflags,
                path: &'life1 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Filestat, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<types::Filestat, Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let flags = flags;
                    let __ret: Result<types::Filestat, Error> = {
                        let filestat = __self
                            .table()
                            .get_dir(u32::from(dirfd))?
                            .get_cap(DirCaps::PATH_FILESTAT_GET)?
                            .get_path_filestat(
                                path.as_cow()?.deref(),
                                flags.contains(types::Lookupflags::SYMLINK_FOLLOW),
                            )
                            .await?;
                        Ok(types::Filestat::from(filestat))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_filestat_set_times<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                flags: types::Lookupflags,
                path: &'life1 GuestPtr<'a, str>,
                atim: types::Timestamp,
                mtim: types::Timestamp,
                fst_flags: types::Fstflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let flags = flags;
                    let atim = atim;
                    let mtim = mtim;
                    let fst_flags = fst_flags;
                    let __ret: Result<(), Error> = {
                        let set_atim = fst_flags.contains(types::Fstflags::ATIM);
                        let set_atim_now = fst_flags.contains(types::Fstflags::ATIM_NOW);
                        let set_mtim = fst_flags.contains(types::Fstflags::MTIM);
                        let set_mtim_now = fst_flags.contains(types::Fstflags::MTIM_NOW);
                        let atim = systimespec(set_atim, atim, set_atim_now)
                            .map_err(|e| e.context("atim"))?;
                        let mtim = systimespec(set_mtim, mtim, set_mtim_now)
                            .map_err(|e| e.context("mtim"))?;
                        __self
                            .table()
                            .get_dir(u32::from(dirfd))?
                            .get_cap(DirCaps::PATH_FILESTAT_SET_TIMES)?
                            .set_times(
                                path.as_cow()?.deref(),
                                atim,
                                mtim,
                                flags.contains(types::Lookupflags::SYMLINK_FOLLOW),
                            )
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_link<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                src_fd: types::Fd,
                src_flags: types::Lookupflags,
                src_path: &'life1 GuestPtr<'a, str>,
                target_fd: types::Fd,
                target_path: &'life2 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let src_fd = src_fd;
                    let src_flags = src_flags;
                    let target_fd = target_fd;
                    let __ret: Result<(), Error> = {
                        let table = __self.table();
                        let src_dir = table.get_dir(u32::from(src_fd))?;
                        let src_dir = src_dir.get_cap(DirCaps::LINK_SOURCE)?;
                        let target_dir = table.get_dir(u32::from(target_fd))?;
                        let target_dir = target_dir.get_cap(DirCaps::LINK_TARGET)?;
                        let symlink_follow = src_flags
                            .contains(types::Lookupflags::SYMLINK_FOLLOW);
                        if symlink_follow {
                            return Err(
                                Error::invalid_argument()
                                    .context("symlink following on path_link is not supported"),
                            );
                        }
                        src_dir
                            .hard_link(
                                src_path.as_cow()?.deref(),
                                target_dir.deref(),
                                target_path.as_cow()?.deref(),
                            )
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_open<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                dirflags: types::Lookupflags,
                path: &'life1 GuestPtr<'a, str>,
                oflags: types::Oflags,
                fs_rights_base: types::Rights,
                fs_rights_inheriting: types::Rights,
                fdflags: types::Fdflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Fd, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Fd, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let dirflags = dirflags;
                    let oflags = oflags;
                    let fs_rights_base = fs_rights_base;
                    let fs_rights_inheriting = fs_rights_inheriting;
                    let fdflags = fdflags;
                    let __ret: Result<types::Fd, Error> = {
                        let table = __self.table();
                        let dirfd = u32::from(dirfd);
                        if table.is::<FileEntry>(dirfd) {
                            return Err(Error::not_dir());
                        }
                        let dir_entry = table.get_dir(dirfd)?;
                        let symlink_follow = dirflags
                            .contains(types::Lookupflags::SYMLINK_FOLLOW);
                        let oflags = OFlags::from(&oflags);
                        let fdflags = FdFlags::from(fdflags);
                        let path = path.as_cow()?;
                        if oflags.contains(OFlags::DIRECTORY) {
                            if oflags.contains(OFlags::CREATE)
                                || oflags.contains(OFlags::EXCLUSIVE)
                                || oflags.contains(OFlags::TRUNCATE)
                            {
                                return Err(
                                    Error::invalid_argument().context("directory oflags"),
                                );
                            }
                            let dir_caps = dir_entry
                                .child_dir_caps(DirCaps::from(&fs_rights_base));
                            let file_caps = dir_entry
                                .child_file_caps(FileCaps::from(&fs_rights_inheriting));
                            let dir = dir_entry.get_cap(DirCaps::OPEN)?;
                            let child_dir = dir
                                .open_dir(symlink_follow, path.deref())
                                .await?;
                            drop(dir);
                            let fd = table
                                .push(
                                    Arc::new(
                                        DirEntry::new(dir_caps, file_caps, None, child_dir),
                                    ),
                                )?;
                            Ok(types::Fd::from(fd))
                        } else {
                            let mut required_caps = DirCaps::OPEN;
                            if oflags.contains(OFlags::CREATE) {
                                required_caps = required_caps | DirCaps::CREATE_FILE;
                            }
                            let file_caps = dir_entry
                                .child_file_caps(FileCaps::from(&fs_rights_base));
                            let dir = dir_entry.get_cap(required_caps)?;
                            let read = file_caps.contains(FileCaps::READ);
                            let write = file_caps.contains(FileCaps::WRITE)
                                || file_caps.contains(FileCaps::ALLOCATE)
                                || file_caps.contains(FileCaps::FILESTAT_SET_SIZE);
                            let file = dir
                                .open_file(
                                    symlink_follow,
                                    path.deref(),
                                    oflags,
                                    read,
                                    write,
                                    fdflags,
                                )
                                .await?;
                            drop(dir);
                            let fd = table
                                .push(Arc::new(FileEntry::new(file_caps, file)))?;
                            Ok(types::Fd::from(fd))
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_readlink<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                path: &'life1 GuestPtr<'a, str>,
                buf: &'life2 GuestPtr<'a, u8>,
                buf_len: types::Size,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let buf_len = buf_len;
                    let __ret: Result<types::Size, Error> = {
                        let link = __self
                            .table()
                            .get_dir(u32::from(dirfd))?
                            .get_cap(DirCaps::READLINK)?
                            .read_link(path.as_cow()?.deref())
                            .await?
                            .into_os_string()
                            .into_string()
                            .map_err(|_| {
                                Error::illegal_byte_sequence().context("link contents")
                            })?;
                        let link_bytes = link.as_bytes();
                        let link_len = link_bytes.len();
                        if link_len > buf_len as usize {
                            return Err(Error::range());
                        }
                        buf.as_array(link_len as u32).copy_from_slice(link_bytes)?;
                        Ok(link_len as types::Size)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_remove_directory<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                path: &'life1 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_dir(u32::from(dirfd))?
                            .get_cap(DirCaps::REMOVE_DIRECTORY)?
                            .remove_dir(path.as_cow()?.deref())
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_rename<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                src_fd: types::Fd,
                src_path: &'life1 GuestPtr<'a, str>,
                dest_fd: types::Fd,
                dest_path: &'life2 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let src_fd = src_fd;
                    let dest_fd = dest_fd;
                    let __ret: Result<(), Error> = {
                        let table = __self.table();
                        let src_dir = table.get_dir(u32::from(src_fd))?;
                        let src_dir = src_dir.get_cap(DirCaps::RENAME_SOURCE)?;
                        let dest_dir = table.get_dir(u32::from(dest_fd))?;
                        let dest_dir = dest_dir.get_cap(DirCaps::RENAME_TARGET)?;
                        src_dir
                            .rename(
                                src_path.as_cow()?.deref(),
                                dest_dir.deref(),
                                dest_path.as_cow()?.deref(),
                            )
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_symlink<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                src_path: &'life1 GuestPtr<'a, str>,
                dirfd: types::Fd,
                dest_path: &'life2 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_dir(u32::from(dirfd))?
                            .get_cap(DirCaps::SYMLINK)?
                            .symlink(
                                src_path.as_cow()?.deref(),
                                dest_path.as_cow()?.deref(),
                            )
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn path_unlink_file<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                dirfd: types::Fd,
                path: &'life1 GuestPtr<'a, str>,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let dirfd = dirfd;
                    let __ret: Result<(), Error> = {
                        __self
                            .table()
                            .get_dir(u32::from(dirfd))?
                            .get_cap(DirCaps::UNLINK_FILE)?
                            .unlink_file(path.as_cow()?.deref())
                            .await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn poll_oneoff<'a, 'life0, 'life1, 'life2, 'async_trait>(
                &'life0 mut self,
                subs: &'life1 GuestPtr<'a, types::Subscription>,
                events: &'life2 GuestPtr<'a, types::Event>,
                nsubscriptions: types::Size,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                'life2: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let nsubscriptions = nsubscriptions;
                    let __ret: Result<types::Size, Error> = {
                        if nsubscriptions == 0 {
                            return Err(
                                Error::invalid_argument()
                                    .context("nsubscriptions must be nonzero"),
                            );
                        }
                        if nsubscriptions == 1 {
                            let sub = subs.read()?;
                            if let types::SubscriptionU::Clock(clocksub) = sub.u {
                                if !clocksub
                                    .flags
                                    .contains(types::Subclockflags::SUBSCRIPTION_CLOCK_ABSTIME)
                                {
                                    __self
                                        .sched
                                        .sleep(Duration::from_nanos(clocksub.timeout))
                                        .await?;
                                    events
                                        .write(types::Event {
                                            userdata: sub.userdata,
                                            error: types::Errno::Success,
                                            type_: types::Eventtype::Clock,
                                            fd_readwrite: fd_readwrite_empty(),
                                        })?;
                                    return Ok(1);
                                }
                            }
                        }
                        let table = &__self.table;
                        let mut read_refs: Vec<(Arc<FileEntry>, Option<Userdata>)> = Vec::new();
                        let mut write_refs: Vec<(Arc<FileEntry>, Option<Userdata>)> = Vec::new();
                        let mut poll = Poll::new();
                        let subs = subs.as_array(nsubscriptions);
                        for sub_elem in subs.iter() {
                            let sub_ptr = sub_elem?;
                            let sub = sub_ptr.read()?;
                            match sub.u {
                                types::SubscriptionU::Clock(clocksub) => {
                                    match clocksub.id {
                                        types::Clockid::Monotonic => {
                                            let clock = __self.clocks.monotonic()?;
                                            let precision = Duration::from_nanos(clocksub.precision);
                                            let duration = Duration::from_nanos(clocksub.timeout);
                                            let start = if clocksub
                                                .flags
                                                .contains(types::Subclockflags::SUBSCRIPTION_CLOCK_ABSTIME)
                                            {
                                                clock.creation_time
                                            } else {
                                                clock.abs_clock.now(precision)
                                            };
                                            let deadline = start
                                                .checked_add(duration)
                                                .ok_or_else(|| Error::overflow().context("deadline"))?;
                                            poll.subscribe_monotonic_clock(
                                                &*clock.abs_clock,
                                                deadline,
                                                precision,
                                                sub.userdata.into(),
                                            )
                                        }
                                        types::Clockid::Realtime => {
                                            let clock = __self.clocks.monotonic()?;
                                            let precision = Duration::from_nanos(clocksub.precision);
                                            let duration = Duration::from_nanos(clocksub.timeout);
                                            let deadline = if clocksub
                                                .flags
                                                .contains(types::Subclockflags::SUBSCRIPTION_CLOCK_ABSTIME)
                                            {
                                                return Err(Error::not_supported());
                                            } else {
                                                clock
                                                    .abs_clock
                                                    .now(precision)
                                                    .checked_add(duration)
                                                    .ok_or_else(|| Error::overflow().context("deadline"))?
                                            };
                                            poll.subscribe_monotonic_clock(
                                                &*clock.abs_clock,
                                                deadline,
                                                precision,
                                                sub.userdata.into(),
                                            )
                                        }
                                        _ => {
                                            Err(
                                                Error::invalid_argument()
                                                    .context("timer subscriptions only support monotonic timer"),
                                            )?
                                        }
                                    }
                                }
                                types::SubscriptionU::FdRead(readsub) => {
                                    let fd = readsub.file_descriptor;
                                    let file_ref = table.get_file(u32::from(fd))?;
                                    let _file = file_ref.get_cap(FileCaps::POLL_READWRITE)?;
                                    read_refs.push((file_ref, Some(sub.userdata.into())));
                                }
                                types::SubscriptionU::FdWrite(writesub) => {
                                    let fd = writesub.file_descriptor;
                                    let file_ref = table.get_file(u32::from(fd))?;
                                    let _file = file_ref.get_cap(FileCaps::POLL_READWRITE)?;
                                    write_refs.push((file_ref, Some(sub.userdata.into())));
                                }
                            }
                        }
                        let mut read_mut_refs: Vec<(&dyn WasiFile, Userdata)> = Vec::new();
                        for (file_lock, userdata) in read_refs.iter_mut() {
                            let file = file_lock.get_cap(FileCaps::POLL_READWRITE)?;
                            read_mut_refs.push((file, userdata.take().unwrap()));
                        }
                        for (f, ud) in read_mut_refs.iter_mut() {
                            poll.subscribe_read(*f, *ud);
                        }
                        let mut write_mut_refs: Vec<(&dyn WasiFile, Userdata)> = Vec::new();
                        for (file_lock, userdata) in write_refs.iter_mut() {
                            let file = file_lock.get_cap(FileCaps::POLL_READWRITE)?;
                            write_mut_refs.push((file, userdata.take().unwrap()));
                        }
                        for (f, ud) in write_mut_refs.iter_mut() {
                            poll.subscribe_write(*f, *ud);
                        }
                        __self.sched.poll_oneoff(&mut poll).await?;
                        let results = poll.results();
                        let num_results = results.len();
                        if !(num_results <= nsubscriptions as usize) {
                            ::core::panicking::panic_fmt(
                                format_args!("results exceeds subscriptions"),
                            )
                        }
                        let events = events
                            .as_array(
                                num_results
                                    .try_into()
                                    .expect("not greater than nsubscriptions"),
                            );
                        for ((result, userdata), event_elem) in results
                            .into_iter()
                            .zip(events.iter())
                        {
                            let event_ptr = event_elem?;
                            let userdata: types::Userdata = userdata.into();
                            event_ptr
                                .write(
                                    match result {
                                        SubscriptionResult::Read(r) => {
                                            let type_ = types::Eventtype::FdRead;
                                            match r {
                                                Ok((nbytes, flags)) => {
                                                    types::Event {
                                                        userdata,
                                                        error: types::Errno::Success,
                                                        type_,
                                                        fd_readwrite: types::EventFdReadwrite {
                                                            nbytes,
                                                            flags: types::Eventrwflags::from(&flags),
                                                        },
                                                    }
                                                }
                                                Err(e) => {
                                                    types::Event {
                                                        userdata,
                                                        error: e.downcast().map_err(Error::trap)?,
                                                        type_,
                                                        fd_readwrite: fd_readwrite_empty(),
                                                    }
                                                }
                                            }
                                        }
                                        SubscriptionResult::Write(r) => {
                                            let type_ = types::Eventtype::FdWrite;
                                            match r {
                                                Ok((nbytes, flags)) => {
                                                    types::Event {
                                                        userdata,
                                                        error: types::Errno::Success,
                                                        type_,
                                                        fd_readwrite: types::EventFdReadwrite {
                                                            nbytes,
                                                            flags: types::Eventrwflags::from(&flags),
                                                        },
                                                    }
                                                }
                                                Err(e) => {
                                                    types::Event {
                                                        userdata,
                                                        error: e.downcast().map_err(Error::trap)?,
                                                        type_,
                                                        fd_readwrite: fd_readwrite_empty(),
                                                    }
                                                }
                                            }
                                        }
                                        SubscriptionResult::MonotonicClock(r) => {
                                            let type_ = types::Eventtype::Clock;
                                            types::Event {
                                                userdata,
                                                error: match r {
                                                    Ok(()) => types::Errno::Success,
                                                    Err(e) => e.downcast().map_err(Error::trap)?,
                                                },
                                                type_,
                                                fd_readwrite: fd_readwrite_empty(),
                                            }
                                        }
                                    },
                                )?;
                        }
                        Ok(num_results.try_into().expect("results fit into memory"))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn proc_exit<'life0, 'async_trait>(
                &'life0 mut self,
                status: types::Exitcode,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = anyhow::Error,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<anyhow::Error> {
                        return __ret;
                    }
                    let mut __self = self;
                    let status = status;
                    let __ret: anyhow::Error = {
                        if status < 126 {
                            I32Exit(status as i32).into()
                        } else {
                            anyhow::Error::msg(
                                "exit with invalid exit status outside of [0..126)",
                            )
                        }
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn proc_raise<'life0, 'async_trait>(
                &'life0 mut self,
                _sig: types::Signal,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let _sig = _sig;
                    let __ret: Result<(), Error> = {
                        Err(Error::trap(anyhow::Error::msg("proc_raise unsupported")))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sched_yield<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(), Error> = { __self.sched.sched_yield().await };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn random_get<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                buf: &'life1 GuestPtr<'a, u8>,
                buf_len: types::Size,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let buf_len = buf_len;
                    let __ret: Result<(), Error> = {
                        let buf = buf.as_array(buf_len);
                        if buf.is_shared_memory() {
                            let mut copied: u32 = 0;
                            while copied < buf.len() {
                                let len = (buf.len() - copied)
                                    .min(MAX_SHARED_BUFFER_SIZE as u32);
                                let mut tmp = ::alloc::vec::from_elem(0, len as usize);
                                __self.random.lock().unwrap().try_fill_bytes(&mut tmp)?;
                                let dest = buf
                                    .get_range(copied..copied + len)
                                    .unwrap()
                                    .as_unsafe_slice_mut()?;
                                dest.copy_from_slice(&tmp)?;
                                copied += len;
                            }
                        } else {
                            let mem = &mut buf.as_slice_mut()?.unwrap();
                            __self.random.lock().unwrap().try_fill_bytes(mem)?;
                        }
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sock_accept<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                flags: types::Fdflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Fd, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Fd, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let flags = flags;
                    let __ret: Result<types::Fd, Error> = {
                        let table = __self.table();
                        let f = table.get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::READ)?;
                        let file = f.sock_accept(FdFlags::from(flags)).await?;
                        let file_caps = FileCaps::READ | FileCaps::WRITE
                            | FileCaps::FDSTAT_SET_FLAGS | FileCaps::POLL_READWRITE
                            | FileCaps::FILESTAT_GET;
                        let fd = table.push(Arc::new(FileEntry::new(file_caps, file)))?;
                        Ok(types::Fd::from(fd))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sock_recv<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                ri_data: &'life1 types::IovecArray<'a>,
                ri_flags: types::Riflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(types::Size, types::Roflags), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<
                            Result<(types::Size, types::Roflags), Error>,
                        > {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let ri_flags = ri_flags;
                    let __ret: Result<(types::Size, types::Roflags), Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::READ)?;
                        let iovs: Vec<wiggle::GuestPtr<[u8]>> = ri_data
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Iovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len))
                            })
                            .collect::<Result<_, Error>>()?;
                        let is_shared_memory = iovs
                            .iter()
                            .next()
                            .and_then(|s| Some(s.is_shared_memory()))
                            .unwrap_or(false);
                        let (bytes_read, ro_flags) = if is_shared_memory {
                            let iov = iovs.into_iter().next();
                            if let Some(iov) = iov {
                                let mut buffer = ::alloc::vec::from_elem(
                                    0,
                                    (iov.len() as usize).min(MAX_SHARED_BUFFER_SIZE),
                                );
                                let (bytes_read, ro_flags) = f
                                    .sock_recv(
                                        &mut [IoSliceMut::new(&mut buffer)],
                                        RiFlags::from(ri_flags),
                                    )
                                    .await?;
                                iov.get_range(0..bytes_read.try_into()?)
                                    .expect(
                                        "it should always be possible to slice the iov smaller",
                                    )
                                    .copy_from_slice(&buffer[0..bytes_read.try_into()?])?;
                                (bytes_read, ro_flags)
                            } else {
                                return Ok((0, RoFlags::empty().into()));
                            }
                        } else {
                            let mut guest_slices: Vec<wiggle::GuestSliceMut<u8>> = iovs
                                .into_iter()
                                .map(|iov| Ok(iov.as_slice_mut()?.unwrap()))
                                .collect::<Result<_, Error>>()?;
                            let mut ioslices: Vec<IoSliceMut> = guest_slices
                                .iter_mut()
                                .map(|s| IoSliceMut::new(&mut *s))
                                .collect();
                            f.sock_recv(&mut ioslices, RiFlags::from(ri_flags)).await?
                        };
                        Ok((types::Size::try_from(bytes_read)?, ro_flags.into()))
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sock_send<'a, 'life0, 'life1, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                si_data: &'life1 types::CiovecArray<'a>,
                _si_flags: types::Siflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<types::Size, Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'a: 'async_trait,
                'life0: 'async_trait,
                'life1: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<types::Size, Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let _si_flags = _si_flags;
                    let __ret: Result<types::Size, Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::WRITE)?;
                        let guest_slices: Vec<wiggle::GuestCow<u8>> = si_data
                            .iter()
                            .map(|iov_ptr| {
                                let iov_ptr = iov_ptr?;
                                let iov: types::Ciovec = iov_ptr.read()?;
                                Ok(iov.buf.as_array(iov.buf_len).as_cow()?)
                            })
                            .collect::<Result<_, Error>>()?;
                        let ioslices: Vec<IoSlice> = guest_slices
                            .iter()
                            .map(|s| IoSlice::new(s.deref()))
                            .collect();
                        let bytes_written = f
                            .sock_send(&ioslices, SiFlags::empty())
                            .await?;
                        Ok(types::Size::try_from(bytes_written)?)
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn sock_shutdown<'life0, 'async_trait>(
                &'life0 mut self,
                fd: types::Fd,
                how: types::Sdflags,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let fd = fd;
                    let how = how;
                    let __ret: Result<(), Error> = {
                        let f = __self.table().get_file(u32::from(fd))?;
                        let f = f.get_cap(FileCaps::FDSTAT_SET_FLAGS)?;
                        f.sock_shutdown(SdFlags::from(how)).await
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
            #[allow(
                clippy::async_yields_async,
                clippy::let_unit_value,
                clippy::no_effect_underscore_binding,
                clippy::shadow_same,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn rdma_list<'life0, 'async_trait>(
                &'life0 mut self,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<
                        Output = Result<(), Error>,
                    > + ::core::marker::Send + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret)
                        = ::core::option::Option::None::<Result<(), Error>> {
                        return __ret;
                    }
                    let mut __self = self;
                    let __ret: Result<(), Error> = {
                        {
                            ::std::io::_print(format_args!("rdma_list test\n"));
                        };
                        new_test();
                        Ok(())
                    };
                    #[allow(unreachable_code)] __ret
                })
            }
        }
        use rdma_sys::*;
        use std::{env, process::exit, ptr::null_mut};
        use std::time::{SystemTime, UNIX_EPOCH};
        fn new_test() {
            let body = async {
                {
                    ::std::io::_print(format_args!("rdma_client: start\n"));
                };
                let ip = SERVER;
                let port = PORT;
                std::thread::spawn(move || server_runs());
                tokio::time::sleep(Duration::new(1, 0)).await;
                let now1 = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_micros();
                {
                    ::std::io::_print(format_args!("the current time is {0:?}\n", now1));
                };
                let ret = run(ip, port);
                let now2 = SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_micros();
                {
                    ::std::io::_print(format_args!("the end time is {0:?}\n", now2));
                };
                {
                    ::std::io::_print(
                        format_args!("the between time is {0:?}\n", now2 - now1),
                    );
                };
                if ret != 0 {
                    {
                        ::std::io::_print(
                            format_args!(
                                "rdma_client: ret error {0:?}\n",
                                std::io::Error::from_raw_os_error(- ret)
                            ),
                        );
                    };
                    if ret == -1 {
                        {
                            ::std::io::_print(
                                format_args!(
                                    "rdma_client: last os error {0:?}\n",
                                    std::io::Error::last_os_error()
                                ),
                            );
                        };
                    }
                }
                {
                    ::std::io::_print(format_args!("rdma_client: end\n\n"));
                };
            };
            #[allow(clippy::expect_used)]
            tokio::runtime::Builder::new_multi_thread()
                .enable_all()
                .build()
                .expect("Failed building the Runtime")
                .block_on(body);
        }
        fn server_runs() {
            {
                ::std::io::_print(format_args!("rdma_server: start\n"));
            };
            let ret = server_run();
            if ret != 0 {
                {
                    ::std::io::_print(
                        format_args!(
                            "rdma_server: ret error {0:?}\n",
                            std::io::Error::from_raw_os_error(- ret)
                        ),
                    );
                };
                if ret == -1 {
                    {
                        ::std::io::_print(
                            format_args!(
                                "rdma_server: last os error {0:?}\n",
                                std::io::Error::last_os_error()
                            ),
                        );
                    };
                }
            }
            {
                ::std::io::_print(format_args!("rdma_server: end\n"));
            };
        }
        fn run(ip: &str, port: &str) -> i32 {
            let mut send_msg = ::alloc::vec::from_elem(1_u8, 16);
            let mut recv_msg = ::alloc::vec::from_elem(0_u8, 16);
            let mut hints = unsafe { std::mem::zeroed::<rdma_addrinfo>() };
            let mut res: *mut rdma_addrinfo = null_mut();
            hints.ai_port_space = rdma_port_space::RDMA_PS_TCP as i32;
            let mut ret = unsafe {
                rdma_getaddrinfo(
                    ip.as_ptr().cast(),
                    port.as_ptr().cast(),
                    &hints,
                    &mut res,
                )
            };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_getaddrinfo\n"));
                };
                return ret;
            }
            let mut attr = unsafe { std::mem::zeroed::<ibv_qp_init_attr>() };
            let mut id: *mut rdma_cm_id = null_mut();
            attr.cap.max_send_wr = 1;
            attr.cap.max_recv_wr = 1;
            attr.cap.max_send_sge = 1;
            attr.cap.max_recv_sge = 1;
            attr.cap.max_inline_data = 16;
            attr.qp_context = id.cast();
            attr.sq_sig_all = 1;
            ret = unsafe { rdma_create_ep(&mut id, res, null_mut(), &mut attr) };
            let mut send_flags = 0_u32;
            if attr.cap.max_inline_data >= 16 {
                send_flags = ibv_send_flags::IBV_SEND_INLINE.0;
            } else {
                {
                    ::std::io::_print(
                        format_args!(
                            "rdma_client: device doesn\'t support IBV_SEND_INLINE, using sge sends\n"
                        ),
                    );
                };
            }
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_create_ep\n"));
                };
                unsafe {
                    rdma_freeaddrinfo(res);
                }
                return ret;
            }
            let mr = unsafe { rdma_reg_msgs(id, recv_msg.as_mut_ptr().cast(), 16) };
            if mr.is_null() {
                {
                    ::std::io::_print(format_args!("rdma_reg_msgs for recv_msg\n"));
                };
                unsafe {
                    rdma_destroy_ep(id);
                }
                return -1;
            }
            let mut send_mr = null_mut();
            if (send_flags & ibv_send_flags::IBV_SEND_INLINE.0) as u32 == 0 {
                {
                    ::std::io::_print(format_args!("flags {0:?}\n", send_flags));
                };
                send_mr = unsafe { rdma_reg_msgs(id, send_msg.as_mut_ptr().cast(), 16) };
                if send_mr.is_null() {
                    {
                        ::std::io::_print(format_args!("rdma_reg_msgs for send_msg\n"));
                    };
                    unsafe {
                        rdma_dereg_mr(mr);
                    }
                    return -1;
                }
            }
            ret = unsafe {
                rdma_post_recv(id, null_mut(), recv_msg.as_mut_ptr().cast(), 16, mr)
            };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_post_recv\n"));
                };
                if (send_flags & ibv_send_flags::IBV_SEND_INLINE.0) as u32 == 0 {
                    unsafe { rdma_dereg_mr(send_mr) };
                }
                return ret;
            }
            ret = unsafe { rdma_connect(id, null_mut()) };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_connect\n"));
                };
                unsafe {
                    rdma_disconnect(id);
                }
                return ret;
            }
            ret = unsafe {
                rdma_post_send(
                    id,
                    null_mut(),
                    send_msg.as_mut_ptr().cast(),
                    16,
                    send_mr,
                    send_flags.try_into().unwrap(),
                )
            };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_post_send\n"));
                };
                unsafe {
                    rdma_disconnect(id);
                }
                return ret;
            }
            let mut wc = unsafe { std::mem::zeroed::<ibv_wc>() };
            while ret == 0 {
                ret = unsafe { rdma_get_send_comp(id, &mut wc) };
            }
            if ret < 0 {
                {
                    ::std::io::_print(format_args!("rdma_get_send_comp\n"));
                };
                unsafe {
                    rdma_disconnect(id);
                }
                return ret;
            }
            ret = 0;
            while ret == 0 {
                ret = unsafe { rdma_get_recv_comp(id, &mut wc) };
            }
            {
                ::std::io::_print(
                    format_args!("rdma_client: recv msg : {0:?}\n", recv_msg),
                );
            };
            if ret < 0 {
                {
                    ::std::io::_print(format_args!("rdma_get_recv_comp\n"));
                };
            } else {
                ret = 0;
            }
            ret
        }
        async fn client(addr: SocketAddrV4) -> io::Result<()> {
            let layout = Layout::new::<[u8; 8]>();
            let rdma = RdmaBuilder::default().connect(addr).await?;
            let mut rmr = rdma.request_remote_mr(layout).await?;
            let mut lmr = rdma.alloc_local_mr(layout)?;
            let _num = lmr.as_mut_slice().write(&[1_u8; 8])?;
            rdma.write(&lmr.get(4..8).unwrap(), &mut rmr.get_mut(4..8).unwrap()).await?;
            rdma.send_remote_mr(rmr).await?;
            Ok(())
        }
        fn server(addr: SocketAddrV4) -> io::Result<()> {
            let body = async {
                let rdma = RdmaBuilder::default().listen(addr).await?;
                let lmr = rdma.receive_local_mr().await?;
                let data = *lmr.as_slice();
                {
                    ::std::io::_print(
                        format_args!(
                            "Data written by the client using RDMA WRITE: {0:?}\n", data
                        ),
                    );
                };
                match (&data, &[[0_u8; 4], [1_u8; 4]].concat()) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
                Ok(())
            };
            #[allow(clippy::expect_used)]
            tokio::runtime::Builder::new_multi_thread()
                .enable_all()
                .build()
                .expect("Failed building the Runtime")
                .block_on(body)
        }
        fn test() {
            let body = async {
                let addr = SocketAddrV4::new(
                    Ipv4Addr::new(127, 0, 0, 1),
                    pick_unused_port().unwrap(),
                );
                std::thread::spawn(move || server(addr));
                tokio::time::sleep(Duration::new(1, 0)).await;
                client(addr)
                    .await
                    .map_err(|err| {
                        ::std::io::_print(format_args!("{0}\n", err));
                    })
                    .unwrap();
            };
            #[allow(clippy::expect_used)]
            tokio::runtime::Builder::new_multi_thread()
                .enable_all()
                .build()
                .expect("Failed building the Runtime")
                .block_on(body);
        }
        fn server_run() -> i32 {
            let mut send_msg = ::alloc::vec::from_elem(1_u8, 16);
            let mut recv_msg = ::alloc::vec::from_elem(0_u8, 16);
            let mut hints = unsafe { std::mem::zeroed::<rdma_addrinfo>() };
            let mut res: *mut rdma_addrinfo = null_mut();
            hints.ai_flags = RAI_PASSIVE.try_into().unwrap();
            hints.ai_port_space = rdma_port_space::RDMA_PS_TCP.try_into().unwrap();
            let mut ret = unsafe {
                rdma_getaddrinfo(
                    SERVER.as_ptr().cast(),
                    PORT.as_ptr().cast(),
                    &hints,
                    &mut res,
                )
            };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_getaddrinfo\n"));
                };
                return ret;
            }
            let mut listen_id = null_mut();
            let mut id = null_mut();
            let mut init_attr = unsafe { std::mem::zeroed::<ibv_qp_init_attr>() };
            init_attr.cap.max_send_wr = 1;
            init_attr.cap.max_recv_wr = 1;
            init_attr.cap.max_send_sge = 1;
            init_attr.cap.max_recv_sge = 1;
            init_attr.cap.max_inline_data = 16;
            init_attr.sq_sig_all = 1;
            ret = unsafe {
                rdma_create_ep(&mut listen_id, res, null_mut(), &mut init_attr)
            };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_create_ep\n"));
                };
                unsafe {
                    rdma_freeaddrinfo(res);
                }
                return ret;
            }
            ret = unsafe { rdma_listen(listen_id, 0) };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_listen\n"));
                };
                unsafe {
                    rdma_destroy_ep(listen_id);
                }
                return ret;
            }
            ret = unsafe { rdma_get_request(listen_id, &mut id) };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_get_request\n"));
                };
                unsafe {
                    rdma_destroy_ep(listen_id);
                }
                return ret;
            }
            let mut qp_attr = unsafe { std::mem::zeroed::<ibv_qp_attr>() };
            ret = unsafe {
                ibv_query_qp(
                    (*id).qp,
                    &mut qp_attr,
                    ibv_qp_attr_mask::IBV_QP_CAP.0.try_into().unwrap(),
                    &mut init_attr,
                )
            };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("ibv_query_qp\n"));
                };
                unsafe {
                    rdma_destroy_ep(id);
                }
                return ret;
            }
            let mut send_flags = 0_u32;
            if init_attr.cap.max_inline_data >= 16 {
                send_flags = ibv_send_flags::IBV_SEND_INLINE.0;
            } else {
                {
                    ::std::io::_print(
                        format_args!(
                            "rdma_server: device doesn\'t support IBV_SEND_INLINE, using sge sends\n"
                        ),
                    );
                };
            }
            let recv_mr = unsafe { rdma_reg_msgs(id, recv_msg.as_mut_ptr().cast(), 16) };
            if recv_mr.is_null() {
                ret = -1;
                {
                    ::std::io::_print(format_args!("rdma_reg_msgs for recv_msg\n"));
                };
                unsafe {
                    rdma_dereg_mr(recv_mr);
                }
                return ret;
            }
            let mut send_mr = null_mut();
            if (send_flags & ibv_send_flags::IBV_SEND_INLINE.0) == 0 {
                send_mr = unsafe { rdma_reg_msgs(id, send_msg.as_mut_ptr().cast(), 16) };
                if send_mr.is_null() {
                    ret = -1;
                    {
                        ::std::io::_print(format_args!("rdma_reg_msgs for send_msg\n"));
                    };
                    unsafe {
                        rdma_dereg_mr(recv_mr);
                    }
                    return ret;
                }
            }
            ret = unsafe {
                rdma_post_recv(id, null_mut(), recv_msg.as_mut_ptr().cast(), 16, recv_mr)
            };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_post_recv\n"));
                };
                unsafe {
                    rdma_dereg_mr(recv_mr);
                }
                return ret;
            }
            ret = unsafe { rdma_accept(id, null_mut()) };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_accept\n"));
                };
                if (send_flags & ibv_send_flags::IBV_SEND_INLINE.0) == 0 {
                    unsafe { rdma_dereg_mr(send_mr) };
                }
                return ret;
            }
            let mut wc = unsafe { std::mem::zeroed::<ibv_wc>() };
            while ret == 0 {
                ret = unsafe { rdma_get_recv_comp(id, &mut wc) };
            }
            if ret < 0 {
                {
                    ::std::io::_print(format_args!("rdma_get_recv_comp\n"));
                };
                unsafe {
                    rdma_disconnect(id);
                }
                return ret;
            }
            {
                ::std::io::_print(
                    format_args!("rdma_server: recv msg : {0:?}\n", recv_msg),
                );
            };
            ret = unsafe {
                rdma_post_send(
                    id,
                    null_mut(),
                    send_msg.as_mut_ptr().cast(),
                    16,
                    send_mr,
                    send_flags.try_into().unwrap(),
                )
            };
            if ret != 0 {
                {
                    ::std::io::_print(format_args!("rdma_post_send\n"));
                };
                unsafe {
                    rdma_disconnect(id);
                }
                return ret;
            }
            while ret == 0 {
                ret = unsafe { rdma_get_send_comp(id, &mut wc) };
            }
            if ret < 0 {
                {
                    ::std::io::_print(format_args!("rdma_get_send_comp\n"));
                };
            } else {
                ret = 0;
            }
            ret
        }
        static SERVER: &str = "192.168.217.128\0";
        static PORT: &str = "7471\0";
        impl From<types::Advice> for Advice {
            fn from(advice: types::Advice) -> Advice {
                match advice {
                    types::Advice::Normal => Advice::Normal,
                    types::Advice::Sequential => Advice::Sequential,
                    types::Advice::Random => Advice::Random,
                    types::Advice::Willneed => Advice::WillNeed,
                    types::Advice::Dontneed => Advice::DontNeed,
                    types::Advice::Noreuse => Advice::NoReuse,
                }
            }
        }
        impl From<&FdStat> for types::Fdstat {
            fn from(fdstat: &FdStat) -> types::Fdstat {
                types::Fdstat {
                    fs_filetype: types::Filetype::from(&fdstat.filetype),
                    fs_rights_base: types::Rights::from(&fdstat.caps),
                    fs_rights_inheriting: types::Rights::empty(),
                    fs_flags: types::Fdflags::from(fdstat.flags),
                }
            }
        }
        impl From<&DirFdStat> for types::Fdstat {
            fn from(dirstat: &DirFdStat) -> types::Fdstat {
                let fs_rights_base = types::Rights::from(&dirstat.dir_caps);
                let fs_rights_inheriting = types::Rights::from(&dirstat.file_caps)
                    | fs_rights_base;
                types::Fdstat {
                    fs_filetype: types::Filetype::Directory,
                    fs_rights_base,
                    fs_rights_inheriting,
                    fs_flags: types::Fdflags::empty(),
                }
            }
        }
        impl From<&FileCaps> for types::Rights {
            fn from(caps: &FileCaps) -> types::Rights {
                let mut rights = types::Rights::empty();
                if caps.contains(FileCaps::DATASYNC) {
                    rights = rights | types::Rights::FD_DATASYNC;
                }
                if caps.contains(FileCaps::READ) {
                    rights = rights | types::Rights::FD_READ;
                }
                if caps.contains(FileCaps::SEEK) {
                    rights = rights | types::Rights::FD_SEEK;
                }
                if caps.contains(FileCaps::FDSTAT_SET_FLAGS) {
                    rights = rights | types::Rights::FD_FDSTAT_SET_FLAGS;
                }
                if caps.contains(FileCaps::SYNC) {
                    rights = rights | types::Rights::FD_SYNC;
                }
                if caps.contains(FileCaps::TELL) {
                    rights = rights | types::Rights::FD_TELL;
                }
                if caps.contains(FileCaps::WRITE) {
                    rights = rights | types::Rights::FD_WRITE;
                }
                if caps.contains(FileCaps::ADVISE) {
                    rights = rights | types::Rights::FD_ADVISE;
                }
                if caps.contains(FileCaps::ALLOCATE) {
                    rights = rights | types::Rights::FD_ALLOCATE;
                }
                if caps.contains(FileCaps::FILESTAT_GET) {
                    rights = rights | types::Rights::FD_FILESTAT_GET;
                }
                if caps.contains(FileCaps::FILESTAT_SET_SIZE) {
                    rights = rights | types::Rights::FD_FILESTAT_SET_SIZE;
                }
                if caps.contains(FileCaps::FILESTAT_SET_TIMES) {
                    rights = rights | types::Rights::FD_FILESTAT_SET_TIMES;
                }
                if caps.contains(FileCaps::POLL_READWRITE) {
                    rights = rights | types::Rights::POLL_FD_READWRITE;
                }
                rights
            }
        }
        impl From<&types::Rights> for FileCaps {
            fn from(rights: &types::Rights) -> FileCaps {
                let mut caps = FileCaps::empty();
                if rights.contains(types::Rights::FD_DATASYNC) {
                    caps = caps | FileCaps::DATASYNC;
                }
                if rights.contains(types::Rights::FD_READ) {
                    caps = caps | FileCaps::READ;
                }
                if rights.contains(types::Rights::FD_SEEK) {
                    caps = caps | FileCaps::SEEK;
                }
                if rights.contains(types::Rights::FD_FDSTAT_SET_FLAGS) {
                    caps = caps | FileCaps::FDSTAT_SET_FLAGS;
                }
                if rights.contains(types::Rights::FD_SYNC) {
                    caps = caps | FileCaps::SYNC;
                }
                if rights.contains(types::Rights::FD_TELL) {
                    caps = caps | FileCaps::TELL;
                }
                if rights.contains(types::Rights::FD_WRITE) {
                    caps = caps | FileCaps::WRITE;
                }
                if rights.contains(types::Rights::FD_ADVISE) {
                    caps = caps | FileCaps::ADVISE;
                }
                if rights.contains(types::Rights::FD_ALLOCATE) {
                    caps = caps | FileCaps::ALLOCATE;
                }
                if rights.contains(types::Rights::FD_FILESTAT_GET) {
                    caps = caps | FileCaps::FILESTAT_GET;
                }
                if rights.contains(types::Rights::FD_FILESTAT_SET_SIZE) {
                    caps = caps | FileCaps::FILESTAT_SET_SIZE;
                }
                if rights.contains(types::Rights::FD_FILESTAT_SET_TIMES) {
                    caps = caps | FileCaps::FILESTAT_SET_TIMES;
                }
                if rights.contains(types::Rights::POLL_FD_READWRITE) {
                    caps = caps | FileCaps::POLL_READWRITE;
                }
                caps
            }
        }
        impl From<&DirCaps> for types::Rights {
            fn from(caps: &DirCaps) -> types::Rights {
                let mut rights = types::Rights::empty();
                if caps.contains(DirCaps::CREATE_DIRECTORY) {
                    rights = rights | types::Rights::PATH_CREATE_DIRECTORY;
                }
                if caps.contains(DirCaps::CREATE_FILE) {
                    rights = rights | types::Rights::PATH_CREATE_FILE;
                }
                if caps.contains(DirCaps::LINK_SOURCE) {
                    rights = rights | types::Rights::PATH_LINK_SOURCE;
                }
                if caps.contains(DirCaps::LINK_TARGET) {
                    rights = rights | types::Rights::PATH_LINK_TARGET;
                }
                if caps.contains(DirCaps::OPEN) {
                    rights = rights | types::Rights::PATH_OPEN;
                }
                if caps.contains(DirCaps::READDIR) {
                    rights = rights | types::Rights::FD_READDIR;
                }
                if caps.contains(DirCaps::READLINK) {
                    rights = rights | types::Rights::PATH_READLINK;
                }
                if caps.contains(DirCaps::RENAME_SOURCE) {
                    rights = rights | types::Rights::PATH_RENAME_SOURCE;
                }
                if caps.contains(DirCaps::RENAME_TARGET) {
                    rights = rights | types::Rights::PATH_RENAME_TARGET;
                }
                if caps.contains(DirCaps::SYMLINK) {
                    rights = rights | types::Rights::PATH_SYMLINK;
                }
                if caps.contains(DirCaps::REMOVE_DIRECTORY) {
                    rights = rights | types::Rights::PATH_REMOVE_DIRECTORY;
                }
                if caps.contains(DirCaps::UNLINK_FILE) {
                    rights = rights | types::Rights::PATH_UNLINK_FILE;
                }
                if caps.contains(DirCaps::PATH_FILESTAT_GET) {
                    rights = rights | types::Rights::PATH_FILESTAT_GET;
                }
                if caps.contains(DirCaps::PATH_FILESTAT_SET_TIMES) {
                    rights = rights | types::Rights::PATH_FILESTAT_SET_TIMES;
                }
                if caps.contains(DirCaps::FILESTAT_GET) {
                    rights = rights | types::Rights::FD_FILESTAT_GET;
                }
                if caps.contains(DirCaps::FILESTAT_SET_TIMES) {
                    rights = rights | types::Rights::FD_FILESTAT_SET_TIMES;
                }
                rights
            }
        }
        impl From<&types::Rights> for DirCaps {
            fn from(rights: &types::Rights) -> DirCaps {
                let mut caps = DirCaps::empty();
                if rights.contains(types::Rights::PATH_CREATE_DIRECTORY) {
                    caps = caps | DirCaps::CREATE_DIRECTORY;
                }
                if rights.contains(types::Rights::PATH_CREATE_FILE) {
                    caps = caps | DirCaps::CREATE_FILE;
                }
                if rights.contains(types::Rights::PATH_LINK_SOURCE) {
                    caps = caps | DirCaps::LINK_SOURCE;
                }
                if rights.contains(types::Rights::PATH_LINK_TARGET) {
                    caps = caps | DirCaps::LINK_TARGET;
                }
                if rights.contains(types::Rights::PATH_OPEN) {
                    caps = caps | DirCaps::OPEN;
                }
                if rights.contains(types::Rights::FD_READDIR) {
                    caps = caps | DirCaps::READDIR;
                }
                if rights.contains(types::Rights::PATH_READLINK) {
                    caps = caps | DirCaps::READLINK;
                }
                if rights.contains(types::Rights::PATH_RENAME_SOURCE) {
                    caps = caps | DirCaps::RENAME_SOURCE;
                }
                if rights.contains(types::Rights::PATH_RENAME_TARGET) {
                    caps = caps | DirCaps::RENAME_TARGET;
                }
                if rights.contains(types::Rights::PATH_SYMLINK) {
                    caps = caps | DirCaps::SYMLINK;
                }
                if rights.contains(types::Rights::PATH_REMOVE_DIRECTORY) {
                    caps = caps | DirCaps::REMOVE_DIRECTORY;
                }
                if rights.contains(types::Rights::PATH_UNLINK_FILE) {
                    caps = caps | DirCaps::UNLINK_FILE;
                }
                if rights.contains(types::Rights::PATH_FILESTAT_GET) {
                    caps = caps | DirCaps::PATH_FILESTAT_GET;
                }
                if rights.contains(types::Rights::PATH_FILESTAT_SET_TIMES) {
                    caps = caps | DirCaps::PATH_FILESTAT_SET_TIMES;
                }
                if rights.contains(types::Rights::FD_FILESTAT_GET) {
                    caps = caps | DirCaps::FILESTAT_GET;
                }
                if rights.contains(types::Rights::FD_FILESTAT_SET_TIMES) {
                    caps = caps | DirCaps::FILESTAT_SET_TIMES;
                }
                caps
            }
        }
        impl From<&FileType> for types::Filetype {
            fn from(ft: &FileType) -> types::Filetype {
                match ft {
                    FileType::Directory => types::Filetype::Directory,
                    FileType::BlockDevice => types::Filetype::BlockDevice,
                    FileType::CharacterDevice => types::Filetype::CharacterDevice,
                    FileType::RegularFile => types::Filetype::RegularFile,
                    FileType::SocketDgram => types::Filetype::SocketDgram,
                    FileType::SocketStream => types::Filetype::SocketStream,
                    FileType::SymbolicLink => types::Filetype::SymbolicLink,
                    FileType::Unknown => types::Filetype::Unknown,
                    FileType::Pipe => types::Filetype::Unknown,
                }
            }
        }
        impl From<FdFlags> for types::Fdflags {
            fn from(f: FdFlags) -> types::Fdflags {
                let mut out = <types::Fdflags>::empty();
                if f.contains(<FdFlags>::APPEND) {
                    out |= <types::Fdflags>::APPEND;
                }
                if f.contains(<FdFlags>::DSYNC) {
                    out |= <types::Fdflags>::DSYNC;
                }
                if f.contains(<FdFlags>::NONBLOCK) {
                    out |= <types::Fdflags>::NONBLOCK;
                }
                if f.contains(<FdFlags>::RSYNC) {
                    out |= <types::Fdflags>::RSYNC;
                }
                if f.contains(<FdFlags>::SYNC) {
                    out |= <types::Fdflags>::SYNC;
                }
                out
            }
        }
        impl From<types::Fdflags> for FdFlags {
            fn from(f: types::Fdflags) -> FdFlags {
                let mut out = <FdFlags>::empty();
                if f.contains(<types::Fdflags>::APPEND) {
                    out |= <FdFlags>::APPEND;
                }
                if f.contains(<types::Fdflags>::DSYNC) {
                    out |= <FdFlags>::DSYNC;
                }
                if f.contains(<types::Fdflags>::NONBLOCK) {
                    out |= <FdFlags>::NONBLOCK;
                }
                if f.contains(<types::Fdflags>::RSYNC) {
                    out |= <FdFlags>::RSYNC;
                }
                if f.contains(<types::Fdflags>::SYNC) {
                    out |= <FdFlags>::SYNC;
                }
                out
            }
        }
        impl From<RiFlags> for types::Riflags {
            fn from(f: RiFlags) -> types::Riflags {
                let mut out = <types::Riflags>::empty();
                if f.contains(<RiFlags>::RECV_PEEK) {
                    out |= <types::Riflags>::RECV_PEEK;
                }
                if f.contains(<RiFlags>::RECV_WAITALL) {
                    out |= <types::Riflags>::RECV_WAITALL;
                }
                out
            }
        }
        impl From<types::Riflags> for RiFlags {
            fn from(f: types::Riflags) -> RiFlags {
                let mut out = <RiFlags>::empty();
                if f.contains(<types::Riflags>::RECV_PEEK) {
                    out |= <RiFlags>::RECV_PEEK;
                }
                if f.contains(<types::Riflags>::RECV_WAITALL) {
                    out |= <RiFlags>::RECV_WAITALL;
                }
                out
            }
        }
        impl From<RoFlags> for types::Roflags {
            fn from(f: RoFlags) -> types::Roflags {
                let mut out = <types::Roflags>::empty();
                if f.contains(<RoFlags>::RECV_DATA_TRUNCATED) {
                    out |= <types::Roflags>::RECV_DATA_TRUNCATED;
                }
                out
            }
        }
        impl From<types::Roflags> for RoFlags {
            fn from(f: types::Roflags) -> RoFlags {
                let mut out = <RoFlags>::empty();
                if f.contains(<types::Roflags>::RECV_DATA_TRUNCATED) {
                    out |= <RoFlags>::RECV_DATA_TRUNCATED;
                }
                out
            }
        }
        impl From<SdFlags> for types::Sdflags {
            fn from(f: SdFlags) -> types::Sdflags {
                let mut out = <types::Sdflags>::empty();
                if f.contains(<SdFlags>::RD) {
                    out |= <types::Sdflags>::RD;
                }
                if f.contains(<SdFlags>::WR) {
                    out |= <types::Sdflags>::WR;
                }
                out
            }
        }
        impl From<types::Sdflags> for SdFlags {
            fn from(f: types::Sdflags) -> SdFlags {
                let mut out = <SdFlags>::empty();
                if f.contains(<types::Sdflags>::RD) {
                    out |= <SdFlags>::RD;
                }
                if f.contains(<types::Sdflags>::WR) {
                    out |= <SdFlags>::WR;
                }
                out
            }
        }
        impl From<&types::Oflags> for OFlags {
            fn from(oflags: &types::Oflags) -> OFlags {
                let mut out = OFlags::empty();
                if oflags.contains(types::Oflags::CREAT) {
                    out = out | OFlags::CREATE;
                }
                if oflags.contains(types::Oflags::DIRECTORY) {
                    out = out | OFlags::DIRECTORY;
                }
                if oflags.contains(types::Oflags::EXCL) {
                    out = out | OFlags::EXCLUSIVE;
                }
                if oflags.contains(types::Oflags::TRUNC) {
                    out = out | OFlags::TRUNCATE;
                }
                out
            }
        }
        impl From<&OFlags> for types::Oflags {
            fn from(oflags: &OFlags) -> types::Oflags {
                let mut out = types::Oflags::empty();
                if oflags.contains(OFlags::CREATE) {
                    out = out | types::Oflags::CREAT;
                }
                if oflags.contains(OFlags::DIRECTORY) {
                    out = out | types::Oflags::DIRECTORY;
                }
                if oflags.contains(OFlags::EXCLUSIVE) {
                    out = out | types::Oflags::EXCL;
                }
                if oflags.contains(OFlags::TRUNCATE) {
                    out = out | types::Oflags::TRUNC;
                }
                out
            }
        }
        impl From<Filestat> for types::Filestat {
            fn from(stat: Filestat) -> types::Filestat {
                types::Filestat {
                    dev: stat.device_id,
                    ino: stat.inode,
                    filetype: types::Filetype::from(&stat.filetype),
                    nlink: stat.nlink,
                    size: stat.size,
                    atim: stat
                        .atim
                        .map(|t| {
                            t.duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos()
                                as u64
                        })
                        .unwrap_or(0),
                    mtim: stat
                        .mtim
                        .map(|t| {
                            t.duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos()
                                as u64
                        })
                        .unwrap_or(0),
                    ctim: stat
                        .ctim
                        .map(|t| {
                            t.duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos()
                                as u64
                        })
                        .unwrap_or(0),
                }
            }
        }
        impl TryFrom<&ReaddirEntity> for types::Dirent {
            type Error = Error;
            fn try_from(e: &ReaddirEntity) -> Result<types::Dirent, Error> {
                Ok(types::Dirent {
                    d_ino: e.inode,
                    d_namlen: e.name.as_bytes().len().try_into()?,
                    d_type: types::Filetype::from(&e.filetype),
                    d_next: e.next.into(),
                })
            }
        }
        fn dirent_bytes(dirent: types::Dirent) -> Vec<u8> {
            use wiggle::GuestType;
            match (
                &types::Dirent::guest_size(),
                &(std::mem::size_of::<types::Dirent>() as _),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::Some(
                                format_args!("Dirent guest repr and host repr should match"),
                            ),
                        );
                    }
                }
            };
            match (&1, &std::mem::size_of_val(&dirent.d_type)) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::Some(
                                format_args!(
                                    "Dirent member d_type should be endian-invariant"
                                ),
                            ),
                        );
                    }
                }
            };
            let size = types::Dirent::guest_size()
                .try_into()
                .expect("Dirent is smaller than 2^32");
            let mut bytes = Vec::with_capacity(size);
            bytes.resize(size, 0);
            let ptr = bytes.as_mut_ptr().cast::<types::Dirent>();
            let guest_dirent = types::Dirent {
                d_ino: dirent.d_ino.to_le(),
                d_namlen: dirent.d_namlen.to_le(),
                d_type: dirent.d_type,
                d_next: dirent.d_next.to_le(),
            };
            unsafe { ptr.write_unaligned(guest_dirent) };
            bytes
        }
        impl From<&RwEventFlags> for types::Eventrwflags {
            fn from(flags: &RwEventFlags) -> types::Eventrwflags {
                let mut out = types::Eventrwflags::empty();
                if flags.contains(RwEventFlags::HANGUP) {
                    out = out | types::Eventrwflags::FD_READWRITE_HANGUP;
                }
                out
            }
        }
        fn fd_readwrite_empty() -> types::EventFdReadwrite {
            types::EventFdReadwrite {
                nbytes: 0,
                flags: types::Eventrwflags::empty(),
            }
        }
        fn systimespec(
            set: bool,
            ts: types::Timestamp,
            now: bool,
        ) -> Result<Option<SystemTimeSpec>, Error> {
            if set && now {
                Err(Error::invalid_argument())
            } else if set {
                Ok(
                    Some(
                        SystemTimeSpec::Absolute(
                            SystemClock::UNIX_EPOCH + Duration::from_nanos(ts),
                        ),
                    ),
                )
            } else if now {
                Ok(Some(SystemTimeSpec::SymbolicNow))
            } else {
                Ok(None)
            }
        }
    }
}
mod string_array {
    use crate::{Error, ErrorExt};
    use wiggle::GuestPtr;
    pub struct StringArray {
        elems: Vec<String>,
    }
    pub enum StringArrayError {
        #[error("Number of elements exceeds 2^32")]
        NumberElements,
        #[error("Element size exceeds 2^32")]
        ElementSize,
        #[error("Cumulative size exceeds 2^32")]
        CumulativeSize,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for StringArrayError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    StringArrayError::NumberElements => "NumberElements",
                    StringArrayError::ElementSize => "ElementSize",
                    StringArrayError::CumulativeSize => "CumulativeSize",
                },
            )
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for StringArrayError {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for StringArrayError {
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                StringArrayError::NumberElements {} => {
                    __formatter
                        .write_fmt(format_args!("Number of elements exceeds 2^32"))
                }
                StringArrayError::ElementSize {} => {
                    __formatter.write_fmt(format_args!("Element size exceeds 2^32"))
                }
                StringArrayError::CumulativeSize {} => {
                    __formatter.write_fmt(format_args!("Cumulative size exceeds 2^32"))
                }
            }
        }
    }
    impl StringArray {
        pub fn new() -> Self {
            StringArray { elems: Vec::new() }
        }
        pub fn push(&mut self, elem: String) -> Result<(), StringArrayError> {
            if self.elems.len() + 1 > std::u32::MAX as usize {
                return Err(StringArrayError::NumberElements);
            }
            if elem.as_bytes().len() + 1 > std::u32::MAX as usize {
                return Err(StringArrayError::ElementSize);
            }
            if self.cumulative_size() as usize + elem.as_bytes().len() + 1
                > std::u32::MAX as usize
            {
                return Err(StringArrayError::CumulativeSize);
            }
            self.elems.push(elem);
            Ok(())
        }
        pub fn number_elements(&self) -> u32 {
            self.elems.len() as u32
        }
        pub fn cumulative_size(&self) -> u32 {
            self.elems.iter().map(|e| e.as_bytes().len() + 1).sum::<usize>() as u32
        }
        pub fn write_to_guest<'a>(
            &self,
            buffer: &GuestPtr<'a, u8>,
            element_heads: &GuestPtr<'a, GuestPtr<'a, u8>>,
        ) -> Result<(), Error> {
            let element_heads = element_heads.as_array(self.number_elements());
            let buffer = buffer.as_array(self.cumulative_size());
            let mut cursor = 0;
            for (elem, head) in self.elems.iter().zip(element_heads.iter()) {
                let bytes = elem.as_bytes();
                let len = bytes.len() as u32;
                {
                    let elem_buffer = buffer
                        .get_range(cursor..(cursor + len))
                        .ok_or(Error::invalid_argument())?;
                    elem_buffer.copy_from_slice(bytes)?;
                }
                buffer.get(cursor + len).ok_or(Error::invalid_argument())?.write(0)?;
                head?.write(buffer.get(cursor).expect("already validated"))?;
                cursor += len + 1;
            }
            Ok(())
        }
    }
}
pub mod table {
    use crate::{Error, ErrorExt};
    use std::any::Any;
    use std::collections::HashMap;
    use std::sync::{Arc, RwLock};
    /// The `Table` type is designed to map u32 handles to resources. The table is now part of the
    /// public interface to a `WasiCtx` - it is reference counted so that it can be shared beyond a
    /// `WasiCtx` with other WASI proposals (e.g. `wasi-crypto` and `wasi-nn`) to manage their
    /// resources. Elements in the `Table` are `Any` typed.
    ///
    /// The `Table` type is intended to model how the Interface Types concept of Resources is shaping
    /// up. Right now it is just an approximation.
    pub struct Table(RwLock<Inner>);
    struct Inner {
        map: HashMap<u32, Arc<dyn Any + Send + Sync>>,
        next_key: u32,
    }
    impl Table {
        /// Create an empty table. New insertions will begin at 3, above stdio.
        pub fn new() -> Self {
            Table(
                RwLock::new(Inner {
                    map: HashMap::new(),
                    next_key: 3,
                }),
            )
        }
        /// Insert a resource at a certain index.
        pub fn insert_at<T: Any + Send + Sync>(&self, key: u32, a: Arc<T>) {
            self.0.write().unwrap().map.insert(key, a);
        }
        /// Insert a resource at the next available index.
        pub fn push<T: Any + Send + Sync>(&self, a: Arc<T>) -> Result<u32, Error> {
            let mut inner = self.0.write().unwrap();
            if inner.map.len() == u32::MAX as usize {
                return Err(Error::trap(anyhow::Error::msg("table has no free keys")));
            }
            loop {
                let key = inner.next_key;
                inner.next_key += 1;
                if inner.map.contains_key(&key) {
                    continue;
                }
                inner.map.insert(key, a);
                return Ok(key);
            }
        }
        /// Check if the table has a resource at the given index.
        pub fn contains_key(&self, key: u32) -> bool {
            self.0.read().unwrap().map.contains_key(&key)
        }
        /// Check if the resource at a given index can be downcast to a given type.
        /// Note: this will always fail if the resource is already borrowed.
        pub fn is<T: Any + Sized>(&self, key: u32) -> bool {
            if let Some(r) = self.0.read().unwrap().map.get(&key) {
                r.is::<T>()
            } else {
                false
            }
        }
        /// Get an Arc reference to a resource of a given type at a given index. Multiple
        /// immutable references can be borrowed at any given time.
        pub fn get<T: Any + Send + Sync + Sized>(
            &self,
            key: u32,
        ) -> Result<Arc<T>, Error> {
            if let Some(r) = self.0.read().unwrap().map.get(&key).cloned() {
                r.downcast::<T>()
                    .map_err(|_| Error::badf().context("element is a different type"))
            } else {
                Err(Error::badf().context("key not in table"))
            }
        }
        /// Get a mutable reference to a resource of a given type at a given index.
        /// Only one such reference can be borrowed at any given time.
        pub fn get_mut<T: Any>(&mut self, key: u32) -> Result<&mut T, Error> {
            let entry = match self.0.get_mut().unwrap().map.get_mut(&key) {
                Some(entry) => entry,
                None => return Err(Error::badf().context("key not in table")),
            };
            let entry = match Arc::get_mut(entry) {
                Some(entry) => entry,
                None => {
                    return Err(
                        Error::badf().context("cannot mutably borrow shared file"),
                    );
                }
            };
            entry
                .downcast_mut::<T>()
                .ok_or_else(|| Error::badf().context("element is a different type"))
        }
        /// Remove a resource at a given index from the table. Returns the resource
        /// if it was present.
        pub fn delete<T: Any + Send + Sync>(&self, key: u32) -> Option<Arc<T>> {
            self.0.write().unwrap().map.remove(&key).map(|r| r.downcast::<T>().unwrap())
        }
        /// Remove a resource at a given index from the table. Returns the resource
        /// if it was present.
        pub fn renumber(&self, from: u32, to: u32) -> Result<(), Error> {
            let map = &mut self.0.write().unwrap().map;
            let from_entry = map.remove(&from).ok_or(Error::badf())?;
            map.insert(to, from_entry);
            Ok(())
        }
    }
}
pub use cap_rand::RngCore;
pub use clocks::{SystemTimeSpec, WasiClocks, WasiMonotonicClock, WasiSystemClock};
pub use ctx::WasiCtx;
pub use dir::WasiDir;
pub use error::{Error, ErrorExt, I32Exit};
pub use file::WasiFile;
pub use sched::{Poll, WasiSched};
pub use string_array::StringArrayError;
pub use table::Table;
